diff --git a/conf/env.mk b/conf/env.mk
index a603f9e..7e96ea9 100644
--- a/conf/env.mk
+++ b/conf/env.mk
@@ -17,4 +17,4 @@ V = @
 # If the makefile cannot find your QEMU binary, uncomment the
 # following line and set it to the full path to QEMU.
 #
-# QEMU=
+ QEMU=/home/swathi/qemu/x86_64-softmmu/qemu-system-x86_64
diff --git a/conf/lab.mk b/conf/lab.mk
index 487e92c..13faa62 100644
--- a/conf/lab.mk
+++ b/conf/lab.mk
@@ -1,2 +1,2 @@
 LAB=4
-PACKAGEDATE=Tue Oct 17 17:42:36 EDT 2017
+PACKAGEDATE=Wed Oct 11 18:27:13 EDT 2017
diff --git a/gradelib.py b/gradelib.py
index 07a7a84..4bb6bed 100644
--- a/gradelib.py
+++ b/gradelib.py
@@ -436,7 +436,7 @@ Failed to shutdown QEMU.  You might need to 'killall qemu' or
     def __monitor_start(self, output):
         if b"\n" in output:
             try:
-                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=30)
+                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=2)
                 raise TerminateTest
             except socket.error:
                 pass
diff --git a/kern/env.c b/kern/env.c
index 0a6a7a6..b64c953 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -119,11 +119,35 @@ env_init(void)
 {
 	// Set up envs array
 	// LAB 3: Your code here.
-
-	// Per-CPU part of the initialization
+                                    
+       // memset (envs, 0, NENV*sizeof(struct Env));               
+        
+        //envs ==> Starting address of memory to be filled
+	//0   ==> Value to be filled
+        //sizeof(struct ENV) * NENV   ==> Number of bytes to be filled starting from envs
+
+	int32_t i;
+	env_free_list = NULL;
+	
+        for (i = NENV; i >= 0; i--) {
+	//initialize backwards to maintain the order
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+        env_free_list = &envs[i];
+    }
+        //envs[i].env_status = ENV_FREE;
+        //envs[i].env_runs = 0;
+        //envs[i].env_type = ENV_TYPE_USER;
+        //envs[i].env_pgdir = NULL;
+	//normal link-list routine
+        
+	
 	env_init_percpu();
 }
 
+
+
+
 // Load GDT and segment descriptors.
 void
 env_init_percpu(void)
@@ -182,14 +206,39 @@ env_setup_vm(struct Env *e)
 	//    - The functions in kern/pmap.h are handy.
 
 	// LAB 3: Your code here.
+	/*e->env_pgdir = page2kva(p);                        
+
+        for(i = 0; i < PDX(UTOP); i++)                     
+        {
+          e->env_pgdir[i] = 0;                             
+        }
 
+        for(i = PDX(UTOP); i < NPDENTRIES; i++)            
+        {
+          e->env_pgdir[i] = kern_pgdir[i];                 //allocating kern_pgdir to the env_pgdir
+        }
+
+        p->pp_ref++;                                       //increment the reference counter if the page is allocated successfully
+	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+	return 0;
+}*/
+
+
+
+e->env_pgdir =(pde_t*) page2kva(p);
+	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
+	
+	//void *memcpy(void *dest, const void *src, size_t n);
+	p->pp_ref++;
 	// UVPT maps the env's own page table read-only.
 	// Permissions: kernel R, user R
 	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
-
+	
 	return 0;
 }
 
+
 //
 // Allocates and initializes a new environment.
 // On success, the new environment is stored in *newenv_store.
@@ -213,7 +262,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 		return r;
 
 	// Generate an env_id for this environment.
-	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1); //~3FF
 	if (generation <= 0)	// Don't create a negative env_id.
 		generation = 1 << ENVGENSHIFT;
 	e->env_id = generation | (e - envs);
@@ -247,6 +296,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 
 	// Enable interrupts while in user mode.
 	// LAB 4: Your code here.
+	e->env_tf.tf_eflags |= FL_IF;
 
 	// Clear the page fault handler until user installs one.
 	e->env_pgfault_upcall = 0;
@@ -279,6 +329,28 @@ region_alloc(struct Env *e, void *va, size_t len)
 	//   'va' and 'len' values that are not page-aligned.
 	//   You should round va down, and round (va + len) up.
 	//   (Watch out for corner-cases!)
+	/*uintptr_t start = ROUNDDOWN((uintptr_t) va, PGSIZE);                            
+        uintptr_t end = ROUNDUP((uintptr_t) va+len, PGSIZE);                            
+
+        for (; start<end; start+=PGSIZE)
+        {
+           struct PageInfo *pp = page_alloc(ALLOC_ZERO);                                
+           if (!pp)                                                                     
+           panic ("No memory");                                                     
+           page_insert(e->env_pgdir, pp, (void*) start, PTE_U | PTE_P | PTE_W);           
+           
+	}
+}*/
+void *start = ROUNDDOWN(va, PGSIZE);
+	void *end = ROUNDUP(start + len, PGSIZE);
+
+	struct PageInfo *p = NULL;
+	for (start; start < end; start += PGSIZE) {
+		p = page_alloc(0);
+		if (p == NULL)
+			panic("Could not allocate a page!");
+		page_insert(e->env_pgdir, p, start, PTE_W | PTE_U | PTE_P);
+	}
 }
 
 //
@@ -338,6 +410,74 @@ load_icode(struct Env *e, uint8_t *binary)
 
 	// Now map one page for the program's initial stack
 	// at virtual address USTACKTOP - PGSIZE.
+	/*struct Proghdr *ph, *eph;                                            
+        struct Elf *ELFHDR = (struct Elf *) binary;               
+                                                                
+        if (ELFHDR->e_magic != ELF_MAGIC)                                   
+		panic ("Not a valid Elf file!");                              
+           
+        // load each program segment 
+        ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff); 
+        eph = ph + ELFHDR->e_phnum;                           
+           
+        lcr3(PADDR(e->env_pgdir));                                           //switch to env_pgdir
+          
+        for (; ph < eph; ph++)                                               //iterate through the program header table
+        {
+
+           if (ph->p_type == ELF_PROG_LOAD)                                  //load segments only when 'ph->p_type == ELF_PROG_LOAD'
+           {
+                 // allocate memory for this binary
+                 region_alloc(e, (void *)ph->p_va, ph->p_memsz);                
+                 // Init .bss
+                 memset((void *)ph->p_va, 0, ph->p_memsz);                      
+                 // Load binary image into memory
+                 memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+           } 
+} 
+	//Modified env's trapframe
+        // other files in trap frame is set in env_alloc.
+        e->env_tf.tf_eip = ELFHDR->e_entry;                                  
+	lcr3(PADDR(kern_pgdir)); 					     //switch back to kern_pgdir
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
+
+	
+	region_alloc(e, (void *)USTACKTOP - PGSIZE, PGSIZE);
+}*/
+
+ struct Elf *ELFHDR = (struct Elf *) binary;
+	struct Proghdr *ph, *eph;
+
+	if (ELFHDR->e_magic != ELF_MAGIC)
+		panic("Not executable!");
+	
+	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
+	eph = ph + ELFHDR->e_phnum;
+	
+	//here above is just as same as main.c
+
+	lcr3(PADDR(e->env_pgdir));
+	//it's silly to use kern_pgdir here.
+
+	for (; ph < eph; ph++)
+		if (ph->p_type == ELF_PROG_LOAD) {
+			region_alloc(e, (void *)ph->p_va, ph->p_memsz);
+			memset((void *)ph->p_va, 0, ph->p_memsz);
+			memcpy((void *)ph->p_va, binary+ph->p_offset, ph->p_filesz);
+		}
+
+	//we can use this because kern_pgdir is a subset of e->env_pgdir
+	lcr3(PADDR(kern_pgdir));
+
+	e->env_tf.tf_eip = ELFHDR->e_entry;
+	//we should set eip to make sure env_pop_tf runs correctly
+
+	region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
 
 	// LAB 3: Your code here.
 }
@@ -353,6 +493,22 @@ void
 env_create(uint8_t *binary, enum EnvType type)
 {
 	// LAB 3: Your code here.
+	
+	struct Env* e;
+
+	int env = env_alloc(&e, 0);                              
+
+	if(env == -E_NO_FREE_ENV)                                
+        { 
+	    panic("no free environments"); 
+	}
+        else if(env == -E_NO_MEM)                                
+        {
+	    panic("no memory"); 
+	}	
+                            
+	load_icode(e, binary);                             //loads the elf binary image into the environment
+	e->env_type = type;                                //set the environment type
 }
 
 //
@@ -483,7 +639,22 @@ env_run(struct Env *e)
 	//	e->env_tf to sensible values.
 
 	// LAB 3: Your code here.
-
-	panic("env_run not yet implemented");
+	if(curenv != e)                                                    
+        {
+          if(curenv && curenv->env_status == ENV_RUNNING)                  
+          {
+              curenv->env_status = ENV_RUNNABLE;                           
+          }
+          curenv = e;                                                      
+          curenv->env_status = ENV_RUNNING;                                
+          curenv->env_runs++;                                              
+          lcr3(PADDR(curenv->env_pgdir));                                   
+        }
+        //step 2
+	 unlock_kernel();
+        env_pop_tf(&curenv->env_tf);                                       
+
+
+	//panic("env_run not yet implemented");
 }
 
diff --git a/kern/init.c b/kern/init.c
index d4eb73b..a81e43a 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -51,6 +51,7 @@ i386_init(void)
 	// Acquire the big kernel lock before waking up APs
 	// Your code here:
 
+lock_kernel();
 	// Starting non-boot CPUs
 	boot_aps();
 
@@ -60,6 +61,18 @@ i386_init(void)
 #else
 	// Touch all you want.
 	ENV_CREATE(user_primes, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_dumbfork, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultread, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultalloc, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultdie, ENV_TYPE_USER);
+      //ENV_CREATE(user_faultallocbad, ENV_TYPE_USER);
+      //ENV_CREATE(user_faultnostack, ENV_TYPE_USER);
+      //ENV_CREATE(user_forktree, ENV_TYPE_USER);
 #endif // TEST*
 
 	// Schedule and run the first user environment!
@@ -82,6 +95,8 @@ boot_aps(void)
 	// Write entry code to unused memory at MPENTRY_PADDR
 	code = KADDR(MPENTRY_PADDR);
 	memmove(code, mpentry_start, mpentry_end - mpentry_start);
+	
+	//void *memmove(void *dest, const void *src, size_t n);
 
 	// Boot each AP one at a time
 	for (c = cpus; c < cpus + ncpu; c++) {
@@ -91,7 +106,8 @@ boot_aps(void)
 		// Tell mpentry.S what stack to use 
 		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
 		// Start the CPU at mpentry_start
-		lapic_startap(c->cpu_id, PADDR(code));
+		lapic_startap(c->cpu_id, PADDR(code)); //Start additional processor running entry code at addr.
+		//lapic_startap(uint8_t apicid, uint32_t addr)
 		// Wait for the CPU to finish some basic setup in mp_main()
 		while(c->cpu_status != CPU_STARTED)
 			;
@@ -116,9 +132,10 @@ mp_main(void)
 	// only one CPU can enter the scheduler at a time!
 	//
 	// Your code here:
-
+	lock_kernel();
+	sched_yield();
 	// Remove this after you finish Exercise 6
-	for (;;);
+	//for (;;);
 }
 
 /*
diff --git a/kern/kdebug.c b/kern/kdebug.c
index f4ee8ee..78772b8 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -142,12 +142,20 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 		// Make sure this memory is valid.
 		// Return -1 if it is not.  Hint: Call user_mem_check.
 		// LAB 3: Your code here.
-
+		
 		stabs = usd->stabs;
 		stab_end = usd->stab_end;
 		stabstr = usd->stabstr;
 		stabstr_end = usd->stabstr_end;
-
+		if(user_mem_check(curenv , usd , sizeof(struct UserStabData) , PTE_U) < 0) {
+			return -1;
+		}
+		if (user_mem_check(curenv , (void *)stabs , (uint32_t)stab_end - (uint32_t)stabs , PTE_U) < 0) {
+			return -1;
+		}
+		if (user_mem_check(curenv , (void *) stabstr , (uint32_t)stabstr_end - (uint32_t)stabstr , PTE_U) < 0) {
+			return -1;
+}
 		// Make sure the STABS and string table memory is valid.
 		// LAB 3: Your code here.
 	}
@@ -204,6 +212,10 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 	//	Look at the STABS documentation and <inc/stab.h> to find
 	//	which one.
 	// Your code here.
+	stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+                 if(lline > rline)
+                 return -1;
+		 info->eip_line = stabs[rline].n_desc;
 
 
 	// Search backwards from the line number for the relevant filename
diff --git a/kern/monitor.c b/kern/monitor.c
index 4e00796..5e50d7a 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -58,7 +58,16 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
 int
 mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 {
-	// Your code here.
+		uint32_t* p=(uint32_t *) read_ebp();
+	cprintf("Stack backtrace:\n");
+	while(p)
+	{
+	 	struct Eipdebuginfo info;
+		cprintf("ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",p, *(p+1),*(p+2),*(p+3),*(p+4),*(p+5),*(p+6));
+		debuginfo_eip(*(p+1), &info);
+		cprintf("\t%s:%d : %.*s+%u\n",info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, (*(p+1)-info.eip_fn_addr));
+		p=(uint32_t*)*p;
+	}
 	return 0;
 }
 
diff --git a/kern/pmap.c b/kern/pmap.c
index 7f2244a..8782f00 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -99,14 +99,25 @@ boot_alloc(uint32_t n)
 		extern char end[];
 		nextfree = ROUNDUP((char *) end, PGSIZE);
 	}
-
 	// Allocate a chunk large enough to hold 'n' bytes, then update
 	// nextfree.  Make sure nextfree is kept aligned
 	// to a multiple of PGSIZE.
 	//
 	// LAB 2: Your code here.
+	 if (n>0) {
+		char *temp = nextfree;
+		nextfree = ROUNDUP((char *) (nextfree+n), PGSIZE);
+		return temp;
+	} 
+	if ((uint32_t)nextfree > KERNBASE + npages*PGSIZE){
+	panic ("boot_alloc failed - Out of memory");
+	}
+	else
+        return nextfree;
+
+	//return NULL;
+
 
-	return NULL;
 }
 
 // Set up a two-level page table:
@@ -128,7 +139,7 @@ mem_init(void)
 	i386_detect_memory();
 
 	// Remove this line when you're ready to test this function.
-	panic("mem_init: This function is not finished\n");
+	//panic("mem_init: This function is not finished\n");
 
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
@@ -151,11 +162,17 @@ mem_init(void)
 	// array.  'npages' is the number of physical pages in memory.  Use memset
 	// to initialize all fields of each struct PageInfo to 0.
 	// Your code goes here:
-
+	
+        pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
+    	memset(pages, 0, sizeof(struct PageInfo) * npages);
+	//pages ==> Starting address of memory to be filled
+	//0   ==> Value to be filled
+        //sizeof(struct PageInfo) * npages   ==> Number of bytes to be filled starting from pages
 
 	//////////////////////////////////////////////////////////////////////
 	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
 	// LAB 3: Your code here.
+	envs = (struct Env *)boot_alloc(NENV*sizeof(struct Env));   
 
 	//////////////////////////////////////////////////////////////////////
 	// Now that we've allocated the initial kernel data structures, we set
@@ -179,6 +196,7 @@ mem_init(void)
 	//      (ie. perm = PTE_U | PTE_P)
 	//    - pages itself -- kernel RW, user NONE
 	// Your code goes here:
+	 boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
 
 	//////////////////////////////////////////////////////////////////////
 	// Map the 'envs' array read-only by the user at linear address UENVS
@@ -187,7 +205,7 @@ mem_init(void)
 	//    - the new image at UENVS  -- kernel R, user R
 	//    - envs itself -- kernel RW, user NONE
 	// LAB 3: Your code here.
-
+	boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);
 	//////////////////////////////////////////////////////////////////////
 	// Use the physical memory that 'bootstack' refers to as the kernel
 	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
@@ -199,7 +217,7 @@ mem_init(void)
 	//       overwrite memory.  Known as a "guard page".
 	//     Permissions: kernel RW, user NONE
 	// Your code goes here:
-
+	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);
 	//////////////////////////////////////////////////////////////////////
 	// Map all of physical memory at KERNBASE.
 	// Ie.  the VA range [KERNBASE, 2^32) should map to
@@ -208,7 +226,7 @@ mem_init(void)
 	// we just set up the mapping anyway.
 	// Permissions: kernel RW, user NONE
 	// Your code goes here:
-
+	 boot_map_region(kern_pgdir, KERNBASE, 0xFFFFFFFF-KERNBASE, 0, PTE_W | PTE_P);
 	// Initialize the SMP-related parts of the memory map
 	mem_init_mp();
 
@@ -259,7 +277,16 @@ mem_init_mp(void)
 	//     Permissions: kernel RW, user NONE
 	//
 	// LAB 4: Your code here:
-
+	
+	int i;
+	for (i = 0; i < NCPU; ++i) {
+		 uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
+		boot_map_region(kern_pgdir, 
+			kstacktop_i - KSTKSIZE, 
+			KSTKSIZE, 
+			PADDR(percpu_kstacks[i]), 
+			PTE_W);
+	}
 }
 
 // --------------------------------------------------------------
@@ -299,10 +326,38 @@ page_init(void)
 	// NB: DO NOT actually touch the physical memory corresponding to
 	// free pages!
 	size_t i;
+	// 0xA0
+	size_t io_hole_begin = IOPHYSMEM / PGSIZE;
+	// 0x100
+	size_t io_hole_end = ROUNDUP(EXTPHYSMEM, PGSIZE) / PGSIZE;
+	size_t kernel_end = io_hole_end + (size_t) (boot_alloc(0) - KERNBASE) / PGSIZE;
+	page_free_list = NULL;
+
+	// i < 0x40FF
 	for (i = 0; i < npages; i++) {
-		pages[i].pp_ref = 0;
-		pages[i].pp_link = page_free_list;
-		page_free_list = &pages[i];
+		// 1)
+		if (i == 0|| i==MPENTRY_PADDR/PGSIZE) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 2) i < 0xA0
+		} else if (i < npages_basemem) {
+			pages[i].pp_ref = 0;
+			pages[i].pp_link = page_free_list;
+			page_free_list = &pages[i];
+		// 3) 0xA0 <= i < 0x100
+		} else if (io_hole_begin <= i && i < io_hole_end) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 4) 0x100 <= i < 0x400 (0xF0400000)
+		} else if (io_hole_end <= i && i < kernel_end) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 4) 0x400 <= i
+		} else {
+			pages[i].pp_ref = 0;
+			pages[i].pp_link = page_free_list;
+			page_free_list = &pages[i];
+		}
 	}
 }
 
@@ -322,7 +377,21 @@ struct PageInfo *
 page_alloc(int alloc_flags)
 {
 	// Fill this function in
-	return 0;
+	struct PageInfo *page;
+	
+	if (page_free_list!=NULL){
+	page = page_free_list;
+	page_free_list = page->pp_link;
+	page->pp_link = NULL;
+	
+	if (alloc_flags & ALLOC_ZERO) {
+		memset(page2kva(page), '\0', PGSIZE);
+	}
+	return page;
+	}
+	return NULL;
+	//return 0;
+	
 }
 
 //
@@ -332,6 +401,12 @@ page_alloc(int alloc_flags)
 void
 page_free(struct PageInfo *pp)
 {
+	if (pp->pp_ref != 0 || pp->pp_link != NULL) 
+        {
+          panic("page_free: not an allocated page\n");
+        }
+        pp->pp_link = page_free_list;
+	page_free_list = pp;
 	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
 	// pp->pp_link is not NULL.
@@ -373,8 +448,39 @@ page_decref(struct PageInfo* pp)
 pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
+
 	// Fill this function in
-	return NULL;
+	pde_t *pde;                                                      // page directory entry virtual
+    	pte_t *pt;                                                       // page table address virtual
+
+    	pde= pgdir + PDX(va);                                      // finding the address of the directory entry by adding directory bits to page directory root pointer
+    
+	if ((*pde) & PTE_P)                                              // checking if page directry entry is present and finding the virtual address of pde
+		pt = KADDR(PTE_ADDR(*pde));		                 //the address stored in pgdir is physical address but we need is virtual address
+         
+   	else
+	{
+          if (create) 
+	  { 				                                 // if page table does not exist, create and insert to page directory
+            	struct PageInfo *pp = page_alloc(ALLOC_ZERO);
+            		
+		if (pp == NULL) 
+		   return NULL;
+            			
+		pt = page2kva(pp); 		                        // pt equals the new page table physical address
+            						                // PTEs inside pt are not initialized yet
+            	pp->pp_ref++;
+            	*pde = PADDR(pt) | PTE_P | PTE_W | PTE_U;
+        	}   
+        	else 
+            	  return NULL;
+    	}
+    
+	return pt + PTX(va);                                              //returns a pointer to the page table entry (PTE) for linear address va
+			                                                  //calculates the page table index        
+
+	// Fill this function in
+	//return NULL;
 }
 
 //
@@ -391,6 +497,12 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
+	size_t i;                                                             //initialize the variable i with type size_t
+        for (i = 0; i < size; i+= PGSIZE) {                                   //size is the multiple of PGSIZE
+	pte_t *pte = pgdir_walk(pgdir, (const void *) (va + i), 1); //finding the page table entry through page walk function; (va +i) - to make va as page alligned
+	*pte = PTE_ADDR(pa + i) | perm | PTE_P;               /*inserts the physical address of the page table entry with permission flags to the page table;(pa + i)  
+                                                                                  - pa as page alligned, with permission bits*/
+	}
 	// Fill this function in
 }
 
@@ -422,8 +534,21 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
-	// Fill this function in
+	pte_t *pte = pgdir_walk(pgdir, va, 1);    //requirement 2 - page is allocated and inserted into pgdir
+
+        if (!pte & PTE_P) {                       //page table couldn't be allocated
+             return -E_NO_MEM;                        
+        }
+        pp->pp_ref++;                             //requirement 3 - page insertion succeed
+
+        if (*pte & PTE_P) {                       //requirement 1 - page is already mapped to va
+             page_remove(pgdir, va);
+        }
+
+       *pte = page2pa(pp) | perm | PTE_P;         
+        //pgdir[PDX(va)] |= perm;
 	return 0;
+	
 }
 
 //
@@ -440,8 +565,17 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
-	// Fill this function in
-	return NULL;
+	pte_t *pte = pgdir_walk(pgdir, va, 0);             //page is not created
+
+        if (!pte) {                                        //page is not mapped to va
+              return NULL;
+        }
+        if (pte_store != 0) {                              
+             *pte_store = pte;                             //address of pte of the page is stored
+        }
+	return pa2page(PTE_ADDR(*pte)); //page mapped at virtual address va is returned
+	//return NULL;
+	
 }
 
 //
@@ -462,6 +596,17 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 void
 page_remove(pde_t *pgdir, void *va)
 {
+	pte_t *pte;
+	struct PageInfo *pp = page_lookup(pgdir, va, &pte);
+	if (!pp) {       			            //page doesnt exist
+	   return;   		                            // do nothing
+	}
+	else
+	{
+	   page_decref(pp);  	                            //decrement reference count and free page table if ref count==0
+	   tlb_invalidate(pgdir, va);                       //invalidate TLB if entry removed from page table
+	   *pte = 0; 		                            // making PTE corresponding to that va as zero
+	} 
 	// Fill this function in
 }
 
@@ -509,7 +654,16 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// Hint: The staff solution uses boot_map_region.
 	//
 	// Your code here:
-	panic("mmio_map_region not implemented");
+	
+	size = ROUNDUP(size, PGSIZE);
+	if (base + size > MMIOLIM) {
+		panic("mmio_map_region failed: overflow");
+	}
+	// note that `base` is already PGSIZE aligned
+	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
+	base += size;
+	return (void *) (base - size);
+	//panic("mmio_map_region not implemented");
 }
 
 static uintptr_t user_mem_check_addr;
@@ -536,8 +690,27 @@ int
 user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 {
 	// LAB 3: Your code here.
+		uintptr_t start = (uintptr_t )ROUNDDOWN ((uint32_t)va, PGSIZE);
+        uintptr_t end = (uintptr_t) va + len;
+
+        for (start; start<end; start+=PGSIZE)
+        {
+         pde_t *pte = pgdir_walk(env->env_pgdir, (void *)start, 0);
+         if (!pte || start>=ULIM || ((uint32_t)*pte & perm) != perm)
+         {
 
+         if (start == (uintptr_t) ROUNDDOWN ((uint32_t)va, PGSIZE))
+         user_mem_check_addr = (uintptr_t) va;
+         else
+         user_mem_check_addr = (uintptr_t) start;
+
+         return -E_FAULT; 
+
+        }
+
+}
 	return 0;
+	
 }
 
 //
diff --git a/kern/sched.c b/kern/sched.c
index f595bb1..ef432fa 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -29,6 +29,21 @@ sched_yield(void)
 	// below to halt the cpu.
 
 	// LAB 4: Your code here.
+	int i, envid;
+	int curenv_id = curenv ? ENVX(curenv->env_id) : 0;
+	
+	
+	for (i = 0; i < NENV; i++) {
+		envid = ENVX(curenv_id + i);
+		if (envs[envid].env_status == ENV_RUNNABLE) {
+			env_run(&envs[envid]);
+		}
+	}
+	
+	if (curenv && curenv->env_status == ENV_RUNNING) {
+		env_run(curenv);
+	}
+	
 
 	// sched_halt never returns
 	sched_halt();
@@ -75,7 +90,7 @@ sched_halt(void)
 		"pushl $0\n"
 		"pushl $0\n"
 		// Uncomment the following line after completing exercise 13
-		//"sti\n"
+		"sti\n"
 		"1:\n"
 		"hlt\n"
 		"jmp 1b\n"
diff --git a/kern/syscall.c b/kern/syscall.c
index 5291c6a..e048ed8 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -20,9 +20,9 @@ sys_cputs(const char *s, size_t len)
 {
 	// Check that the user has permission to read memory [s, s+len).
 	// Destroy the environment if not.
-
+	user_mem_assert(curenv, (void *)s, len, PTE_U);
 	// LAB 3: Your code here.
-
+	
 	// Print the string supplied by the user.
 	cprintf("%.*s", len, s);
 }
@@ -77,6 +77,7 @@ sys_yield(void)
 static envid_t
 sys_exofork(void)
 {
+		
 	// Create the new environment with env_alloc(), from kern/env.c.
 	// It should be left as env_alloc created it, except that
 	// status is set to ENV_NOT_RUNNABLE, and the register set is copied
@@ -84,7 +85,18 @@ sys_exofork(void)
 	// will appear to return 0.
 
 	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+	struct Env *env;
+    int result = env_alloc(&env, curenv->env_id);
+    if (result < 0) {
+        return -E_NO_FREE_ENV;
+    }
+
+    env->env_status = ENV_NOT_RUNNABLE;
+    env->env_tf = curenv->env_tf;
+    env->env_tf.tf_regs.reg_eax = 0;
+
+    return env->env_id;
+	//panic("sys_exofork not implemented");
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -97,6 +109,7 @@ sys_exofork(void)
 static int
 sys_env_set_status(envid_t envid, int status)
 {
+	
 	// Hint: Use the 'envid2env' function from kern/env.c to translate an
 	// envid to a struct Env.
 	// You should set envid2env's third argument to 1, which will
@@ -104,7 +117,19 @@ sys_env_set_status(envid_t envid, int status)
 	// envid's status.
 
 	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
+	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) {
+        return -E_INVAL;
+    }
+//If checkperm is set, the specified environment must be either the
+// current environment or an immediate child of the current environment.
+    struct Env *env;
+    if (envid2env(envid, &env, 1)!=0) {
+        return -E_BAD_ENV;
+    }
+    env->env_status = status;
+
+    return 0;
+	//panic("sys_env_set_status not implemented");
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -118,8 +143,17 @@ sys_env_set_status(envid_t envid, int status)
 static int
 sys_env_set_pgfault_upcall(envid_t envid, void *func)
 {
+	struct Env *env;
+	if (envid2env(envid, &env, 1) != 0) {
+		return -E_BAD_ENV;
+	}
+
+	env->env_pgfault_upcall = func; //page fault upcall entry point//
+
+	return 0;
+
 	// LAB 4: Your code here.
-	panic("sys_env_set_pgfault_upcall not implemented");
+	//panic("sys_env_set_pgfault_upcall not implemented");
 }
 
 // Allocate a page of memory and map it at 'va' with permission
@@ -147,9 +181,38 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 	//   parameters for correctness.
 	//   If page_insert() fails, remember to free the page you
 	//   allocated!
+	struct Env *env;
+    if (envid2env(envid, &env, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+    struct PageInfo *pi = page_alloc(ALLOC_ZERO);
+    if (pi == NULL) {
+        return -E_NO_MEM;
+    }
+    pi->pp_ref++;
+    //page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)-> physical page pp to virtual address va
+    if (page_insert(env->env_pgdir, pi, va, perm) != 0) {
+        page_free(pi);
+        return -E_NO_MEM;
+    }
+    if ((uint32_t)va >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(va, PGSIZE) != va) {
+        return -E_INVAL;
+    }
 
+    if (!((perm & PTE_U) && (perm & PTE_P)) || (perm & (~PTE_SYSCALL))) {
+        return -E_INVAL;
+    }
+
+    
+
+    
+    return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+	//panic("sys_page_alloc not implemented");
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -178,9 +241,55 @@ sys_page_map(envid_t srcenvid, void *srcva,
 	//   parameters for correctness.
 	//   Use the third argument to page_lookup() to
 	//   check the current permissions on the page.
+	struct Env *srcenv;
+    if (envid2env(srcenvid, &srcenv, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+
+    struct Env *dstenv;
+    if (envid2env(dstenvid, &dstenv, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+
+    if ((uint32_t)srcva >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(srcva, PGSIZE) != srcva) {
+        return -E_INVAL;
+    }
+
+    if ((uint32_t)dstva >= UTOP) {
+        return -E_INVAL;
+    }
 
+    if (ROUNDUP(dstva, PGSIZE) != dstva) {
+        return -E_INVAL;
+    }
+
+    if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) || (perm & (~PTE_SYSCALL))) {
+        return -E_INVAL;
+    }
+
+    pte_t *srcpte;
+    //Return the page mapped at virtual address 'va'.
+    //page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+    struct PageInfo *srcpi = page_lookup(srcenv->env_pgdir, srcva, &srcpte);
+    if (srcpi == NULL) {
+        return -E_INVAL;
+    }
+
+    if (((*srcpte) & PTE_W) == 0 && ((perm & PTE_W) == PTE_W)) {
+        return -E_INVAL;
+    }
+
+    int result = page_insert(dstenv->env_pgdir, srcpi, dstva, perm);
+    if (result != 0) {
+        return result;
+    }
+	return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+	//panic("sys_page_map not implemented");
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -194,9 +303,26 @@ static int
 sys_page_unmap(envid_t envid, void *va)
 {
 	// Hint: This function is a wrapper around page_remove().
+	struct Env *env;
+    if (envid2env(envid, &env, 1) != 0) {
+        return -E_BAD_ENV;
+    }
 
+    if ((uint32_t)va >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(va, PGSIZE) != va) {
+        return -E_INVAL;
+    }
+   //Unmaps the physical page at virtual address 'va'.
+   //page_remove(pde_t *pgdir, void *va)
+    page_remove(env->env_pgdir, va);
+    
+
+    return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+	//panic("sys_page_unmap not implemented");
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -241,7 +367,71 @@ static int
 sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_try_send not implemented");
+		/*struct Env *e;
+    if (envid2env(envid, &e, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+    if (!e->env_ipc_recving)
+        return -E_IPC_NOT_RECV;
+        
+    if (((uint32_t)srcva < UTOP))
+    {
+
+      if ((uint32_t)srcva != ROUNDDOWN(srcva, PGSIZE))  
+      return -E_INVAL;
+      
+       if (((perm & (PTE_P | PTE_U)) != ((PTE_P | PTE_U)) || (perm & ~(PTE_SYSCALL))))
+        return -E_INVAL; */
+
+	//panic("sys_ipc_try_send not implemented");
+	
+	struct Env *e;
+        struct PageInfo *pp;
+        pte_t *pte;
+
+        if (envid2env(envid, &e, 0))
+        return -E_BAD_ENV;
+
+        if (!e->env_ipc_recving)
+        return -E_IPC_NOT_RECV;
+
+      if (((uint32_t)srcva < UTOP))
+      {
+
+        if ((uint32_t)srcva % PGSIZE != 0)
+        return -E_INVAL;
+
+        if (((perm & (PTE_P | PTE_U)) != ((PTE_P | PTE_U)) || (perm & ~(PTE_SYSCALL))))
+        return -E_INVAL;
+
+        if (!(pp = page_lookup(curenv->env_pgdir, srcva, &pte)))
+        return -E_INVAL;
+
+        if ((perm & PTE_W) && !(*pte & PTE_W))
+        return -E_INVAL;
+
+        if ((uint32_t)e->env_ipc_dstva < UTOP)
+        {
+
+        if (page_insert(e->env_pgdir, pp, e->env_ipc_dstva, perm))
+        return -E_NO_MEM;
+        e->env_ipc_perm = perm;
+        }
+
+     }
+
+     e->env_ipc_recving = 0;
+     e->env_ipc_from = curenv->env_id;
+     e->env_ipc_value = value;
+     e->env_status = ENV_RUNNABLE;
+
+     e->env_tf.tf_regs.reg_eax = 0;
+
+     return 0;
+	
+	
+	
+	
 }
 
 // Block until a value is ready.  Record that you want to receive
@@ -258,9 +448,19 @@ sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 static int
 sys_ipc_recv(void *dstva)
 {
+	
+	if ((uint32_t)dstva < UTOP && (uint32_t)dstva % PGSIZE != 0)
+       return -E_INVAL;
+       curenv->env_ipc_recving = 1;
+       curenv->env_ipc_dstva = dstva;
+       curenv->env_status = ENV_NOT_RUNNABLE;
+
+       sched_yield();
+
+       return 0; 
 	// LAB 4: Your code here.
-	panic("sys_ipc_recv not implemented");
-	return 0;
+	//panic("sys_ipc_recv not implemented");
+	
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
@@ -270,12 +470,45 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 	// Call the function corresponding to the 'syscallno' parameter.
 	// Return any appropriate return value.
 	// LAB 3: Your code here.
+switch (syscallno)
+ 	{
+ 	   case SYS_cputs:
+      	     sys_cputs((char *) a1, (size_t) a2);
+             return 0;
+ 	   case SYS_cgetc:
+	     return sys_cgetc(); 
+	   case SYS_getenvid: 
+	     return sys_getenvid(); 
+	   case SYS_env_destroy: 
+	     return sys_env_destroy((envid_t) a1); 
+	     case SYS_yield:
+	     sys_yield();
+	      return 0;
+	      case SYS_exofork:
+         return sys_exofork();
+        case SYS_env_set_status:
+         return sys_env_set_status(a1, (int)a2);
+        case SYS_page_alloc:
+         return sys_page_alloc(a1, (void*)a2, (int) a3);
+          case SYS_page_map:
+          return sys_page_map(a1, (void*)a2,(envid_t)a3, (void*)a4, (int)a5);
+         case SYS_page_unmap:
+       return sys_page_unmap(a1, (void*)a2);
+       case SYS_env_set_pgfault_upcall:
+         return sys_env_set_pgfault_upcall(a1,(void *)a2);
+         case SYS_ipc_try_send:
+         return sys_ipc_try_send(a1, a2, (void *) a3, a4);
 
-	panic("syscall not implemented");
+         case SYS_ipc_recv:
+         return sys_ipc_recv((void *) a1);
+ 	   default:
+             return -E_INVAL;     
+	} 
+	/*panic("syscall not implemented");
 
 	switch (syscallno) {
 	default:
 		return -E_INVAL;
-	}
+	}*/
 }
 
diff --git a/kern/trap.c b/kern/trap.c
index 1ca8182..98b1e23 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -70,6 +70,85 @@ void
 trap_init(void)
 {
 	extern struct Segdesc gdt[];
+	void trap_divide();
+	void trap_debug();
+	void trap_nmi();
+	void trap_brkpt();
+	void trap_oflow();
+	void trap_bound();
+	void trap_illop();
+	void trap_device();
+	void trap_dblflt();
+	void trap_tss();
+	void trap_segnp();
+	void trap_stack();
+	void trap_gpflt();
+	void trap_pgflt();
+	void trap_fperr();
+	void trap_align();
+	void trap_mchk();
+	void trap_simderr();
+	void trap_syscall();
+	
+	
+	
+	void irq0();
+	void irq1();
+	void irq2();
+	void irq3();
+	void irq4();
+	void irq5();
+	void irq6();
+	void irq7();
+	void irq8();
+	void irq9();
+	void irq10();
+	void irq11();
+	void irq12();
+	void irq13();
+	void irq14();
+	void irq15();
+		
+	
+	// SETGATE(gate, istrap, sel, off, dpl)
+	SETGATE(idt[T_DIVIDE], 0, GD_KT, trap_divide, 0);
+	SETGATE(idt[T_DEBUG] , 0, GD_KT, trap_debug , 0);
+	SETGATE(idt[T_NMI],    0, GD_KT, trap_nmi, 0);
+	SETGATE(idt[T_BRKPT],  0, GD_KT, trap_brkpt, 3);
+	SETGATE(idt[T_OFLOW] , 0, GD_KT, trap_oflow , 0);
+	SETGATE(idt[T_BOUND] , 0, GD_KT, trap_bound , 0);
+	SETGATE(idt[T_ILLOP] , 0, GD_KT, trap_illop , 0);
+	SETGATE(idt[T_DEVICE], 0, GD_KT, trap_device, 0);
+	SETGATE(idt[T_DBLFLT], 0, GD_KT, trap_dblflt, 0);
+	SETGATE(idt[T_TSS]   , 0, GD_KT, trap_tss,    0);
+	SETGATE(idt[T_SEGNP] , 0, GD_KT, trap_segnp,  0);
+	SETGATE(idt[T_STACK] , 0, GD_KT, trap_stack,  0);
+	SETGATE(idt[T_GPFLT] , 0, GD_KT, trap_gpflt,  0);
+	SETGATE(idt[T_PGFLT] , 0, GD_KT, trap_pgflt,  0);
+	SETGATE(idt[T_FPERR] , 0, GD_KT, trap_fperr,  0);
+	SETGATE(idt[T_ALIGN] , 0, GD_KT, trap_align,  0);
+	SETGATE(idt[T_MCHK]  , 0, GD_KT, trap_mchk ,  0);
+	SETGATE(idt[T_SIMDERR],0, GD_KT, trap_simderr, 0);
+	SETGATE(idt[T_SYSCALL],0, GD_KT, trap_syscall, 3);
+	
+	
+	
+  SETGATE(idt[IRQ_OFFSET+0], 0, GD_KT, irq0, 0); 
+  SETGATE(idt[IRQ_OFFSET+1], 0, GD_KT, irq1, 0); 
+  SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, irq2, 0); 
+  SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, irq3, 0); 
+  SETGATE(idt[IRQ_OFFSET+4], 0, GD_KT, irq4, 0); 
+  SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, irq5, 0); 
+  SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, irq6, 0); 
+  SETGATE(idt[IRQ_OFFSET+7], 0, GD_KT, irq7, 0); 
+  SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, irq8, 0); 
+  SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, irq9, 0); 
+  SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, irq10, 0); 
+  SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, irq11, 0); 
+  SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, irq12, 0); 
+  SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, irq13, 0); 
+  SETGATE(idt[IRQ_OFFSET+14], 0, GD_KT, irq14, 0); 
+  SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, irq15, 0);
 
 	// LAB 3: Your code here.
 
@@ -108,18 +187,19 @@ trap_init_percpu(void)
 
 	// Setup a TSS so that we get the right stack
 	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
+	int i = thiscpu->cpu_id;
+	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP); //percpu_kstacks[thiscpu->cpu_id];
+	thiscpu->cpu_ts.ts_ss0 = GD_KD;
+	 thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);
 
 	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
-					sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
+	gdt[(GD_TSS0 >> 3)+i] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),
+					sizeof(struct Taskstate) - 1, 0); //Available 32-bit TSS
+	gdt[(GD_TSS0 >> 3)+i].sd_s = 0; 
 
 	// Load the TSS selector (like other segment selectors, the
 	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
+	ltr(GD_TSS0+sizeof(struct Segdesc)*i);
 
 	// Load the IDT
 	lidt(&idt_pd);
@@ -176,6 +256,27 @@ trap_dispatch(struct Trapframe *tf)
 {
 	// Handle processor exceptions.
 	// LAB 3: Your code here.
+	if (tf->tf_trapno == T_PGFLT) 
+        {
+	   page_fault_handler(tf);
+	   return;
+	}
+	
+	if(tf->tf_trapno == T_BRKPT)
+        {
+           monitor(tf);
+           return;
+        }
+
+	if (tf->tf_trapno == T_SYSCALL)
+        {
+        if((tf->tf_regs.reg_eax = syscall (tf->tf_regs.reg_eax, tf->tf_regs.reg_edx,
+                          tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx,
+                          tf->tf_regs.reg_edi, tf->tf_regs.reg_esi)) < 0)
+ 
+        panic ("Invalid system call!");
+ 	return;
+}
 
 	// Handle spurious interrupts
 	// The hardware sometimes raises these because of noise on the
@@ -189,7 +290,11 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle clock interrupts. Don't forget to acknowledge the
 	// interrupt using lapic_eoi() before calling the scheduler!
 	// LAB 4: Your code here.
-
+	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
+		lapic_eoi();
+		sched_yield();
+		return;
+	}
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
 	if (tf->tf_cs == GD_KT)
@@ -226,6 +331,7 @@ trap(struct Trapframe *tf)
 		// Acquire the big kernel lock before doing any
 		// serious kernel work.
 		// LAB 4: Your code here.
+			lock_kernel();
 		assert(curenv);
 
 		// Garbage collect if current enviroment is a zombie
@@ -271,7 +377,8 @@ page_fault_handler(struct Trapframe *tf)
 	// Handle kernel-mode page faults.
 
 	// LAB 3: Your code here.
-
+	if ((tf->tf_cs & 3) == 0)
+		panic("page fault in kernel mode.");
 	// We've already handled kernel-mode exceptions, so if we get here,
 	// the page fault happened in user mode.
 
@@ -303,13 +410,77 @@ page_fault_handler(struct Trapframe *tf)
 	//   user_mem_assert() and env_run() are useful here.
 	//   To change what the user environment runs, modify 'curenv->env_tf'
 	//   (the 'tf' variable points at 'curenv->env_tf').
-
-	// LAB 4: Your code here.
-
-	// Destroy the environment that caused the fault.
+	/*if (curenv->env_pgfault_upcall == NULL)
+	{
 	cprintf("[%08x] user fault va %08x ip %08x\n",
 		curenv->env_id, fault_va, tf->tf_eip);
 	print_trapframe(tf);
 	env_destroy(curenv);
 }
 
+// Destroy the environment that caused the fault.
+	else {
+		uintptr_t stacktop;
+		if (tf->tf_esp < UXSTACKTOP)
+			stacktop = tf->tf_esp - sizeof(struct UTrapframe)-4;
+		else
+			stacktop = UXSTACKTOP- sizeof(struct UTrapframe);
+
+		struct UTrapframe *utf = (struct UTrapframe *)stacktop;
+
+		user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
+
+		utf->utf_fault_va = fault_va;
+		utf->utf_err = tf->tf_err;
+		utf->utf_regs = tf->tf_regs;
+		utf->utf_eip = tf->tf_eip;
+		utf->utf_eflags = tf->tf_eflags;
+		utf->utf_esp = tf->tf_esp;
+		curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
+		curenv->env_tf.tf_esp = stacktop;
+
+		env_run(curenv);
+	}
+
+	// LAB 4: Your code here.
+
+	
+	
+}*/
+
+
+
+
+if (curenv->env_pgfault_upcall == NULL || tf->tf_esp > UXSTACKTOP || (tf->tf_esp > USTACKTOP && tf->tf_esp < (UXSTACKTOP - PGSIZE)))
+        {
+         cprintf("[%08x] user fault va %08x ip %08x\n",
+         curenv->env_id, fault_va, tf->tf_eip);
+         print_trapframe(tf);
+         env_destroy(curenv);
+        }
+        uint32_t xstack_top;
+        if (tf->tf_esp < USTACKTOP) 
+        {
+        xstack_top = UXSTACKTOP - sizeof(struct UTrapframe);
+        } 
+        else 
+        {
+        xstack_top = tf->tf_esp - sizeof(struct UTrapframe) - 4;
+        }
+  
+        user_mem_assert(curenv, (void *) xstack_top, 1, PTE_W | PTE_U);
+     
+        struct UTrapframe *u_tf = (struct UTrapframe *) xstack_top;
+        u_tf->utf_fault_va = fault_va;
+        u_tf->utf_err = tf->tf_err;
+        u_tf->utf_regs = tf->tf_regs;
+        u_tf->utf_eip = tf->tf_eip;
+        u_tf->utf_eflags = tf->tf_eflags;
+        u_tf->utf_esp = tf->tf_esp; 
+ 
+        tf->tf_esp = (uintptr_t) xstack_top;
+        tf->tf_eip = (uintptr_t) curenv->env_pgfault_upcall;
+        env_run(curenv);        
+}
+
+
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 2dbeeca..3cc24f4 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -48,9 +48,61 @@
  * Lab 3: Your code here for generating entry points for the different traps.
  */
 
+TRAPHANDLER_NOEC(trap_divide, T_DIVIDE)
+	TRAPHANDLER_NOEC(trap_debug, T_DEBUG)
+	TRAPHANDLER_NOEC(trap_nmi, T_NMI)
+	TRAPHANDLER_NOEC(trap_brkpt, T_BRKPT)
+	TRAPHANDLER_NOEC(trap_oflow, T_OFLOW)
+	TRAPHANDLER_NOEC(trap_bound, T_BOUND)
+	TRAPHANDLER_NOEC(trap_illop, T_ILLOP)
+	TRAPHANDLER_NOEC(trap_device, T_DEVICE)
+	TRAPHANDLER(trap_dblflt, T_DBLFLT)
+	TRAPHANDLER(trap_tss, T_TSS)
+	TRAPHANDLER(trap_segnp, T_SEGNP)
+	TRAPHANDLER(trap_stack, T_STACK)
+	TRAPHANDLER(trap_gpflt, T_GPFLT)
+	TRAPHANDLER(trap_pgflt, T_PGFLT)
+	TRAPHANDLER_NOEC(trap_fperr, T_FPERR)
+	TRAPHANDLER(trap_align, T_ALIGN)
+	TRAPHANDLER_NOEC(trap_mchk, T_MCHK)
+	TRAPHANDLER_NOEC(trap_simderr, T_SIMDERR)
+	TRAPHANDLER_NOEC(trap_syscall, T_SYSCALL)
+
+
+
+  TRAPHANDLER_NOEC(irq0, IRQ_OFFSET+0 ); 
+  TRAPHANDLER_NOEC(irq1, IRQ_OFFSET+1 ); 
+  TRAPHANDLER_NOEC(irq2, IRQ_OFFSET+2 ); 
+  TRAPHANDLER_NOEC(irq3, IRQ_OFFSET+3 ); 
+  TRAPHANDLER_NOEC(irq4, IRQ_OFFSET+4 ); 
+  TRAPHANDLER_NOEC(irq5, IRQ_OFFSET+5 ); 
+  TRAPHANDLER_NOEC(irq6, IRQ_OFFSET+6 ); 
+  TRAPHANDLER_NOEC(irq7, IRQ_OFFSET+7 ); 
+  TRAPHANDLER_NOEC(irq8, IRQ_OFFSET+8 ); 
+  TRAPHANDLER_NOEC(irq9, IRQ_OFFSET+9 ); 
+  TRAPHANDLER_NOEC(irq10, IRQ_OFFSET+10 ); 
+  TRAPHANDLER_NOEC(irq11, IRQ_OFFSET+11 ); 
+  TRAPHANDLER_NOEC(irq12, IRQ_OFFSET+12 ); 
+  TRAPHANDLER_NOEC(irq13, IRQ_OFFSET+13 ); 
+  TRAPHANDLER_NOEC(irq14, IRQ_OFFSET+14 ); 
+  TRAPHANDLER_NOEC(irq15, IRQ_OFFSET+15 ); 
 
 
 /*
  * Lab 3: Your code here for _alltraps
  */
 
+_alltraps:
+	pushl %ds
+	pushl %es
+	pushal
+	pushl $GD_KD
+	popl %ds
+	pushl $GD_KD
+	popl %es
+	pushl %esp
+	call trap
+
+
+
+
diff --git a/lib/fork.c b/lib/fork.c
index 61264da..6016713 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -7,6 +7,8 @@
 // It is one of the bits explicitly allocated to user processes (PTE_AVAIL).
 #define PTE_COW		0x800
 
+extern void _pgfault_upcall(void);
+
 //
 // Custom page fault handler - if faulting page is copy-on-write,
 // map in our own private writable copy.
@@ -24,7 +26,15 @@ pgfault(struct UTrapframe *utf)
 	//   Use the read-only page table mappings at uvpt
 	//   (see <inc/memlayout.h>).
 
-	// LAB 4: Your code here.
+	// LAB 4: Your code here
+        //check if the page fault is a write.
+        if ((err & FEC_WR) == 0)
+        panic("pgfault: faulting address [%08x] is not a write\n", addr);
+
+        void *page_aligned_addr = (void *) ROUNDDOWN(addr, PGSIZE);
+        uint32_t pgno = (uint32_t) page_aligned_addr / PGSIZE;
+        if (!(uvpt[pgno] & PTE_COW))
+        panic("pgfault: fault was not on a copy-on-write page\n");
 
 	// Allocate a new page, map it at a temporary location (PFTEMP),
 	// copy the data from the old page to the new page, then move the new
@@ -32,9 +42,20 @@ pgfault(struct UTrapframe *utf)
 	// Hint:
 	//   You should make three system calls.
 
-	// LAB 4: Your code here.
+	// LAB 4: Your code here.i
+        if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
+        panic("pgfault: sys_page_alloc: %e\n", r);
+       
+        void *src_addr = (void *) ROUNDDOWN(addr, PGSIZE);
+        memmove(PFTEMP, src_addr, PGSIZE);
 
-	panic("pgfault not implemented");
+       if ((r = sys_page_map(0, PFTEMP, 0, src_addr, PTE_P | PTE_U | PTE_W)) < 0)
+       panic("pgfault: sys_page_map: %e\n", r);
+      
+       if((sys_page_unmap(0, PFTEMP))<0)
+       panic("pgfault/fork: couldn't unmap the page at PFTEMP");
+ 
+	//panic("pgfault not implemented");
 }
 
 //
@@ -48,14 +69,32 @@ pgfault(struct UTrapframe *utf)
 // Returns: 0 on success, < 0 on error.
 // It is also OK to panic on error.
 //
+/*For each writable or copy-on-write page in its address space below UTOP, the parent calls duppage, which should map the page copy-on-write into the address space of the child and then remap the page copy-on-write in its own address space. duppage sets both PTEs so that the page is not writeable, and to contain PTE_COW in the "avail" field to distinguish copy-on-write pages from genuine read-only pages.*/
 static int
 duppage(envid_t envid, unsigned pn)
 {
-	int r;
+     int r;
+     uint32_t perm = PTE_P | PTE_COW | PTE_U;
+     void * addr = (void *)(pn*PGSIZE);
 
-	// LAB 4: Your code here.
-	panic("duppage not implemented");
-	return 0;
+     // LAB 4: Your code here.
+    //If the page passed is marked copy-on-write or writable 
+    if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W) 
+     {
+     //then map the page at addr in parent to child at addr in its address space with perm COW
+     if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, perm)) < 0)
+     panic("duppage: sys_page_map: %e\n", r);
+
+     // remap the page at addr in parent with perm that contains COW
+     if ((r = sys_page_map(thisenv->env_id, addr, thisenv->env_id, addr, perm)) < 0)
+     panic("duppage: sys_page_map: %e\n", r);
+
+    } 
+   else // if the page is read-only , map this addr of the page too in the child 
+   if((r = sys_page_map(thisenv->env_id, addr, envid, addr,PTE_P | PTE_U )) < 0)
+   panic("duppage: sys_page_map: %e\n", r);
+
+return 0;
 }
 
 //
@@ -78,7 +117,58 @@ envid_t
 fork(void)
 {
 	// LAB 4: Your code here.
-	panic("fork not implemented");
+	//panic("fork not implemented");
+        envid_t child_envid;
+        int r;
+        set_pgfault_handler(pgfault); // set the pagefault handler to pgfault which is defined above  
+
+        // Allocate a new child environment.
+        // The kernel will initialize it with a copy of our register state,
+        // so that the child will appear to have called sys_exofork() too -
+        // except that in the child, this "fake" call to sys_exofork()
+        // will return 0 instead of the envid of the child.
+        child_envid = sys_exofork();
+        if (child_envid < 0)
+                panic("fork: sys_exofork: %e", child_envid);
+        if (child_envid == 0) {
+                // We're the child.
+                // The copied value of the global variable 'thisenv'
+                // is no longer valid (it refers to the parent!).
+                // Fix it and return 0.
+                thisenv = &envs[ENVX(sys_getenvid())];
+                return 0;
+        }
+
+        // We're the parent.
+        // Eagerly copy our mappings into the child.
+       uint32_t pgno=0;
+       pte_t *pte;
+       for (; pgno < PGNUM(UTOP - PGSIZE); pgno++) 
+       {  //rounddown to the nearest multiple of NPDENTRIES
+       uint32_t pdx = ROUNDDOWN(pgno, NPDENTRIES) / NPDENTRIES; // or use PDX macro with substitution of page numbers
+       if ((uvpd[pdx] & PTE_P) == PTE_P && ((uvpt[pgno] & PTE_P) == PTE_P))  
+// traverse through the uvpt array of the parents environment to find *pte and make sure there is mapping to every page
+       {
+       duppage(child_envid, pgno);
+       }
+      } 
+ 
+        //allocate user exception stack for child
+        if(sys_page_alloc(child_envid,(void *) (UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P)<0)    
+        panic("fork: unable to allocate user exeception stack for the child"); 
+  
+        //copy the parent page fault handler entrypoint to child's environment, in this case _pgfault_upcall in lib/pfentry.S
+ 
+       if ((r = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall)) < 0)
+       panic("fork: sys_env_set_pgfault_upcall", r);
+ 
+    
+        // Now the child is ready to start running
+        if ((r = sys_env_set_status(child_envid, ENV_RUNNABLE)) < 0)
+                panic("sys_env_set_status: %e", r);
+
+        return child_envid;
+        
 }
 
 // Challenge!
diff --git a/lib/ipc.c b/lib/ipc.c
index 2e222b9..9556652 100644
--- a/lib/ipc.c
+++ b/lib/ipc.c
@@ -22,9 +22,26 @@
 int32_t
 ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 {
+	if (!pg) 
+        pg = (void*) -1;
+
+        if (sys_ipc_recv(pg))
+        {
+          *from_env_store = 0;
+          *perm_store = 0;
+           return -E_INVAL;
+        }
+
+        if (from_env_store)
+        *from_env_store = thisenv->env_ipc_from;
+    
+        if (perm_store)
+        *perm_store = thisenv->env_ipc_perm;
+
+        return thisenv->env_ipc_value;
 	// LAB 4: Your code here.
-	panic("ipc_recv not implemented");
-	return 0;
+	//panic("ipc_recv not implemented");
+	//return 0;
 }
 
 // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
@@ -38,8 +55,18 @@ ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 void
 ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
 {
+	int result;
+        if (!pg)
+        pg = (void *)-1;
+        while((result = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) 
+        {
+        sys_yield();
+        }
+
+        if (result)
+        panic ("E_IPC_NOT_RECV %e", result);
 	// LAB 4: Your code here.
-	panic("ipc_send not implemented");
+	//panic("ipc_send not implemented");
 }
 
 // Find the first environment of the given type.  We'll use this to
diff --git a/lib/libmain.c b/lib/libmain.c
index 8a14b29..9829054 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -13,7 +13,8 @@ libmain(int argc, char **argv)
 {
 	// set thisenv to point at our Env structure in envs[].
 	// LAB 3: Your code here.
-	thisenv = 0;
+	//thisenv = 0;
+	thisenv = (struct Env *)envs + ENVX(sys_getenvid());
 
 	// save the name of the program so that panic() can use it
 	if (argc > 0)
diff --git a/lib/pfentry.S b/lib/pfentry.S
index f40aeeb..c303d5d 100644
--- a/lib/pfentry.S
+++ b/lib/pfentry.S
@@ -65,18 +65,24 @@ _pgfault_upcall:
 	// ways as registers become unavailable as scratch space.
 	//
 	// LAB 4: Your code here.
-
+	movl 0x28(%esp), %edx 
+	subl $0x4, 0x30(%esp) 
+	movl 0x30(%esp), %eax 
+	movl %edx, (%eax)
+	addl $0x8, %esp
 	// Restore the trap-time registers.  After you do this, you
 	// can no longer modify any general-purpose registers.
 	// LAB 4: Your code here.
-
+	popal
 	// Restore eflags from the stack.  After you do this, you can
 	// no longer use arithmetic operations or anything else that
 	// modifies eflags.
 	// LAB 4: Your code here.
-
+	addl $0x4, %esp 
+	popfl
 	// Switch back to the adjusted trap-time stack.
 	// LAB 4: Your code here.
-
+	popl %esp
 	// Return to re-execute the instruction that faulted.
 	// LAB 4: Your code here.
+	ret
diff --git a/lib/pgfault.c b/lib/pgfault.c
index a975518..e273c83 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -29,9 +29,14 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 	if (_pgfault_handler == 0) {
 		// First time through!
 		// LAB 4: Your code here.
-		panic("set_pgfault_handler not implemented");
+		//panic("set_pgfault_handler not implemented");
+	   if (sys_page_alloc(thisenv->env_id, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) < 0) 
+			panic("set_pgfault_handler:sys_page_alloc failed");;
 	}
-
 	// Save handler pointer for assembly to call.
 	_pgfault_handler = handler;
+	if (sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall) < 0)
+		panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed");
+	
+	
 }
diff --git a/user/dumbfork.c b/user/dumbfork.c
index e5e433c..8c3466f 100644
--- a/user/dumbfork.c
+++ b/user/dumbfork.c
@@ -16,7 +16,7 @@ umain(int argc, char **argv)
 	who = dumbfork();
 
 	// print a message and yield to the other a few times
-	for (i = 0; i < (who ? 10 : 20); i++) {
+	for (i = 0; i < (who ? 30 : 20); i++) {
 		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
 		sys_yield();
 	}
diff --git a/user/faultallocbad.c b/user/faultallocbad.c
index 2c0898a..19ad2f1 100644
--- a/user/faultallocbad.c
+++ b/user/faultallocbad.c
@@ -2,7 +2,8 @@
 // doesn't work because we sys_cputs instead of cprintf (exercise: why?)
 
 #include <inc/lib.h>
-
+//const char *hello = "hello, world\n";
+//const char *DEADBEEF = "hello, world\n";
 void
 handler(struct UTrapframe *utf)
 {
@@ -20,5 +21,20 @@ void
 umain(int argc, char **argv)
 {
 	set_pgfault_handler(handler);
+	
 	sys_cputs((char*)0xDEADBEEF, 4);
+	
+	//sys_cputs((char*)0xeebfe000, 1024);//failure:ustacktop//
+	//sys_cputs((char*)0xeebfefff, 1024);//failure:emptymemory:user exception stack+1//
+	//sys_cputs((char*)0xeebff000, 1024);//no failure: user exception stack//
+	//sys_cputs((char*)0xef400000, 1024);//no failure: uvpt//
+	//sys_cputs((char*)0xef7fffff, 1024);//no failure: ulim-1//
+	//sys_cputs((char*)0xef800000, 1024);//failure: ulim//	
+
+/****************no failure when the address range is between uxstacktop and ulim**************/
+
+
+	//sys_cputs("0xDEADBEEF\n", 1024);
+	//sys_cputs(DEADBEEF, 1024);
+	//sys_cputs(hello, 1024);
 }
diff --git a/user/faultdie.c b/user/faultdie.c
index 4959d11..76e1d65 100644
--- a/user/faultdie.c
+++ b/user/faultdie.c
@@ -7,6 +7,7 @@ handler(struct UTrapframe *utf)
 {
 	void *addr = (void*)utf->utf_fault_va;
 	uint32_t err = utf->utf_err;
+        cprintf("error= %x\n",err);
 	cprintf("i faulted at va %x, err %x\n", addr, err & 7);
 	sys_env_destroy(sys_getenvid());
 }
