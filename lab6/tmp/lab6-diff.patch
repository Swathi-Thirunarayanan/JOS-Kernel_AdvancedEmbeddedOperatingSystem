diff --git a/.dir-locals.el b/.dir-locals.el
old mode 100644
new mode 100755
diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
old mode 100644
new mode 100755
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/conf/env.mk b/conf/env.mk
index a603f9e..bd94f15 100644
--- a/conf/env.mk
+++ b/conf/env.mk
@@ -17,4 +17,4 @@ V = @
 # If the makefile cannot find your QEMU binary, uncomment the
 # following line and set it to the full path to QEMU.
 #
-# QEMU=
+QEMU=/home/swathi/qemu/x86_64-softmmu/qemu-system-x86_64
diff --git a/conf/lab.mk b/conf/lab.mk
index 36d5b37..08f238e 100644
--- a/conf/lab.mk
+++ b/conf/lab.mk
@@ -1,2 +1,4 @@
+
 LAB=6
 PACKAGEDATE=Mon Nov 6 10:50:45 EST 2017
+
diff --git a/fs/bc.c b/fs/bc.c
index e3922c4..6b64864 100644
--- a/fs/bc.c
+++ b/fs/bc.c
@@ -14,7 +14,7 @@ diskaddr(uint32_t blockno)
 bool
 va_is_mapped(void *va)
 {
-	return (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P);
+	return (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P);//uvpt-read only virtual page table
 }
 
 // Is this virtual address dirty?
@@ -48,7 +48,19 @@ bc_pgfault(struct UTrapframe *utf)
 	// the disk.
 	//
 	// LAB 5: you code here:
-
+	 addr = ROUNDDOWN(addr, PGSIZE);
+        if ((r = sys_page_alloc(sys_getenvid(), addr, PTE_W|PTE_U|PTE_P)) < 0)
+        panic("sys_page_alloc in bc_pgfault");
+        // uint32_t secno = blockno * BLKSECTS;
+
+        if ((r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) < 0) 
+		panic("ide_read: %e", r);
+		/*ide_read reads the contents of the disk to the page, 
+		 * read the disk sector as a unit, according to The distance from addr
+		 *  to the DISKMAP address. The read contents are blockno*BLKSECTS 
+		 * (a BLOCK) starting from blockno*BLKSECT*/
+        
+        
 	// Clear the dirty bit for the disk block page since we just read the
 	// block from disk
 	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
@@ -77,6 +89,19 @@ flush_block(void *addr)
 		panic("flush_block of bad va %08x", addr);
 
 	// LAB 5: Your code here.
+	int r;
+	 envid_t envid = thisenv->env_id;
+if (va_is_mapped(addr) && va_is_dirty(addr))
+ {
+  addr = ROUNDDOWN(addr, PGSIZE);
+  //ide_write(uint32_t secno, const void *src, size_t nsecs)
+  if ((r = ide_write(blockno * 8, addr, 8)))//8=BLKSECTS
+    panic("in flush_block, ide_write: %e", r);
+   if ((r = sys_page_map(envid, addr, envid, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
+   //After writing the block to disk, flush_block should clear the PTE_D bit using sys_page_map
+     panic("in flush_block, sys_page_map: %e", r);
+ }
+  return;
 	panic("flush_block not implemented");
 }
 
diff --git a/fs/fs.c b/fs/fs.c
index 45ecaf8..74d3386 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -31,6 +31,7 @@ block_is_free(uint32_t blockno)
 {
 	if (super == 0 || blockno >= super->s_nblocks)
 		return 0;
+		//panic("%x", blockno);
 	if (bitmap[blockno / 32] & (1 << (blockno % 32)))
 		return 1;
 	return 0;
@@ -62,9 +63,57 @@ alloc_block(void)
 	// super->s_nblocks blocks in the disk altogether.
 
 	// LAB 5: Your code here.
-	panic("alloc_block not implemented");
+
+       
+       int result;
+	for(uint32_t block=2; block < (super->s_nblocks); block++)
+	{
+		if(block_is_free(block))
+		{
+			bitmap[block / 32] &= ~(1 << (block % 32));
+			flush_block(diskaddr(block));
+			return block;
+		}
+	}
 	return -E_NO_DISK;
 }
+       
+   
+   
+   
+      	 /* uint32_t i, j;
+     // There are super->s_nblocks blocks in the disk altogether.
+     for(i = 0; i < super->s_nblocks; i++){
+         if(block_is_free(i)){
+             // use free_block as an example for manipulating the bitmap
+             bitmap[i/32] &= ~(1<<(i%32));
+             // immediately flush the changed bitmap block to disk
+             flush_block(diskaddr(i/BLKBITSIZE + 2));
+             // Return block number allocated on success
+             return i;
+         }
+     }
+     // panic("alloc_block not implemented");
+     return -E_NO_DISK;
+     
+     uint32_t i;
+        int blockno;
+        for (i = 0; i < super->s_nblocks/32; ++i)
+        {
+         if (bitmap[i])
+         {
+         uint32_t bit_idx = (__builtin_ffs(bitmap[i]) - 1);
+         * 
+         cprintf("%u: %u\n", bitmap[i], bit_idx);
+         bitmap[i] &= ~(1u << bit_idx);
+         blockno = i*32 + bit_idx;
+         flush_block(diskaddr(blockno));
+         return blockno;
+        }
+       } 
+       return -E_NO_DISK;*/ 
+	
+
 
 // Validate the file system bitmap.
 //
@@ -135,8 +184,39 @@ static int
 file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
 {
        // LAB 5: Your code here.
-       panic("file_block_walk not implemented");
-}
+        uint32_t blkno;
+     // filebno in [0, 9]
+     if(filebno <= 9){   //NDIRECT
+         // Set '*ppdiskbno' to point to one of the f->f_direct[] entries
+         *ppdiskbno = &f->f_direct[filebno];
+         return 0;
+     }
+     // filebno in [10, 1033]
+     else if(filebno <= 1033 && filebno>9){  //NDIRECT + NINDIRECT
+         if (!f->f_indirect){
+             if(!alloc){
+                 return -E_NOT_FOUND;
+             }
+             // When 'alloc' is set, allocate an indirect block if necessary.
+             blkno = alloc_block();
+             // -E_NO_DISK if there's no space on the disk for an indirect block.
+             if (blkno < 0){
+                 return -E_NO_DISK;
+             }
+             f->f_indirect = blkno;
+             memset(diskaddr(blkno), 0, BLKSIZE);
+         }
+         // Set '*ppdiskbno' to point to an entry in the indirect block
+         *ppdiskbno = &((uintptr_t *) diskaddr(f->f_indirect))[filebno];
+     }
+     // filebno in [1034, inf)
+     else{
+         return -E_INVAL;
+     }
+     return 0;
+     //panic("file_block_walk not implemented");
+ }
+       
 
 // Set *blk to the address in memory where the filebno'th
 // block of file 'f' would be mapped.
@@ -150,7 +230,26 @@ int
 file_get_block(struct File *f, uint32_t filebno, char **blk)
 {
        // LAB 5: Your code here.
-       panic("file_get_block not implemented");
+       
+       uint32_t *diskbno = NULL;
+     uint32_t block = file_block_walk(f, filebno, &diskbno, 1);
+
+     if(block < 0)
+         return block;
+
+     if(! *diskbno){
+         *diskbno = alloc_block();
+         // -E_NO_DISK if a block needed to be allocated but the disk is full.
+         if (*diskbno < 0){
+             return -E_NO_DISK;
+         }
+         
+     }
+     // Set *blk to the address in memory where the filebno'th
+     // block of file 'f' would be mapped.
+     *blk = (char *)diskaddr(*diskbno);
+     return 0;
+       //panic("file_get_block not implemented");
 }
 
 // Try to find a file named "name" in dir.  If so, set *file to it.
diff --git a/fs/fsformat.c b/fs/fsformat.c
index 4dab07a..52c3135 100644
--- a/fs/fsformat.c
+++ b/fs/fsformat.c
@@ -111,11 +111,13 @@ opendisk(const char *name)
 	super = alloc(BLKSIZE);
 	super->s_magic = FS_MAGIC;
 	super->s_nblocks = nblocks;
+	//cprintf("%x\n",nblocks);
 	super->s_root.f_type = FTYPE_DIR;
 	strcpy(super->s_root.f_name, "/");
 
 	nbitblocks = (nblocks + BLKBITSIZE - 1) / BLKBITSIZE;
 	bitmap = alloc(nbitblocks * BLKSIZE);
+	//panic("%x %x %x %x",nbitblocks * BLKSIZE, nblocks, nbitblocks, BLKBITSIZE);
 	memset(bitmap, 0xFF, nbitblocks * BLKSIZE);
 }
 
diff --git a/fs/ide.c b/fs/ide.c
index 2d8b4bf..b716f77 100644
--- a/fs/ide.c
+++ b/fs/ide.c
@@ -80,6 +80,7 @@ ide_read(uint32_t secno, void *dst, size_t nsecs)
 		if ((r = ide_wait_ready(1)) < 0)
 			return r;
 		insl(0x1F0, dst, SECTSIZE/4);
+		//Transfer a string from the port address, specified in the DX register, into the ES:destination index register: 
 	}
 
 	return 0;
@@ -105,6 +106,9 @@ ide_write(uint32_t secno, const void *src, size_t nsecs)
 		if ((r = ide_wait_ready(1)) < 0)
 			return r;
 		outsl(0x1F0, src, SECTSIZE/4);
+		//  void outb(unsigned char value, unsigned short int port);
+		//Transfers a byte, word, or long from the memory address pointed to by the content of the AL, AX,
+		// or EAX register to the immediate 8-, 16-, or 32-bit port address.
 	}
 
 	return 0;
diff --git a/fs/serv.c b/fs/serv.c
index 00a35bb..44674bf 100644
--- a/fs/serv.c
+++ b/fs/serv.c
@@ -214,6 +214,27 @@ serve_read(envid_t envid, union Fsipc *ipc)
 		cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// Lab 5: Your code here:
+	int r;
+
+ struct OpenFile * open_file;
+ 
+     // First, use openfile_lookup to find the relevant open file.
+    // On failure, return the error code to the client with ipc_send.
+ if ((r = openfile_lookup(envid, req->req_fileid, &open_file)) < 0)
+   return r;
+// if (open_file->o_fd->fd_offset == open_file->o_file->f_size)
+  // return -E_INVAL;
+   
+   
+    // Second, call the relevant file system function (from fs/fs.c).
+    // On failure, return the error code to the client.
+ if ((r = file_read(open_file->o_file, ret->ret_buf, req->req_n, open_file->o_fd->fd_offset))){
+   if (r > 0)
+   {
+     open_file->o_fd->fd_offset += r;
+   }
+   return r;
+ }
 	return 0;
 }
 
@@ -229,6 +250,17 @@ serve_write(envid_t envid, struct Fsreq_write *req)
 		cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// LAB 5: Your code here.
+	int r;
+ struct OpenFile * open_file;
+ if ((r = openfile_lookup(envid, req->req_fileid, &open_file)) < 0)
+   return r;
+ if ((r = file_write(open_file->o_file, req->req_buf, req->req_n, open_file->o_fd->fd_offset))){
+   if (r > 0)
+   {
+     open_file->o_fd->fd_offset += r;
+   }
+   return r;
+}
 	panic("serve_write not implemented");
 }
 
@@ -341,4 +373,3 @@ umain(int argc, char **argv)
 	fs_init();
 	serve();
 }
-
diff --git a/gradelib.py b/gradelib.py
index 07a7a84..4bb6bed 100644
--- a/gradelib.py
+++ b/gradelib.py
@@ -436,7 +436,7 @@ Failed to shutdown QEMU.  You might need to 'killall qemu' or
     def __monitor_start(self, output):
         if b"\n" in output:
             try:
-                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=30)
+                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=2)
                 raise TerminateTest
             except socket.error:
                 pass
diff --git a/inc/lib.h b/inc/lib.h
index 66740e8..9a82803 100644
--- a/inc/lib.h
+++ b/inc/lib.h
@@ -60,6 +60,9 @@ int	sys_page_unmap(envid_t env, void *pg);
 int	sys_ipc_try_send(envid_t to_env, uint32_t value, void *pg, int perm);
 int	sys_ipc_recv(void *rcv_pg);
 unsigned int sys_time_msec(void);
+//lab6
+int sys_net_tx(void * addr, size_t length);
+int sys_net_recv(void * addr);
 
 // This must be inlined.  Exercise for reader: why?
 static inline envid_t __attribute__((always_inline))
diff --git a/inc/syscall.h b/inc/syscall.h
index 36f26de..6eaa4b0 100644
--- a/inc/syscall.h
+++ b/inc/syscall.h
@@ -18,6 +18,8 @@ enum {
 	SYS_ipc_try_send,
 	SYS_ipc_recv,
 	SYS_time_msec,
+	SYS_net_tx,
+	SYS_net_recv,
 	NSYSCALLS
 };
 
diff --git a/init.d b/init.d
new file mode 100644
index 0000000..a9c7591
--- /dev/null
+++ b/init.d
@@ -0,0 +1,2 @@
+init.o: kern/init.c inc/stdio.h inc/stdarg.h inc/string.h inc/types.h \
+ inc/assert.h kern/monitor.h kern/console.h
diff --git a/init.s b/init.s
new file mode 100644
index 0000000..6e3b943
--- /dev/null
+++ b/init.s
@@ -0,0 +1,411 @@
+	.file	"init.c"
+	.stabs	"kern/init.c",100,0,2,.Ltext0
+	.text
+.Ltext0:
+	.stabs	"gcc2_compiled.",60,0,0,0
+	.stabs	"int:t(0,1)=r(0,1);-2147483648;2147483647;",128,0,0,0
+	.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
+	.stabs	"long int:t(0,3)=r(0,3);-0;4294967295;",128,0,0,0
+	.stabs	"unsigned int:t(0,4)=r(0,4);0;4294967295;",128,0,0,0
+	.stabs	"long unsigned int:t(0,5)=r(0,5);0;-1;",128,0,0,0
+	.stabs	"__int128:t(0,6)=r(0,6);0;-1;",128,0,0,0
+	.stabs	"__int128 unsigned:t(0,7)=r(0,7);0;-1;",128,0,0,0
+	.stabs	"long long int:t(0,8)=r(0,8);-0;4294967295;",128,0,0,0
+	.stabs	"long long unsigned int:t(0,9)=r(0,9);0;-1;",128,0,0,0
+	.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
+	.stabs	"short unsigned int:t(0,11)=r(0,11);0;65535;",128,0,0,0
+	.stabs	"signed char:t(0,12)=r(0,12);-128;127;",128,0,0,0
+	.stabs	"unsigned char:t(0,13)=r(0,13);0;255;",128,0,0,0
+	.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
+	.stabs	"double:t(0,15)=r(0,1);8;0;",128,0,0,0
+	.stabs	"long double:t(0,16)=r(0,1);16;0;",128,0,0,0
+	.stabs	"_Decimal32:t(0,17)=r(0,1);4;0;",128,0,0,0
+	.stabs	"_Decimal64:t(0,18)=r(0,1);8;0;",128,0,0,0
+	.stabs	"_Decimal128:t(0,19)=r(0,1);16;0;",128,0,0,0
+	.stabs	"void:t(0,20)=(0,20)",128,0,0,0
+	.stabs	"./inc/stdio.h",130,0,0,0
+	.stabs	"./inc/stdarg.h",130,0,0,0
+	.stabs	"va_list:t(2,1)=(2,2)=ar(2,3)=r(2,3);0;-1;;0;0;(2,4)=xs__va_list_tag:",128,0,0,0
+	.stabn	162,0,0,0
+	.stabn	162,0,0,0
+	.stabs	"./inc/string.h",130,0,0,0
+	.stabs	"./inc/types.h",130,0,0,0
+	.stabs	"bool:t(4,1)=(4,2)=eFalse:0,True:1,;",128,0,0,0
+	.stabs	" :T(4,3)=efalse:0,true:1,;",128,0,0,0
+	.stabs	"int8_t:t(4,4)=(0,12)",128,0,0,0
+	.stabs	"uint8_t:t(4,5)=(0,13)",128,0,0,0
+	.stabs	"int16_t:t(4,6)=(0,10)",128,0,0,0
+	.stabs	"uint16_t:t(4,7)=(0,11)",128,0,0,0
+	.stabs	"int32_t:t(4,8)=(0,1)",128,0,0,0
+	.stabs	"uint32_t:t(4,9)=(0,4)",128,0,0,0
+	.stabs	"int64_t:t(4,10)=(0,8)",128,0,0,0
+	.stabs	"uint64_t:t(4,11)=(0,9)",128,0,0,0
+	.stabs	"intptr_t:t(4,12)=(4,8)",128,0,0,0
+	.stabs	"uintptr_t:t(4,13)=(4,9)",128,0,0,0
+	.stabs	"physaddr_t:t(4,14)=(4,9)",128,0,0,0
+	.stabs	"ppn_t:t(4,15)=(4,9)",128,0,0,0
+	.stabs	"size_t:t(4,16)=(4,9)",128,0,0,0
+	.stabs	"ssize_t:t(4,17)=(4,8)",128,0,0,0
+	.stabs	"off_t:t(4,18)=(4,8)",128,0,0,0
+	.stabn	162,0,0,0
+	.stabn	162,0,0,0
+	.section	.rodata.str1.1,"aMS",@progbits,1
+.LC0:
+	.string	"entering test_backtrace %d\n"
+.LC1:
+	.string	"leaving test_backtrace %d\n"
+	.section	.text.unlikely,"ax",@progbits
+.LCOLDB2:
+	.text
+.LHOTB2:
+	.p2align 4,,15
+	.stabs	"test_backtrace:F(0,20)",36,0,0,test_backtrace
+	.stabs	"x:P(0,1)",64,0,0,3
+	.globl	test_backtrace
+	.type	test_backtrace, @function
+test_backtrace:
+	.stabn	68,0,24,.LM0-.LFBB1
+.LM0:
+.LFBB1:
+.LFB0:
+	.cfi_startproc
+	pushq	%rbx
+	.cfi_def_cfa_offset 16
+	.cfi_offset 3, -16
+	.stabn	68,0,25,.LM1-.LFBB1
+.LM1:
+	movl	%edi, %esi
+	.stabn	68,0,24,.LM2-.LFBB1
+.LM2:
+	movl	%edi, %ebx
+	.stabn	68,0,25,.LM3-.LFBB1
+.LM3:
+	xorl	%eax, %eax
+	movl	$.LC0, %edi
+	call	cprintf
+	.stabn	68,0,26,.LM4-.LFBB1
+.LM4:
+	testl	%ebx, %ebx
+	jle	.L2
+	.stabn	68,0,27,.LM5-.LFBB1
+.LM5:
+	leal	-1(%rbx), %edi
+	call	test_backtrace
+	.stabn	68,0,30,.LM6-.LFBB1
+.LM6:
+	movl	%ebx, %esi
+	movl	$.LC1, %edi
+	xorl	%eax, %eax
+	.stabn	68,0,31,.LM7-.LFBB1
+.LM7:
+	popq	%rbx
+	.cfi_remember_state
+	.cfi_def_cfa_offset 8
+	.stabn	68,0,30,.LM8-.LFBB1
+.LM8:
+	jmp	cprintf
+	.p2align 4,,10
+	.p2align 3
+.L2:
+	.cfi_restore_state
+	.stabn	68,0,29,.LM9-.LFBB1
+.LM9:
+	xorl	%esi, %esi
+	xorl	%edi, %edi
+	xorl	%edx, %edx
+	call	backtrace
+	.stabn	68,0,30,.LM10-.LFBB1
+.LM10:
+	movl	%ebx, %esi
+	movl	$.LC1, %edi
+	xorl	%eax, %eax
+	.stabn	68,0,31,.LM11-.LFBB1
+.LM11:
+	popq	%rbx
+	.cfi_def_cfa_offset 8
+	.stabn	68,0,30,.LM12-.LFBB1
+.LM12:
+	jmp	cprintf
+	.cfi_endproc
+.LFE0:
+	.size	test_backtrace, .-test_backtrace
+	.section	.text.unlikely
+.LCOLDE2:
+	.text
+.LHOTE2:
+.Lscope1:
+	.section	.rodata.str1.1
+.LC3:
+	.string	"6828 decimal is %o octal!\n"
+	.section	.text.unlikely
+.LCOLDB4:
+	.text
+.LHOTB4:
+	.p2align 4,,15
+	.stabs	"i386_init:F(0,20)",36,0,0,i386_init
+	.globl	i386_init
+	.type	i386_init, @function
+i386_init:
+	.stabn	68,0,35,.LM13-.LFBB2
+.LM13:
+.LFBB2:
+.LFB1:
+	.cfi_startproc
+	.stabn	68,0,41,.LM14-.LFBB2
+.LM14:
+	movl	$end, %edx
+	.stabn	68,0,35,.LM15-.LFBB2
+.LM15:
+	subq	$8, %rsp
+	.cfi_def_cfa_offset 16
+	.stabn	68,0,41,.LM16-.LFBB2
+.LM16:
+	xorl	%esi, %esi
+	subq	$edata, %rdx
+	movl	$edata, %edi
+	call	memset
+	.stabn	68,0,45,.LM17-.LFBB2
+.LM17:
+	call	cons_init
+	.stabn	68,0,47,.LM18-.LFBB2
+.LM18:
+	movl	$.LC3, %edi
+	movl	$6828, %esi
+	xorl	%eax, %eax
+	call	cprintf
+	.stabn	68,0,50,.LM19-.LFBB2
+.LM19:
+	movl	$5, %edi
+	call	test_backtrace
+	.p2align 4,,10
+	.p2align 3
+.L7:
+	.stabn	68,0,54,.LM20-.LFBB2
+.LM20:
+	xorl	%edi, %edi
+	call	monitor
+	jmp	.L7
+	.cfi_endproc
+.LFE1:
+	.size	i386_init, .-i386_init
+	.section	.text.unlikely
+.LCOLDE4:
+	.text
+.LHOTE4:
+.Lscope2:
+	.section	.rodata.str1.1
+.LC5:
+	.string	"kernel panic at %s:%d: "
+.LC6:
+	.string	"\n"
+	.section	.text.unlikely
+.LCOLDB7:
+	.text
+.LHOTB7:
+	.p2align 4,,15
+	.stabs	"_panic:F(0,20)",36,0,0,_panic
+	.stabs	"file:P(0,21)=*(0,2)",64,0,0,5
+	.stabs	"line:P(0,1)",64,0,0,4
+	.stabs	"fmt:P(0,21)",64,0,0,3
+	.globl	_panic
+	.type	_panic, @function
+_panic:
+	.stabn	68,0,70,.LM21-.LFBB3
+.LM21:
+.LFBB3:
+.LFB2:
+	.cfi_startproc
+	pushq	%rbx
+	.cfi_def_cfa_offset 16
+	.cfi_offset 3, -16
+	movq	%rdx, %rbx
+	subq	$208, %rsp
+	.cfi_def_cfa_offset 224
+	testb	%al, %al
+	movq	%rcx, 56(%rsp)
+	movq	%r8, 64(%rsp)
+	movq	%r9, 72(%rsp)
+	je	.L10
+	movaps	%xmm0, 80(%rsp)
+	movaps	%xmm1, 96(%rsp)
+	movaps	%xmm2, 112(%rsp)
+	movaps	%xmm3, 128(%rsp)
+	movaps	%xmm4, 144(%rsp)
+	movaps	%xmm5, 160(%rsp)
+	movaps	%xmm6, 176(%rsp)
+	movaps	%xmm7, 192(%rsp)
+.L10:
+	.stabn	68,0,70,.LM22-.LFBB3
+.LM22:
+	movq	%fs:40, %rax
+	movq	%rax, 24(%rsp)
+	xorl	%eax, %eax
+	.stabn	68,0,73,.LM23-.LFBB3
+.LM23:
+	cmpq	$0, panicstr(%rip)
+	je	.L15
+	.p2align 4,,10
+	.p2align 3
+.L12:
+	.stabn	68,0,89,.LM24-.LFBB3
+.LM24:
+	xorl	%edi, %edi
+	call	monitor
+	jmp	.L12
+.L15:
+	.stabn	68,0,75,.LM25-.LFBB3
+.LM25:
+	movq	%rbx, panicstr(%rip)
+	.stabn	68,0,78,.LM26-.LFBB3
+.LM26:
+#APP
+# 78 "kern/init.c" 1
+	cli; cld
+# 0 "" 2
+	.stabn	68,0,80,.LM27-.LFBB3
+.LM27:
+#NO_APP
+	leaq	224(%rsp), %rax
+	.stabn	68,0,81,.LM28-.LFBB3
+.LM28:
+	movl	%esi, %edx
+	movq	%rdi, %rsi
+	movl	$.LC5, %edi
+	.stabn	68,0,80,.LM29-.LFBB3
+.LM29:
+	movl	$24, (%rsp)
+	movl	$48, 4(%rsp)
+	movq	%rax, 8(%rsp)
+	leaq	32(%rsp), %rax
+	movq	%rax, 16(%rsp)
+	.stabn	68,0,81,.LM30-.LFBB3
+.LM30:
+	xorl	%eax, %eax
+	call	cprintf
+	.stabn	68,0,82,.LM31-.LFBB3
+.LM31:
+	movq	%rbx, %rdi
+	movq	%rsp, %rsi
+	call	vcprintf
+	.stabn	68,0,83,.LM32-.LFBB3
+.LM32:
+	movl	$.LC6, %edi
+	xorl	%eax, %eax
+	call	cprintf
+	jmp	.L12
+	.cfi_endproc
+.LFE2:
+	.size	_panic, .-_panic
+	.section	.text.unlikely
+.LCOLDE7:
+	.text
+.LHOTE7:
+	.stabs	"ap:(2,1)",128,0,0,0
+	.stabn	192,0,0,.LFBB3-.LFBB3
+	.stabn	224,0,0,.Lscope3-.LFBB3
+.Lscope3:
+	.section	.rodata.str1.1
+.LC8:
+	.string	"kernel warning at %s:%d: "
+	.section	.text.unlikely
+.LCOLDB9:
+	.text
+.LHOTB9:
+	.p2align 4,,15
+	.stabs	"_warn:F(0,20)",36,0,0,_warn
+	.stabs	"file:P(0,21)",64,0,0,5
+	.stabs	"line:P(0,1)",64,0,0,4
+	.stabs	"fmt:P(0,21)",64,0,0,3
+	.globl	_warn
+	.type	_warn, @function
+_warn:
+	.stabn	68,0,95,.LM33-.LFBB4
+.LM33:
+.LFBB4:
+.LFB3:
+	.cfi_startproc
+	pushq	%rbx
+	.cfi_def_cfa_offset 16
+	.cfi_offset 3, -16
+	movq	%rdx, %rbx
+	subq	$208, %rsp
+	.cfi_def_cfa_offset 224
+	testb	%al, %al
+	movq	%rcx, 56(%rsp)
+	movq	%r8, 64(%rsp)
+	movq	%r9, 72(%rsp)
+	je	.L17
+	movaps	%xmm0, 80(%rsp)
+	movaps	%xmm1, 96(%rsp)
+	movaps	%xmm2, 112(%rsp)
+	movaps	%xmm3, 128(%rsp)
+	movaps	%xmm4, 144(%rsp)
+	movaps	%xmm5, 160(%rsp)
+	movaps	%xmm6, 176(%rsp)
+	movaps	%xmm7, 192(%rsp)
+.L17:
+	.stabn	68,0,95,.LM34-.LFBB4
+.LM34:
+	movq	%fs:40, %rax
+	movq	%rax, 24(%rsp)
+	xorl	%eax, %eax
+	.stabn	68,0,98,.LM35-.LFBB4
+.LM35:
+	leaq	224(%rsp), %rax
+	.stabn	68,0,99,.LM36-.LFBB4
+.LM36:
+	movl	%esi, %edx
+	movq	%rdi, %rsi
+	movl	$.LC8, %edi
+	.stabn	68,0,98,.LM37-.LFBB4
+.LM37:
+	movq	%rax, 8(%rsp)
+	leaq	32(%rsp), %rax
+	movl	$24, (%rsp)
+	movl	$48, 4(%rsp)
+	movq	%rax, 16(%rsp)
+	.stabn	68,0,99,.LM38-.LFBB4
+.LM38:
+	xorl	%eax, %eax
+	call	cprintf
+	.stabn	68,0,100,.LM39-.LFBB4
+.LM39:
+	movq	%rsp, %rsi
+	movq	%rbx, %rdi
+	call	vcprintf
+	.stabn	68,0,101,.LM40-.LFBB4
+.LM40:
+	xorl	%eax, %eax
+	movl	$.LC6, %edi
+	call	cprintf
+	.stabn	68,0,103,.LM41-.LFBB4
+.LM41:
+	movq	24(%rsp), %rax
+	xorq	%fs:40, %rax
+	jne	.L20
+	addq	$208, %rsp
+	.cfi_remember_state
+	.cfi_def_cfa_offset 16
+	popq	%rbx
+	.cfi_def_cfa_offset 8
+	ret
+.L20:
+	.cfi_restore_state
+	call	__stack_chk_fail
+	.cfi_endproc
+.LFE3:
+	.size	_warn, .-_warn
+	.section	.text.unlikely
+.LCOLDE9:
+	.text
+.LHOTE9:
+	.stabs	"ap:(2,1)",128,0,0,0
+	.stabn	192,0,0,.LFBB4-.LFBB4
+	.stabn	224,0,0,.Lscope4-.LFBB4
+.Lscope4:
+	.comm	panicstr,8,8
+	.stabs	"panicstr:G(0,21)",32,0,0,0
+	.stabs	"",100,0,0,.Letext0
+.Letext0:
+	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.5) 5.4.0 20160609"
+	.section	.note.GNU-stack,"",@progbits
diff --git a/kern/e1000.c b/kern/e1000.c
index 7570e75..75df546 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -1,3 +1,111 @@
 #include <kern/e1000.h>
 
 // LAB 6: Your driver code here
+
+struct e1000_tx_desc tx_desc_buf[TXRING_LEN] __attribute__ ((aligned (PGSIZE)));
+struct e1000_data tx_data_buf[TXRING_LEN] __attribute__ ((aligned (PGSIZE)));
+
+struct e1000_rx_desc rx_desc_buf[RXRING_LEN] __attribute__ ((aligned (PGSIZE)));
+struct e1000_data rx_data_buf[RXRING_LEN] __attribute__ ((aligned (PGSIZE)));
+
+static void
+init_desc(){
+ int i;
+ for (i = 0; i < TXRING_LEN; ++i)
+ {
+   tx_desc_buf[i].buffer_addr = PADDR(&tx_data_buf[i]);
+   tx_desc_buf[i].upper.fields.status = E1000_TXD_STAT_DD;
+ }
+ for (i = 0; i < RXRING_LEN; ++i)
+ {
+   rx_desc_buf[i].buffer_addr = PADDR(&rx_data_buf[i]);
+ }
+}
+
+static void
+e1000_init(){
+ assert(e1000[E1000_STATUS] == 0x80080783);
+ e1000[E1000_TDBAL] = PADDR(tx_desc_buf);
+ e1000[E1000_TDBAH] = 0x0;
+ e1000[E1000_TDH] = 0x0;
+ e1000[E1000_TDT] = 0x0;
+ e1000[E1000_TDLEN] = TXRING_LEN * sizeof(struct e1000_tx_desc);
+ e1000[E1000_TCTL] = VALUEATMASK(1, E1000_TCTL_EN) |
+           VALUEATMASK(1, E1000_TCTL_PSP) |
+           VALUEATMASK(0x10, E1000_TCTL_CT) |
+           VALUEATMASK(0x40, E1000_TCTL_COLD);
+ e1000[E1000_TIPG] = VALUEATMASK(10, E1000_TIPG_IPGT) |
+           VALUEATMASK(8, E1000_TIPG_IPGR1) |
+          VALUEATMASK(6, E1000_TIPG_IPGR2);
+ e1000[E1000_RAL] = 0x12005452;
+ e1000[E1000_RAH] = 0x00005634 | E1000_RAH_AV;
+ e1000[E1000_RDBAL] = PADDR(rx_desc_buf);
+ e1000[E1000_RDBAH] = 0x0;
+e1000[E1000_RDLEN] = RXRING_LEN * sizeof(struct e1000_rx_desc);
+ e1000[E1000_RDH] = 0x0;
+ e1000[E1000_RDT] = RXRING_LEN;
+ e1000[E1000_RCTL] = E1000_RCTL_EN |
+           !E1000_RCTL_LPE |
+           E1000_RCTL_LBM_NO |
+           E1000_RCTL_RDMTS_HALF |
+           E1000_RCTL_MO_0 |
+           E1000_RCTL_BAM |
+           E1000_RCTL_BSEX |
+           E1000_RCTL_SZ_4096 |
+           E1000_RCTL_SECRC;
+	}
+
+int
+e1000_attach(struct pci_func *pcif){
+ // enable PCI function
+ pci_func_enable(pcif);
+ //init descriptor
+ init_desc();
+ // create virtual memory mapping
+ e1000 = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);
+ cprintf("device status reg: %x\n", e1000[E1000_STATUS]);
+ // check the status register
+ assert(e1000[E1000_STATUS] == 0x80080783);
+ // init the hardware
+ e1000_init();
+
+//char arr[10]="Check";
+//e1000_tx(arr,5);
+
+ return 0;
+}
+
+int
+e1000_tx(uint8_t * addr, size_t length){
+ uint32_t tail = e1000[E1000_TDT];
+ struct e1000_tx_desc * tail_desc = &tx_desc_buf[tail];
+ if (tail_desc->upper.fields.status != E1000_TXD_STAT_DD)
+ {
+   return -1;
+ }
+ length = length > DATA_SIZE ? DATA_SIZE : length;
+ memmove(&tx_data_buf[tail], addr, length);
+tail_desc->lower.flags.length = length;
+ tail_desc->upper.fields.status = 0;
+ tail_desc->lower.data |=  (E1000_TXD_CMD_RS |
+                E1000_TXD_CMD_EOP);
+ e1000[E1000_TDT] = (tail + 1) % TXRING_LEN;
+ return 0;
+}
+
+int
+e1000_recv(uint8_t * data){
+ static uint32_t real_tail = 0;
+ uint32_t tail = real_tail;
+ struct e1000_rx_desc * tail_desc = &rx_desc_buf[tail];
+ if (!(tail_desc->status & E1000_RXD_STAT_DD))
+ {
+   return -1;
+ }
+ size_t length = tail_desc->length;
+ memmove(data, &rx_data_buf[tail], length);
+ tail_desc->status = 0;
+ e1000[E1000_RDT] = tail;
+ real_tail = (tail + 1) % RXRING_LEN;
+ return length;
+}
\ No newline at end of file
diff --git a/kern/e1000.h b/kern/e1000.h
index e563ac4..56d7da3 100644
--- a/kern/e1000.h
+++ b/kern/e1000.h
@@ -1,4 +1,199 @@
 #ifndef JOS_KERN_E1000_H
 #define JOS_KERN_E1000_H
 
+#include<kern/pci.h>
+#include <kern/pmap.h>
+#include<inc/string.h>
+// Some macro adapted from linux e1000_hw.h
+
+/* PCI Device IDs */
+#define E1000_DEV_ID_82540EM             0x100E
+/* Register Set. (82543, 82544)
+ *
+ * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+ * These registers are physically located on the NIC, but are mapped into the
+ * host memory address space.
+ *
+ * RW - register is both readable and writable
+ * RO - register is read only
+ * WO - register is write only
+ * R/clr - register is read only and is cleared when read
+ * A - register array
+ */
+#define E1000_STATUS   0x00008 / 4  /* Device Status - RO */
+#define E1000_TCTL     0x00400 / 4  /* TX Control - RW */
+#define E1000_TIPG     0x00410 / 4  /* TX Inter-packet gap -RW */
+#define E1000_TDBAL    0x03800 / 4  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804 / 4  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808 / 4  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810 / 4  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818 / 4 /* TX Descripotr Tail - RW */
+#define E1000_TDT      0x03818 / 4  /* TX Descripotr Tail - RW */
+#define E1000_RCTL     0x00100 / 4  /* RX Control - RW */
+#define E1000_RA       0x05400 / 4  /* Receive Address - RW Array */
+#define E1000_RAL      0x05400 / 4  /* Receive Address Low - RW */
+#define E1000_RAH      0x05404 / 4  /* Receive Address HIGH - RW */
+#define E1000_RDBAL    0x02800 / 4  /* RX Descriptor Base Address Low - RW */
+#define E1000_RDBAH    0x02804 / 4  /* RX Descriptor Base Address High - RW */
+#define E1000_RDLEN    0x02808 / 4  /* RX Descriptor Length - RW */
+#define E1000_RDH      0x02810 / 4  /* RX Descriptor Head - RW */
+#define E1000_RDT      0x02818 / 4  /* RX Descriptor Tail - RW */
+/* Transmit Control */
+#define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+#define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+#define E1000_TCTL_MULR   0x10000000    /* Multiple request support */
+ /* Receive Control */
+#define E1000_RCTL_RST            0x00000001    /* Software reset */
+#define E1000_RCTL_EN             0x00000002    /* enable */
+#define E1000_RCTL_SBP            0x00000004    /* store bad packet */
+#define E1000_RCTL_UPE            0x00000008    /* unicast promiscuous enable */
+#define E1000_RCTL_MPE            0x00000010    /* multicast promiscuous enab */
+#define E1000_RCTL_LPE            0x00000020    /* long packet enable */
+#define E1000_RCTL_LBM_NO         0x00000000    /* no loopback mode */
+#define E1000_RCTL_LBM_MAC        0x00000040    /* MAC loopback mode */
+#define E1000_RCTL_LBM_SLP        0x00000080    /* serial link loopback mode */
+#define E1000_RCTL_LBM_TCVR       0x000000C0    /* tcvr loopback mode */
+#define E1000_RCTL_DTYP_MASK      0x00000C00    /* Descriptor type mask */
+#define E1000_RCTL_DTYP_PS        0x00000400    /* Packet Split descriptor */
+#define E1000_RCTL_RDMTS_HALF     0x00000000    /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT     0x00000100    /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH    0x00000200    /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT       12            /* multicast offset shift */
+#define E1000_RCTL_MO_0           0x00000000    /* multicast offset 11:0 */
+#define E1000_RCTL_MO_1           0x00001000    /* multicast offset 12:1 */
+#define E1000_RCTL_MO_2           0x00002000    /* multicast offset 13:2 */
+#define E1000_RCTL_MO_3           0x00003000    /* multicast offset 15:4 */
+#define E1000_RCTL_MDR            0x00004000    /* multicast desc ring 0 */
+#define E1000_RCTL_BAM            0x00008000    /* broadcast enable */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+#define E1000_RCTL_SZ_2048        0x00000000    /* rx buffer size 2048 */
+#define E1000_RCTL_SZ_1024        0x00010000    /* rx buffer size 1024 */
+#define E1000_RCTL_SZ_512         0x00020000    /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256         0x00030000    /* rx buffer size 256 */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+#define E1000_RCTL_SZ_16384       0x00010000    /* rx buffer size 16384 */
+#define E1000_RCTL_SZ_8192        0x00020000    /* rx buffer size 8192 */
+#define E1000_RCTL_SZ_4096        0x00030000    /* rx buffer size 4096 */
+#define E1000_RCTL_VFE            0x00040000    /* vlan filter enable */
+#define E1000_RCTL_CFIEN          0x00080000    /* canonical form enable */
+#define E1000_RCTL_CFI            0x00100000    /* canonical form indicator */
+#define E1000_RCTL_DPF            0x00400000    /* discard pause frames */
+#define E1000_RCTL_PMCF           0x00800000    /* pass MAC control frames */
+#define E1000_RCTL_BSEX           0x02000000    /* Buffer size extension */
+#define E1000_RCTL_SECRC          0x04000000    /* Strip Ethernet CRC */
+#define E1000_RCTL_FLXBUF_MASK    0x78000000    /* Flexible buffer size */
+#define E1000_RCTL_FLXBUF_SHIFT   27            /* Flexible buffer shift */
+ /* Transmit Descriptor bit definitions */
+#define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+#define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+#define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+#define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+#define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+#define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+#define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+#define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+#define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+#define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+#define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+#define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+#define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+#define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+#define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+#define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+#define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+/* Receive Descriptor bit definitions */
+#define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+#define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+#define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+#define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+#define E1000_RXD_STAT_UDPCS    0x10    /* UDP xsum caculated */
+#define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+#define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+#define E1000_RXD_STAT_IPIDV    0x200   /* IP identification valid */
+#define E1000_RXD_STAT_UDPV     0x400   /* Valid UDP checksum */
+#define E1000_RXD_STAT_ACK      0x8000  /* ACK Packet indication */
+#define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+#define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+#define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+#define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+#define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+#define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+#define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+#define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+#define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+#define E1000_RXD_SPC_PRI_SHIFT 13
+#define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+#define E1000_RXD_SPC_CFI_SHIFT 12
+ /* TX Inter-packet gap bit definitions */
+#define E1000_TIPG_IPGT      0x000003FF
+#define E1000_TIPG_IPGR1     0x000FFA00
+#define E1000_TIPG_IPGR2     0x3FF00000
+
+#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+
+#define TXRING_LEN 64
+#define RXRING_LEN 128
+//#define TXDATA_SIZE 2048
+#define DATA_SIZE 4096
+
+/* Transmit Descriptor */
+struct e1000_tx_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t cso;        /* Checksum offset */
+            uint8_t cmd;        /* Descriptor control */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+           uint8_t css;        /* Checksum start */
+            uint16_t special;
+        } fields;
+    } upper;
+};
+
+/* Receive Descriptor */
+struct e1000_rx_desc {
+    uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+    uint16_t length;     /* Length of data DMAed into data buffer */
+    uint16_t csum;       /* Packet checksum */
+    uint8_t status;      /* Descriptor status */
+    uint8_t errors;      /* Descriptor Errors */
+    uint16_t special;
+};
+
+/* Data */
+struct e1000_data {
+//    uint8_t data[4096];
+    uint8_t data[DATA_SIZE];
+};
+
+#define VALUEATMASK(value, mask) value * ((mask) & ~((mask) << 1))
+
+volatile uint32_t* e1000;
+
+int e1000_attach(struct pci_func *pcif);
+//int e1000_tx(void * addr, size_t length);
+int e1000_tx(uint8_t * addr, size_t length);
+
+int e1000_recv(uint8_t * addr);
+
+
 #endif	// JOS_KERN_E1000_H
diff --git a/kern/env.c b/kern/env.c
index ebb1c02..5bf048a 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -119,11 +119,35 @@ env_init(void)
 {
 	// Set up envs array
 	// LAB 3: Your code here.
-
-	// Per-CPU part of the initialization
+                                    
+       // memset (envs, 0, NENV*sizeof(struct Env));               
+        
+        //envs ==> Starting address of memory to be filled
+	//0   ==> Value to be filled
+        //sizeof(struct ENV) * NENV   ==> Number of bytes to be filled starting from envs
+
+	int32_t i;
+	env_free_list = NULL;
+	
+        for (i = NENV; i >= 0; i--) {
+	//initialize backwards to maintain the order
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+        env_free_list = &envs[i];
+    }
+        //envs[i].env_status = ENV_FREE;
+        //envs[i].env_runs = 0;
+        //envs[i].env_type = ENV_TYPE_USER;
+        //envs[i].env_pgdir = NULL;
+	//normal link-list routine
+        
+	
 	env_init_percpu();
 }
 
+
+
+
 // Load GDT and segment descriptors.
 void
 env_init_percpu(void)
@@ -182,14 +206,39 @@ env_setup_vm(struct Env *e)
 	//    - The functions in kern/pmap.h are handy.
 
 	// LAB 3: Your code here.
+	/*e->env_pgdir = page2kva(p);                        
+
+        for(i = 0; i < PDX(UTOP); i++)                     
+        {
+          e->env_pgdir[i] = 0;                             
+        }
+
+        for(i = PDX(UTOP); i < NPDENTRIES; i++)            
+        {
+          e->env_pgdir[i] = kern_pgdir[i];                 //allocating kern_pgdir to the env_pgdir
+        }
+
+        p->pp_ref++;                                       //increment the reference counter if the page is allocated successfully
+	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+	return 0;
+}*/
 
+
+
+e->env_pgdir =(pde_t*) page2kva(p);
+	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
+	
+	//void *memcpy(void *dest, const void *src, size_t n);
+	p->pp_ref++;
 	// UVPT maps the env's own page table read-only.
 	// Permissions: kernel R, user R
 	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
-
+	
 	return 0;
 }
 
+
 //
 // Allocates and initializes a new environment.
 // On success, the new environment is stored in *newenv_store.
@@ -213,7 +262,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 		return r;
 
 	// Generate an env_id for this environment.
-	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1); //~3FF
 	if (generation <= 0)	// Don't create a negative env_id.
 		generation = 1 << ENVGENSHIFT;
 	e->env_id = generation | (e - envs);
@@ -247,6 +296,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 
 	// Enable interrupts while in user mode.
 	// LAB 4: Your code here.
+	e->env_tf.tf_eflags |= FL_IF;
 
 	// Clear the page fault handler until user installs one.
 	e->env_pgfault_upcall = 0;
@@ -279,6 +329,28 @@ region_alloc(struct Env *e, void *va, size_t len)
 	//   'va' and 'len' values that are not page-aligned.
 	//   You should round va down, and round (va + len) up.
 	//   (Watch out for corner-cases!)
+	/*uintptr_t start = ROUNDDOWN((uintptr_t) va, PGSIZE);                            
+        uintptr_t end = ROUNDUP((uintptr_t) va+len, PGSIZE);                            
+
+        for (; start<end; start+=PGSIZE)
+        {
+           struct PageInfo *pp = page_alloc(ALLOC_ZERO);                                
+           if (!pp)                                                                     
+           panic ("No memory");                                                     
+           page_insert(e->env_pgdir, pp, (void*) start, PTE_U | PTE_P | PTE_W);           
+           
+	}
+}*/
+void *start = ROUNDDOWN(va, PGSIZE);
+	void *end = ROUNDUP(start + len, PGSIZE);
+
+	struct PageInfo *p = NULL;
+	for (start; start < end; start += PGSIZE) {
+		p = page_alloc(0);
+		if (p == NULL)
+			panic("Could not allocate a page!");
+		page_insert(e->env_pgdir, p, start, PTE_W | PTE_U | PTE_P);
+	}
 }
 
 //
@@ -338,6 +410,74 @@ load_icode(struct Env *e, uint8_t *binary)
 
 	// Now map one page for the program's initial stack
 	// at virtual address USTACKTOP - PGSIZE.
+	/*struct Proghdr *ph, *eph;                                            
+        struct Elf *ELFHDR = (struct Elf *) binary;               
+                                                                
+        if (ELFHDR->e_magic != ELF_MAGIC)                                   
+		panic ("Not a valid Elf file!");                              
+           
+        // load each program segment 
+        ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff); 
+        eph = ph + ELFHDR->e_phnum;                           
+           
+        lcr3(PADDR(e->env_pgdir));                                           //switch to env_pgdir
+          
+        for (; ph < eph; ph++)                                               //iterate through the program header table
+        {
+
+           if (ph->p_type == ELF_PROG_LOAD)                                  //load segments only when 'ph->p_type == ELF_PROG_LOAD'
+           {
+                 // allocate memory for this binary
+                 region_alloc(e, (void *)ph->p_va, ph->p_memsz);                
+                 // Init .bss
+                 memset((void *)ph->p_va, 0, ph->p_memsz);                      
+                 // Load binary image into memory
+                 memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+           } 
+} 
+	//Modified env's trapframe
+        // other files in trap frame is set in env_alloc.
+        e->env_tf.tf_eip = ELFHDR->e_entry;                                  
+	lcr3(PADDR(kern_pgdir)); 					     //switch back to kern_pgdir
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
+
+	
+	region_alloc(e, (void *)USTACKTOP - PGSIZE, PGSIZE);
+}*/
+
+ struct Elf *ELFHDR = (struct Elf *) binary;
+	struct Proghdr *ph, *eph;
+
+	if (ELFHDR->e_magic != ELF_MAGIC)
+		panic("Not executable!");
+	
+	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
+	eph = ph + ELFHDR->e_phnum;
+	
+	//here above is just as same as main.c
+
+	lcr3(PADDR(e->env_pgdir));
+	//it's silly to use kern_pgdir here.
+
+	for (; ph < eph; ph++)
+		if (ph->p_type == ELF_PROG_LOAD) {
+			region_alloc(e, (void *)ph->p_va, ph->p_memsz);
+			memset((void *)ph->p_va, 0, ph->p_memsz);
+			memcpy((void *)ph->p_va, binary+ph->p_offset, ph->p_filesz);
+		}
+
+	//we can use this because kern_pgdir is a subset of e->env_pgdir
+	lcr3(PADDR(kern_pgdir));
+
+	e->env_tf.tf_eip = ELFHDR->e_entry;
+	//we should set eip to make sure env_pop_tf runs correctly
+
+	region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
 
 	// LAB 3: Your code here.
 }
@@ -354,8 +494,30 @@ env_create(uint8_t *binary, enum EnvType type)
 {
 	// LAB 3: Your code here.
 
+
 	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
 	// LAB 5: Your code here.
+
+	
+	struct Env* e;
+
+	int env = env_alloc(&e, 0);                              
+
+	if(env == -E_NO_FREE_ENV)                                
+        { 
+	    panic("no free environments"); 
+	}
+        else if(env == -E_NO_MEM)                                
+        {
+	    panic("no memory"); 
+	}	
+                            
+	load_icode(e, binary);                             //loads the elf binary image into the environment
+	e->env_type = type;                                //set the environment type
+
+	if(type == ENV_TYPE_FS)
+        e->env_tf.tf_eflags =e->env_tf.tf_eflags|FL_IOPL_3; //eflags i/o privilege level 3//eflags in mmu.h
+
 }
 
 //
@@ -486,7 +648,24 @@ env_run(struct Env *e)
 	//	e->env_tf to sensible values.
 
 	// LAB 3: Your code here.
-
-	panic("env_run not yet implemented");
+	if(curenv != e)                                                    
+        {
+          if(curenv && curenv->env_status == ENV_RUNNING)                  
+          {
+              curenv->env_status = ENV_RUNNABLE;                           
+          }
+          curenv = e;                                                      
+          curenv->env_status = ENV_RUNNING;                                
+          curenv->env_runs++;                                              
+         lcr3(PADDR(curenv->env_pgdir));                                    
+        }
+        
+        
+        //step 2
+	 unlock_kernel();
+        env_pop_tf(&curenv->env_tf);                                       
+
+
+	//panic("env_run not yet implemented");
 }
 
diff --git a/kern/init.c b/kern/init.c
index 1dce3a3..9bd84f4 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -57,6 +57,7 @@ i386_init(void)
 	// Acquire the big kernel lock before waking up APs
 	// Your code here:
 
+lock_kernel();
 	// Starting non-boot CPUs
 	boot_aps();
 
@@ -73,7 +74,24 @@ i386_init(void)
 	ENV_CREATE(TEST, ENV_TYPE_USER);
 #else
 	// Touch all you want.
-	ENV_CREATE(user_icode, ENV_TYPE_USER);
+//	ENV_CREATE(user_spawnhello, ENV_TYPE_USER);
+	ENV_CREATE(user_testkbd, ENV_TYPE_USER);
+//	ENV_CREATE(user_icode, ENV_TYPE_USER);
+
+//	ENV_CREATE(user_primes, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_yield, ENV_TYPE_USER);
+	//ENV_CREATE(user_dumbfork, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultread, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultalloc, ENV_TYPE_USER);
+    //ENV_CREATE(user_faultdie, ENV_TYPE_USER);
+      //ENV_CREATE(user_faultallocbad, ENV_TYPE_USER);
+      //ENV_CREATE(user_faultnostack, ENV_TYPE_USER);
+      //ENV_CREATE(user_forktree, ENV_TYPE_USER);
+
 #endif // TEST*
 
 	// Should not be necessary - drains keyboard because interrupt has given up.
@@ -99,6 +117,8 @@ boot_aps(void)
 	// Write entry code to unused memory at MPENTRY_PADDR
 	code = KADDR(MPENTRY_PADDR);
 	memmove(code, mpentry_start, mpentry_end - mpentry_start);
+	
+	//void *memmove(void *dest, const void *src, size_t n);
 
 	// Boot each AP one at a time
 	for (c = cpus; c < cpus + ncpu; c++) {
@@ -108,7 +128,8 @@ boot_aps(void)
 		// Tell mpentry.S what stack to use 
 		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
 		// Start the CPU at mpentry_start
-		lapic_startap(c->cpu_id, PADDR(code));
+		lapic_startap(c->cpu_id, PADDR(code)); //Start additional processor running entry code at addr.
+		//lapic_startap(uint8_t apicid, uint32_t addr)
 		// Wait for the CPU to finish some basic setup in mp_main()
 		while(c->cpu_status != CPU_STARTED)
 			;
@@ -133,9 +154,10 @@ mp_main(void)
 	// only one CPU can enter the scheduler at a time!
 	//
 	// Your code here:
-
+	lock_kernel();
+	sched_yield();
 	// Remove this after you finish Exercise 6
-	for (;;);
+	//for (;;);
 }
 
 /*
diff --git a/kern/kdebug.c b/kern/kdebug.c
index f4ee8ee..78772b8 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -142,12 +142,20 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 		// Make sure this memory is valid.
 		// Return -1 if it is not.  Hint: Call user_mem_check.
 		// LAB 3: Your code here.
-
+		
 		stabs = usd->stabs;
 		stab_end = usd->stab_end;
 		stabstr = usd->stabstr;
 		stabstr_end = usd->stabstr_end;
-
+		if(user_mem_check(curenv , usd , sizeof(struct UserStabData) , PTE_U) < 0) {
+			return -1;
+		}
+		if (user_mem_check(curenv , (void *)stabs , (uint32_t)stab_end - (uint32_t)stabs , PTE_U) < 0) {
+			return -1;
+		}
+		if (user_mem_check(curenv , (void *) stabstr , (uint32_t)stabstr_end - (uint32_t)stabstr , PTE_U) < 0) {
+			return -1;
+}
 		// Make sure the STABS and string table memory is valid.
 		// LAB 3: Your code here.
 	}
@@ -204,6 +212,10 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 	//	Look at the STABS documentation and <inc/stab.h> to find
 	//	which one.
 	// Your code here.
+	stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+                 if(lline > rline)
+                 return -1;
+		 info->eip_line = stabs[rline].n_desc;
 
 
 	// Search backwards from the line number for the relevant filename
diff --git a/kern/monitor.c b/kern/monitor.c
index 4e00796..5e50d7a 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -58,7 +58,16 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
 int
 mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 {
-	// Your code here.
+		uint32_t* p=(uint32_t *) read_ebp();
+	cprintf("Stack backtrace:\n");
+	while(p)
+	{
+	 	struct Eipdebuginfo info;
+		cprintf("ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",p, *(p+1),*(p+2),*(p+3),*(p+4),*(p+5),*(p+6));
+		debuginfo_eip(*(p+1), &info);
+		cprintf("\t%s:%d : %.*s+%u\n",info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, (*(p+1)-info.eip_fn_addr));
+		p=(uint32_t*)*p;
+	}
 	return 0;
 }
 
diff --git a/kern/pci.c b/kern/pci.c
index 784e072..e5c703c 100644
--- a/kern/pci.c
+++ b/kern/pci.c
@@ -31,6 +31,8 @@ struct pci_driver pci_attach_class[] = {
 // pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1
 // and key2 should be the vendor ID and device ID respectively
 struct pci_driver pci_attach_vendor[] = {
+	{ 0x8086, 0x100e, e1000_attach},
+
 	{ 0, 0, 0 },
 };
 
diff --git a/kern/pci.h b/kern/pci.h
index 06f510c..1763457 100644
--- a/kern/pci.h
+++ b/kern/pci.h
@@ -28,6 +28,7 @@ struct pci_bus {
 };
 
 int  pci_init(void);
-void pci_func_enable(struct pci_func *f);
+
+extern void pci_func_enable(struct pci_func *f);
 
 #endif
diff --git a/kern/pmap.c b/kern/pmap.c
index 7f2244a..e81e9ed 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -99,14 +99,25 @@ boot_alloc(uint32_t n)
 		extern char end[];
 		nextfree = ROUNDUP((char *) end, PGSIZE);
 	}
-
 	// Allocate a chunk large enough to hold 'n' bytes, then update
 	// nextfree.  Make sure nextfree is kept aligned
 	// to a multiple of PGSIZE.
 	//
 	// LAB 2: Your code here.
+	 if (n>0) {
+		char *temp = nextfree;
+		nextfree = ROUNDUP((char *) (nextfree+n), PGSIZE);
+		return temp;
+	} 
+	if ((uint32_t)nextfree > KERNBASE + npages*PGSIZE){
+	panic ("boot_alloc failed - Out of memory");
+	}
+	else
+        return nextfree;
+
+	//return NULL;
+
 
-	return NULL;
 }
 
 // Set up a two-level page table:
@@ -128,7 +139,7 @@ mem_init(void)
 	i386_detect_memory();
 
 	// Remove this line when you're ready to test this function.
-	panic("mem_init: This function is not finished\n");
+	//panic("mem_init: This function is not finished\n");
 
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
@@ -151,11 +162,17 @@ mem_init(void)
 	// array.  'npages' is the number of physical pages in memory.  Use memset
 	// to initialize all fields of each struct PageInfo to 0.
 	// Your code goes here:
-
+	
+        pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
+    	memset(pages, 0, sizeof(struct PageInfo) * npages);
+	//pages ==> Starting address of memory to be filled
+	//0   ==> Value to be filled
+        //sizeof(struct PageInfo) * npages   ==> Number of bytes to be filled starting from pages
 
 	//////////////////////////////////////////////////////////////////////
 	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
 	// LAB 3: Your code here.
+	envs = (struct Env *)boot_alloc(NENV*sizeof(struct Env));   
 
 	//////////////////////////////////////////////////////////////////////
 	// Now that we've allocated the initial kernel data structures, we set
@@ -179,6 +196,7 @@ mem_init(void)
 	//      (ie. perm = PTE_U | PTE_P)
 	//    - pages itself -- kernel RW, user NONE
 	// Your code goes here:
+	 boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
 
 	//////////////////////////////////////////////////////////////////////
 	// Map the 'envs' array read-only by the user at linear address UENVS
@@ -187,7 +205,7 @@ mem_init(void)
 	//    - the new image at UENVS  -- kernel R, user R
 	//    - envs itself -- kernel RW, user NONE
 	// LAB 3: Your code here.
-
+	boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);
 	//////////////////////////////////////////////////////////////////////
 	// Use the physical memory that 'bootstack' refers to as the kernel
 	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
@@ -199,7 +217,7 @@ mem_init(void)
 	//       overwrite memory.  Known as a "guard page".
 	//     Permissions: kernel RW, user NONE
 	// Your code goes here:
-
+	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);
 	//////////////////////////////////////////////////////////////////////
 	// Map all of physical memory at KERNBASE.
 	// Ie.  the VA range [KERNBASE, 2^32) should map to
@@ -208,7 +226,7 @@ mem_init(void)
 	// we just set up the mapping anyway.
 	// Permissions: kernel RW, user NONE
 	// Your code goes here:
-
+	 boot_map_region(kern_pgdir, KERNBASE, 0xFFFFFFFF-KERNBASE, 0, PTE_W | PTE_P);
 	// Initialize the SMP-related parts of the memory map
 	mem_init_mp();
 
@@ -259,7 +277,16 @@ mem_init_mp(void)
 	//     Permissions: kernel RW, user NONE
 	//
 	// LAB 4: Your code here:
-
+	
+	int i;
+	for (i = 0; i < NCPU; ++i) {
+		 uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
+		boot_map_region(kern_pgdir, 
+			kstacktop_i - KSTKSIZE, 
+			KSTKSIZE, 
+			PADDR(percpu_kstacks[i]), 
+			PTE_W);
+	}
 }
 
 // --------------------------------------------------------------
@@ -299,10 +326,38 @@ page_init(void)
 	// NB: DO NOT actually touch the physical memory corresponding to
 	// free pages!
 	size_t i;
+	// 0xA0
+	size_t io_hole_begin = IOPHYSMEM / PGSIZE;
+	// 0x100
+	size_t io_hole_end = ROUNDUP(EXTPHYSMEM, PGSIZE) / PGSIZE;
+	size_t kernel_end = io_hole_end + (size_t) (boot_alloc(0) - KERNBASE) / PGSIZE;
+	page_free_list = NULL;
+
+	// i < 0x40FF
 	for (i = 0; i < npages; i++) {
-		pages[i].pp_ref = 0;
-		pages[i].pp_link = page_free_list;
-		page_free_list = &pages[i];
+		// 1)
+		if (i == 0|| i==MPENTRY_PADDR/PGSIZE) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 2) i < 0xA0
+		} else if (i < npages_basemem) {
+			pages[i].pp_ref = 0;
+			pages[i].pp_link = page_free_list;
+			page_free_list = &pages[i];
+		// 3) 0xA0 <= i < 0x100
+		} else if (io_hole_begin <= i && i < io_hole_end) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 4) 0x100 <= i < 0x400 (0xF0400000)
+		} else if (io_hole_end <= i && i < kernel_end) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+		// 4) 0x400 <= i
+		} else {
+			pages[i].pp_ref = 0;
+			pages[i].pp_link = page_free_list;
+			page_free_list = &pages[i];
+		}
 	}
 }
 
@@ -322,7 +377,21 @@ struct PageInfo *
 page_alloc(int alloc_flags)
 {
 	// Fill this function in
-	return 0;
+	struct PageInfo *page;
+	
+	if (page_free_list!=NULL){
+	page = page_free_list;
+	page_free_list = page->pp_link;
+	page->pp_link = NULL;
+	
+	if (alloc_flags & ALLOC_ZERO) {
+		memset(page2kva(page), '\0', PGSIZE);
+	}
+	return page;
+	}
+	return NULL;
+	//return 0;
+	
 }
 
 //
@@ -332,6 +401,12 @@ page_alloc(int alloc_flags)
 void
 page_free(struct PageInfo *pp)
 {
+	if (pp->pp_ref != 0 || pp->pp_link != NULL) 
+        {
+          panic("page_free: not an allocated page\n");
+        }
+        pp->pp_link = page_free_list;
+	page_free_list = pp;
 	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
 	// pp->pp_link is not NULL.
@@ -373,8 +448,39 @@ page_decref(struct PageInfo* pp)
 pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
+
 	// Fill this function in
-	return NULL;
+	pde_t *pde;                                                      // page directory entry virtual
+    	pte_t *pt;                                                       // page table address virtual
+
+    	pde= pgdir + PDX(va);                                      // finding the address of the directory entry by adding directory bits to page directory root pointer
+    
+	if ((*pde) & PTE_P)                                              // checking if page directry entry is present and finding the virtual address of pde
+		pt = KADDR(PTE_ADDR(*pde));		                 //the address stored in pgdir is physical address but we need is virtual address
+         
+   	else
+	{
+          if (create) 
+	  { 				                                 // if page table does not exist, create and insert to page directory
+            	struct PageInfo *pp = page_alloc(ALLOC_ZERO);
+            		
+		if (pp == NULL) 
+		   return NULL;
+            			
+		pt = page2kva(pp); 		                        // pt equals the new page table physical address
+            						                // PTEs inside pt are not initialized yet
+            	pp->pp_ref++;
+            	*pde = PADDR(pt) | PTE_P | PTE_W | PTE_U;
+        	}   
+        	else 
+            	  return NULL;
+    	}
+    
+	return pt + PTX(va);                                              //returns a pointer to the page table entry (PTE) for linear address va
+			                                                  //calculates the page table index        
+
+	// Fill this function in
+	//return NULL
 }
 
 //
@@ -391,6 +497,12 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
+	size_t i;                                                             //initialize the variable i with type size_t
+        for (i = 0; i < size; i+= PGSIZE) {                                   //size is the multiple of PGSIZE
+	pte_t *pte = pgdir_walk(pgdir, (const void *) (va + i), 1); //finding the page table entry through page walk function; (va +i) - to make va as page alligned
+	*pte = PTE_ADDR(pa + i) | perm | PTE_P;               /*inserts the physical address of the page table entry with permission flags to the page table;(pa + i)  
+                                                                                  - pa as page alligned, with permission bits*/
+	}
 	// Fill this function in
 }
 
@@ -422,8 +534,23 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
-	// Fill this function in
+	pte_t *pte = pgdir_walk(pgdir, va, 1);    //requirement 2 - page is allocated and inserted into pgdir
+
+        if (!pte & PTE_P) {                       //page table couldn't be allocated
+             return -E_NO_MEM;                        
+        }
+        pp->pp_ref++;                             //requirement 3 - page insertion succeed
+
+        if (*pte & PTE_P) {                       //requirement 1 - page is already mapped to va
+             page_remove(pgdir, va);
+        }
+
+       *pte = page2pa(pp) | perm | PTE_P;         
+        //pgdir[PDX(va)] |= perm;
 	return 0;
+	
+	
+	
 }
 
 //
@@ -440,11 +567,34 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
-	// Fill this function in
+	
+	pte_t *pte = pgdir_walk(pgdir, va, 0);;
+
+	if (!pte || !(*pte & PTE_P))
 	return NULL;
-}
+	if (pte_store)
+	*pte_store = pte;
+
+	return pa2page(PTE_ADDR(*pte));
+	}
+	
+	
+	/*pte_t *pte = pgdir_walk(pgdir, va, 0);             //page is not created
+
+        if (!pte) {                                        //page is not mapped to va
+              return NULL;
+        }
+        if (pte_store != 0) {                              
+             *pte_store = pte;                             //address of pte of the page is stored
+        }
+	return pa2page(PTE_ADDR(*pte)); //page mapped at virtual address va is returned
+	//return NULL;*/
+	
+	
+	
+
+
 
-//
 // Unmaps the physical page at virtual address 'va'.
 // If there is no physical page at that address, silently does nothing.
 //
@@ -462,6 +612,17 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 void
 page_remove(pde_t *pgdir, void *va)
 {
+	pte_t *pte;
+	struct PageInfo *pp = page_lookup(pgdir, va, &pte);
+	if (!pp) {       			            //page doesnt exist
+	   return;   		                            // do nothing
+	}
+	else
+	{
+	   page_decref(pp);  	                            //decrement reference count and free page table if ref count==0
+	   tlb_invalidate(pgdir, va);                       //invalidate TLB if entry removed from page table
+	   *pte = 0; 		                            // making PTE corresponding to that va as zero
+	} 
 	// Fill this function in
 }
 
@@ -509,7 +670,16 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// Hint: The staff solution uses boot_map_region.
 	//
 	// Your code here:
-	panic("mmio_map_region not implemented");
+	
+	size = ROUNDUP(size, PGSIZE);
+	if (base + size > MMIOLIM) {
+		panic("mmio_map_region failed: overflow");
+	}
+	// note that `base` is already PGSIZE aligned
+	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
+	base += size;
+	return (void *) (base - size);
+	//panic("mmio_map_region not implemented");
 }
 
 static uintptr_t user_mem_check_addr;
@@ -536,8 +706,27 @@ int
 user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 {
 	// LAB 3: Your code here.
+		uintptr_t start = (uintptr_t )ROUNDDOWN ((uint32_t)va, PGSIZE);
+        uintptr_t end = (uintptr_t) va + len;
 
+        for (start; start<end; start+=PGSIZE)
+        {
+         pde_t *pte = pgdir_walk(env->env_pgdir, (void *)start, 0);
+         if (!pte || start>=ULIM || ((uint32_t)*pte & perm) != perm)
+         {
+
+         if (start == (uintptr_t) ROUNDDOWN ((uint32_t)va, PGSIZE))
+         user_mem_check_addr = (uintptr_t) va;
+         else
+         user_mem_check_addr = (uintptr_t) start;
+
+         return -E_FAULT; 
+
+        }
+
+}
 	return 0;
+	
 }
 
 //
diff --git a/kern/sched.c b/kern/sched.c
index f595bb1..ef432fa 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -29,6 +29,21 @@ sched_yield(void)
 	// below to halt the cpu.
 
 	// LAB 4: Your code here.
+	int i, envid;
+	int curenv_id = curenv ? ENVX(curenv->env_id) : 0;
+	
+	
+	for (i = 0; i < NENV; i++) {
+		envid = ENVX(curenv_id + i);
+		if (envs[envid].env_status == ENV_RUNNABLE) {
+			env_run(&envs[envid]);
+		}
+	}
+	
+	if (curenv && curenv->env_status == ENV_RUNNING) {
+		env_run(curenv);
+	}
+	
 
 	// sched_halt never returns
 	sched_halt();
@@ -75,7 +90,7 @@ sched_halt(void)
 		"pushl $0\n"
 		"pushl $0\n"
 		// Uncomment the following line after completing exercise 13
-		//"sti\n"
+		"sti\n"
 		"1:\n"
 		"hlt\n"
 		"jmp 1b\n"
diff --git a/kern/syscall.c b/kern/syscall.c
index be759b0..7ebe62d 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -12,6 +12,7 @@
 #include <kern/console.h>
 #include <kern/sched.h>
 #include <kern/time.h>
+#include <kern/e1000.h>
 
 // Print a string to the system console.
 // The string is exactly 'len' characters long.
@@ -21,9 +22,9 @@ sys_cputs(const char *s, size_t len)
 {
 	// Check that the user has permission to read memory [s, s+len).
 	// Destroy the environment if not.
-
+	user_mem_assert(curenv, (void *)s, len, PTE_U);
 	// LAB 3: Your code here.
-
+	
 	// Print the string supplied by the user.
 	cprintf("%.*s", len, s);
 }
@@ -74,6 +75,7 @@ sys_yield(void)
 static envid_t
 sys_exofork(void)
 {
+		
 	// Create the new environment with env_alloc(), from kern/env.c.
 	// It should be left as env_alloc created it, except that
 	// status is set to ENV_NOT_RUNNABLE, and the register set is copied
@@ -81,7 +83,18 @@ sys_exofork(void)
 	// will appear to return 0.
 
 	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+	struct Env *env;
+    int result = env_alloc(&env, curenv->env_id);
+    if (result < 0) {
+        return -E_NO_FREE_ENV;
+    }
+
+    env->env_status = ENV_NOT_RUNNABLE;
+    env->env_tf = curenv->env_tf;
+    env->env_tf.tf_regs.reg_eax = 0;
+
+    return env->env_id;
+	//panic("sys_exofork not implemented");
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -94,6 +107,7 @@ sys_exofork(void)
 static int
 sys_env_set_status(envid_t envid, int status)
 {
+	
 	// Hint: Use the 'envid2env' function from kern/env.c to translate an
 	// envid to a struct Env.
 	// You should set envid2env's third argument to 1, which will
@@ -101,7 +115,19 @@ sys_env_set_status(envid_t envid, int status)
 	// envid's status.
 
 	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
+	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) {
+        return -E_INVAL;
+    }
+//If checkperm is set, the specified environment must be either the
+// current environment or an immediate child of the current environment.
+    struct Env *env;
+    if (envid2env(envid, &env, 1)!=0) {
+        return -E_BAD_ENV;
+    }
+    env->env_status = status;
+
+    return 0;
+	//panic("sys_env_set_status not implemented");
 }
 
 // Set envid's trap frame to 'tf'.
@@ -115,10 +141,51 @@ static int
 sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 {
 	// LAB 5: Your code here.
-	// Remember to check whether the user has supplied us with a good
-	// address!
-	panic("sys_env_set_trapframe not implemented");
+	
+	  int ret=0;  
+    struct Env *e; 
+	if ((ret = envid2env(envid, &e, 1))<0)
+	return -E_BAD_ENV;
+	
+	e->env_tf = *tf;
+	user_mem_assert(e, tf, sizeof(struct Trapframe), PTE_U);
+	tf->tf_cs = GD_UT | 0x3; //user text//
+    tf->tf_eflags |= FL_IF;
+     tf->tf_eflags |=FL_IOPL_0; //I/O Privilege level 0
+	return 0;
+	//panic("sys_env_set_trapframe not implemented");
 }
+	
+	/*struct Env *e;
+	int r;
+
+	if ((r = envid2env(envid, &e, 1)) < 0)
+		return r;
+
+	if ((r = user_mem_check(curenv, tf, sizeof(struct Trapframe), PTE_U|PTE_P)) < 0)
+		return r;
+
+	memmove(&(e->env_tf), tf, sizeof(struct Trapframe));
+
+	return 0;*/
+	 /*int envStatus=0;
+	struct Env *e=NULL;
+	
+	envStatus = envid2env(envid, &e, 1);
+	if(envStatus < 0)
+	return envStatus;
+	
+	if(tf->tf_eip >= UTOP)
+	return -E_INVAL;
+	
+	e->env_tf = *tf;
+	e->env_tf.tf_eflags |= FL_IF;
+	
+	return 0;
+   }*/
+  
+ 
+
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
 // Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the
@@ -131,8 +198,17 @@ sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 static int
 sys_env_set_pgfault_upcall(envid_t envid, void *func)
 {
+	struct Env *env;
+	if (envid2env(envid, &env, 1) != 0) {
+		return -E_BAD_ENV;
+	}
+
+	env->env_pgfault_upcall = func; //page fault upcall entry point//
+
+	return 0;
+
 	// LAB 4: Your code here.
-	panic("sys_env_set_pgfault_upcall not implemented");
+	//panic("sys_env_set_pgfault_upcall not implemented");
 }
 
 // Allocate a page of memory and map it at 'va' with permission
@@ -160,9 +236,38 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 	//   parameters for correctness.
 	//   If page_insert() fails, remember to free the page you
 	//   allocated!
+	struct Env *env;
+    if (envid2env(envid, &env, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+    struct PageInfo *pi = page_alloc(ALLOC_ZERO);
+    if (pi == NULL) {
+        return -E_NO_MEM;
+    }
+    //pi->pp_ref++;
+    //page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)-> physical page pp to virtual address va
+    if (page_insert(env->env_pgdir, pi, va, perm) != 0) {
+        page_free(pi);
+        return -E_NO_MEM;
+    }
+    if ((uint32_t)va >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(va, PGSIZE) != va) {
+        return -E_INVAL;
+    }
+
+    if (!((perm & PTE_U) && (perm & PTE_P)) || (perm & (~PTE_SYSCALL))) {
+        return -E_INVAL;
+    }
+
+    
 
+    
+    return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+	//panic("sys_page_alloc not implemented");
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -191,9 +296,59 @@ sys_page_map(envid_t srcenvid, void *srcva,
 	//   parameters for correctness.
 	//   Use the third argument to page_lookup() to
 	//   check the current permissions on the page.
+	struct Env *srcenv;
+    if (envid2env(srcenvid, &srcenv, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+
+    struct Env *dstenv;
+    if (envid2env(dstenvid, &dstenv, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+
+    if ((uint32_t)srcva >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(srcva, PGSIZE) != srcva) {
+        return -E_INVAL;
+    }
+
+    if ((uint32_t)dstva >= UTOP) {
+        return -E_INVAL;
+    }
+
+    if (ROUNDUP(dstva, PGSIZE) != dstva) {
+        return -E_INVAL;
+    }
+
+    if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) || (perm & (~PTE_SYSCALL))) {
+        return -E_INVAL;
+    }
+
+    pte_t *srcpte;
+    //Return the page mapped at virtual address 'va'.
+    //page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+    struct PageInfo *srcpi = page_lookup(srcenv->env_pgdir, srcva, &srcpte);
+    if (srcpi == NULL) {
+        return -E_INVAL;
+    }
+
+    if (((*srcpte) & PTE_W) == 0 && ((perm & PTE_W) == PTE_W)) {
+        return -E_INVAL;
+        
+    }
+    
+    if (((perm & (PTE_P | PTE_U)) != (PTE_P | PTE_U)) || (perm & ~(PTE_SYSCALL)) || ((perm & PTE_W) & (*srcpte)) != (perm & PTE_W))
+       return -E_INVAL;  
 
+    int result = page_insert(dstenv->env_pgdir, srcpi, dstva, perm);
+    if (result != 0) {
+        return result;
+    }
+	return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+	//panic("sys_page_map not implemented");
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -207,9 +362,26 @@ static int
 sys_page_unmap(envid_t envid, void *va)
 {
 	// Hint: This function is a wrapper around page_remove().
+	struct Env *env;
+    if (envid2env(envid, &env, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+
+    if ((uint32_t)va >= UTOP) {
+        return -E_INVAL;
+    }
 
+    if (ROUNDUP(va, PGSIZE) != va) {
+        return -E_INVAL;
+    }
+   //Unmaps the physical page at virtual address 'va'.
+   //page_remove(pde_t *pgdir, void *va)
+    page_remove(env->env_pgdir, va);
+    
+
+    return 0;
 	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+	//panic("sys_page_unmap not implemented");
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -254,7 +426,71 @@ static int
 sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_try_send not implemented");
+		/*struct Env *e;
+    if (envid2env(envid, &e, 1) != 0) {
+        return -E_BAD_ENV;
+    }
+    if (!e->env_ipc_recving)
+        return -E_IPC_NOT_RECV;
+        
+    if (((uint32_t)srcva < UTOP))
+    {
+
+      if ((uint32_t)srcva != ROUNDDOWN(srcva, PGSIZE))  
+      return -E_INVAL;
+      
+       if (((perm & (PTE_P | PTE_U)) != ((PTE_P | PTE_U)) || (perm & ~(PTE_SYSCALL))))
+        return -E_INVAL; */
+
+	//panic("sys_ipc_try_send not implemented");
+	
+	struct Env *e;
+        struct PageInfo *pp;
+        pte_t *pte;
+
+        if (envid2env(envid, &e, 0))
+        return -E_BAD_ENV;
+
+        if (!e->env_ipc_recving)
+        return -E_IPC_NOT_RECV;
+
+      if (((uint32_t)srcva < UTOP))
+      {
+
+        if ((uint32_t)srcva % PGSIZE != 0)
+        return -E_INVAL;
+
+        if (((perm & (PTE_P | PTE_U)) != ((PTE_P | PTE_U)) || (perm & ~(PTE_SYSCALL))))
+        return -E_INVAL;
+
+        if (!(pp = page_lookup(curenv->env_pgdir, srcva, &pte)))
+        return -E_INVAL;
+
+        if ((perm & PTE_W) && !(*pte & PTE_W))
+        return -E_INVAL;
+
+        if ((uint32_t)e->env_ipc_dstva < UTOP)
+        {
+
+        if (page_insert(e->env_pgdir, pp, e->env_ipc_dstva, perm))
+        return -E_NO_MEM;
+        e->env_ipc_perm = perm;
+        }
+
+     }
+
+     e->env_ipc_recving = 0;
+     e->env_ipc_from = curenv->env_id;
+     e->env_ipc_value = value;
+     e->env_status = ENV_RUNNABLE;
+
+     e->env_tf.tf_regs.reg_eax = 0;
+
+     return 0;
+	
+	
+	
+	
 }
 
 // Block until a value is ready.  Record that you want to receive
@@ -271,9 +507,19 @@ sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 static int
 sys_ipc_recv(void *dstva)
 {
+	
+	if ((uint32_t)dstva < UTOP && (uint32_t)dstva % PGSIZE != 0)
+       return -E_INVAL;
+       curenv->env_ipc_recving = 1;
+       curenv->env_ipc_dstva = dstva;
+       curenv->env_status = ENV_NOT_RUNNABLE;
+
+       sched_yield();
+
+       return 0; 
 	// LAB 4: Your code here.
-	panic("sys_ipc_recv not implemented");
-	return 0;
+	//panic("sys_ipc_recv not implemented");
+	
 }
 
 // Return the current time.
@@ -281,9 +527,26 @@ static int
 sys_time_msec(void)
 {
 	// LAB 6: Your code here.
+  return time_msec();
 	panic("sys_time_msec not implemented");
 }
 
+// Transmit a network packet
+static int
+sys_net_tx(uint8_t * addr, size_t length)
+{
+ user_mem_assert(curenv, addr, length, PTE_U);
+ return e1000_tx(addr, length);
+}
+
+// Receive a network packet
+static int
+sys_net_recv(uint8_t * addr)
+{
+ user_mem_assert(curenv, addr, DATA_SIZE, PTE_U);
+ return e1000_recv(addr);
+}
+
 // Dispatches to the correct kernel function, passing the arguments.
 int32_t
 syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
@@ -291,12 +554,53 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 	// Call the function corresponding to the 'syscallno' parameter.
 	// Return any appropriate return value.
 	// LAB 3: Your code here.
+switch (syscallno)
+ 	{
+ 	   case SYS_cputs:
+      	     sys_cputs((char *) a1, (size_t) a2);
+             return 0;
+ 	   case SYS_cgetc:
+	     return sys_cgetc(); 
+	   case SYS_getenvid: 
+	     return sys_getenvid(); 
+	   case SYS_env_destroy: 
+	     return sys_env_destroy((envid_t) a1); 
+	     case SYS_yield:
+	     sys_yield();
+	      return 0;
+	      case SYS_exofork:
+         return sys_exofork();
+        case SYS_env_set_status:
+         return sys_env_set_status(a1, (int)a2);
+        case SYS_page_alloc:
+         return sys_page_alloc(a1, (void*)a2, (int) a3);
+          case SYS_page_map:
+          return sys_page_map(a1, (void*)a2,(envid_t)a3, (void*)a4, (int)a5);
+         case SYS_page_unmap:
+       return sys_page_unmap(a1, (void*)a2);
+       case SYS_env_set_pgfault_upcall:
+         return sys_env_set_pgfault_upcall(a1,(void *)a2);
+         case SYS_ipc_try_send:
+         return sys_ipc_try_send(a1, a2, (void *) a3, a4);
 
-	panic("syscall not implemented");
+         case SYS_ipc_recv:
+         return sys_ipc_recv((void *) a1);
+         case SYS_time_msec:
+          return (int32_t)sys_time_msec();
+         
+          case SYS_env_set_trapframe:
+			return (int32_t)sys_env_set_trapframe(a1, (void*) a2);
+         case SYS_net_tx:
+   return (int32_t)sys_net_tx((uint8_t *)a1, (size_t)a2);
+         case SYS_net_recv:
+   return (int32_t)sys_net_recv((uint8_t *)a1);
+ 	   default:
+             return -E_INVAL;     
+	} 
+	/*panic("syscall not implemented");
 
 	switch (syscallno) {
 	default:
 		return -E_INVAL;
-	}
+	}*/
 }
-
diff --git a/kern/syscall.h b/kern/syscall.h
index e370801..d8465dc 100644
--- a/kern/syscall.h
+++ b/kern/syscall.h
@@ -6,6 +6,7 @@
 
 #include <inc/syscall.h>
 
+
 int32_t syscall(uint32_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5);
 
 #endif /* !JOS_KERN_SYSCALL_H */
diff --git a/kern/trap.c b/kern/trap.c
index 1a23d4b..542add2 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -71,6 +71,85 @@ void
 trap_init(void)
 {
 	extern struct Segdesc gdt[];
+	void trap_divide();
+	void trap_debug();
+	void trap_nmi();
+	void trap_brkpt();
+	void trap_oflow();
+	void trap_bound();
+	void trap_illop();
+	void trap_device();
+	void trap_dblflt();
+	void trap_tss();
+	void trap_segnp();
+	void trap_stack();
+	void trap_gpflt();
+	void trap_pgflt();
+	void trap_fperr();
+	void trap_align();
+	void trap_mchk();
+	void trap_simderr();
+	void trap_syscall();
+	
+	
+	
+	void irq0();
+	void irq1();
+	void irq2();
+	void irq3();
+	void irq4();
+	void irq5();
+	void irq6();
+	void irq7();
+	void irq8();
+	void irq9();
+	void irq10();
+	void irq11();
+	void irq12();
+	void irq13();
+	void irq14();
+	void irq15();
+		
+	
+	// SETGATE(gate, istrap, sel, off, dpl)
+	SETGATE(idt[T_DIVIDE], 0, GD_KT, trap_divide, 0);
+	SETGATE(idt[T_DEBUG] , 0, GD_KT, trap_debug , 0);
+	SETGATE(idt[T_NMI],    0, GD_KT, trap_nmi, 0);
+	SETGATE(idt[T_BRKPT],  0, GD_KT, trap_brkpt, 3);
+	SETGATE(idt[T_OFLOW] , 0, GD_KT, trap_oflow , 0);
+	SETGATE(idt[T_BOUND] , 0, GD_KT, trap_bound , 0);
+	SETGATE(idt[T_ILLOP] , 0, GD_KT, trap_illop , 0);
+	SETGATE(idt[T_DEVICE], 0, GD_KT, trap_device, 0);
+	SETGATE(idt[T_DBLFLT], 0, GD_KT, trap_dblflt, 0);
+	SETGATE(idt[T_TSS]   , 0, GD_KT, trap_tss,    0);
+	SETGATE(idt[T_SEGNP] , 0, GD_KT, trap_segnp,  0);
+	SETGATE(idt[T_STACK] , 0, GD_KT, trap_stack,  0);
+	SETGATE(idt[T_GPFLT] , 0, GD_KT, trap_gpflt,  0);
+	SETGATE(idt[T_PGFLT] , 0, GD_KT, trap_pgflt,  0);
+	SETGATE(idt[T_FPERR] , 0, GD_KT, trap_fperr,  0);
+	SETGATE(idt[T_ALIGN] , 0, GD_KT, trap_align,  0);
+	SETGATE(idt[T_MCHK]  , 0, GD_KT, trap_mchk ,  0);
+	SETGATE(idt[T_SIMDERR],0, GD_KT, trap_simderr, 0);
+	SETGATE(idt[T_SYSCALL],0, GD_KT, trap_syscall, 3);
+	
+	
+	
+  SETGATE(idt[IRQ_OFFSET+0], 0, GD_KT, irq0, 0); 
+  SETGATE(idt[IRQ_OFFSET+1], 0, GD_KT, irq1, 0); 
+  SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, irq2, 0); 
+  SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, irq3, 0); 
+  SETGATE(idt[IRQ_OFFSET+4], 0, GD_KT, irq4, 0); 
+  SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, irq5, 0); 
+  SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, irq6, 0); 
+  SETGATE(idt[IRQ_OFFSET+7], 0, GD_KT, irq7, 0); 
+  SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, irq8, 0); 
+  SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, irq9, 0); 
+  SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, irq10, 0); 
+  SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, irq11, 0); 
+  SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, irq12, 0); 
+  SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, irq13, 0); 
+  SETGATE(idt[IRQ_OFFSET+14], 0, GD_KT, irq14, 0); 
+  SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, irq15, 0);
 
 	// LAB 3: Your code here.
 
@@ -109,18 +188,19 @@ trap_init_percpu(void)
 
 	// Setup a TSS so that we get the right stack
 	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
+	int i = thiscpu->cpu_id;
+	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP); //percpu_kstacks[thiscpu->cpu_id];
+	thiscpu->cpu_ts.ts_ss0 = GD_KD;
+	 thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);
 
 	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
-					sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
+	gdt[(GD_TSS0 >> 3)+i] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),
+					sizeof(struct Taskstate) - 1, 0); //Available 32-bit TSS
+	gdt[(GD_TSS0 >> 3)+i].sd_s = 0; 
 
 	// Load the TSS selector (like other segment selectors, the
 	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
+	ltr(GD_TSS0+sizeof(struct Segdesc)*i);
 
 	// Load the IDT
 	lidt(&idt_pd);
@@ -177,6 +257,27 @@ trap_dispatch(struct Trapframe *tf)
 {
 	// Handle processor exceptions.
 	// LAB 3: Your code here.
+	if (tf->tf_trapno == T_PGFLT) 
+        {
+	   page_fault_handler(tf);
+	   return;
+	}
+	
+	if(tf->tf_trapno == T_BRKPT)
+        {
+           monitor(tf);
+           return;
+        }
+
+	if (tf->tf_trapno == T_SYSCALL)
+        {
+        if((tf->tf_regs.reg_eax = syscall (tf->tf_regs.reg_eax, tf->tf_regs.reg_edx,
+                          tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx,
+                          tf->tf_regs.reg_edi, tf->tf_regs.reg_esi)) < 0)
+ 
+        panic ("Invalid system call!");
+ 	return;
+}
 
 	// Handle spurious interrupts
 	// The hardware sometimes raises these because of noise on the
@@ -190,15 +291,42 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle clock interrupts. Don't forget to acknowledge the
 	// interrupt using lapic_eoi() before calling the scheduler!
 	// LAB 4: Your code here.
-
+	
+	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER){
+	//	lapic_eoi();
+	//	sched_yield();
+	//	return;
+	
 	// Add time tick increment to clock interrupts.
 	// Be careful! In multiprocessors, clock interrupts are
 	// triggered on every CPU.
 	// LAB 6: Your code here.
-
+  
+        
+        lapic_eoi();
+         if(cpunum()==0)
+         {
+          time_tick();
+         }
+        sched_yield();
+        return;
+        }
 
 	// Handle keyboard and serial interrupts.
 	// LAB 5: Your code here.
+	 if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD)
+        {
+         kbd_intr();
+         return;
+        }
+ 
+        if (tf->tf_trapno == IRQ_OFFSET+IRQ_SERIAL)
+        {
+         serial_intr();
+         return;
+        }
+
+
 
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
@@ -236,6 +364,7 @@ trap(struct Trapframe *tf)
 		// Acquire the big kernel lock before doing any
 		// serious kernel work.
 		// LAB 4: Your code here.
+			lock_kernel();
 		assert(curenv);
 
 		// Garbage collect if current enviroment is a zombie
@@ -281,7 +410,8 @@ page_fault_handler(struct Trapframe *tf)
 	// Handle kernel-mode page faults.
 
 	// LAB 3: Your code here.
-
+	if ((tf->tf_cs & 3) == 0)
+		panic("page fault in kernel mode.");
 	// We've already handled kernel-mode exceptions, so if we get here,
 	// the page fault happened in user mode.
 
@@ -313,13 +443,77 @@ page_fault_handler(struct Trapframe *tf)
 	//   user_mem_assert() and env_run() are useful here.
 	//   To change what the user environment runs, modify 'curenv->env_tf'
 	//   (the 'tf' variable points at 'curenv->env_tf').
-
-	// LAB 4: Your code here.
-
-	// Destroy the environment that caused the fault.
+	/*if (curenv->env_pgfault_upcall == NULL)
+	{
 	cprintf("[%08x] user fault va %08x ip %08x\n",
 		curenv->env_id, fault_va, tf->tf_eip);
 	print_trapframe(tf);
 	env_destroy(curenv);
 }
 
+// Destroy the environment that caused the fault.
+	else {
+		uintptr_t stacktop;
+		if (tf->tf_esp < UXSTACKTOP)
+			stacktop = tf->tf_esp - sizeof(struct UTrapframe)-4;
+		else
+			stacktop = UXSTACKTOP- sizeof(struct UTrapframe);
+
+		struct UTrapframe *utf = (struct UTrapframe *)stacktop;
+
+		user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
+
+		utf->utf_fault_va = fault_va;
+		utf->utf_err = tf->tf_err;
+		utf->utf_regs = tf->tf_regs;
+		utf->utf_eip = tf->tf_eip;
+		utf->utf_eflags = tf->tf_eflags;
+		utf->utf_esp = tf->tf_esp;
+		curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
+		curenv->env_tf.tf_esp = stacktop;
+
+		env_run(curenv);
+	}
+
+	// LAB 4: Your code here.
+
+	
+	
+}*/
+
+
+
+
+if (curenv->env_pgfault_upcall == NULL || tf->tf_esp > UXSTACKTOP || (tf->tf_esp > USTACKTOP && tf->tf_esp < (UXSTACKTOP - PGSIZE)))
+        {
+         cprintf("[%08x] user fault va %08x ip %08x\n",
+         curenv->env_id, fault_va, tf->tf_eip);
+         print_trapframe(tf);
+         env_destroy(curenv);
+        }
+        uint32_t xstack_top;
+        if (tf->tf_esp < USTACKTOP) 
+        {
+        xstack_top = UXSTACKTOP - sizeof(struct UTrapframe);
+        } 
+        else 
+        {
+        xstack_top = tf->tf_esp - sizeof(struct UTrapframe) - 4;
+        }
+  
+        user_mem_assert(curenv, (void *) xstack_top, 1, PTE_W | PTE_U);
+     
+        struct UTrapframe *u_tf = (struct UTrapframe *) xstack_top;
+        u_tf->utf_fault_va = fault_va;
+        u_tf->utf_err = tf->tf_err;
+        u_tf->utf_regs = tf->tf_regs;
+        u_tf->utf_eip = tf->tf_eip;
+        u_tf->utf_eflags = tf->tf_eflags;
+        u_tf->utf_esp = tf->tf_esp; 
+ 
+        tf->tf_esp = (uintptr_t) xstack_top;
+        tf->tf_eip = (uintptr_t) curenv->env_pgfault_upcall;
+        env_run(curenv);        
+}
+
+
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 2dbeeca..3cc24f4 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -48,9 +48,61 @@
  * Lab 3: Your code here for generating entry points for the different traps.
  */
 
+TRAPHANDLER_NOEC(trap_divide, T_DIVIDE)
+	TRAPHANDLER_NOEC(trap_debug, T_DEBUG)
+	TRAPHANDLER_NOEC(trap_nmi, T_NMI)
+	TRAPHANDLER_NOEC(trap_brkpt, T_BRKPT)
+	TRAPHANDLER_NOEC(trap_oflow, T_OFLOW)
+	TRAPHANDLER_NOEC(trap_bound, T_BOUND)
+	TRAPHANDLER_NOEC(trap_illop, T_ILLOP)
+	TRAPHANDLER_NOEC(trap_device, T_DEVICE)
+	TRAPHANDLER(trap_dblflt, T_DBLFLT)
+	TRAPHANDLER(trap_tss, T_TSS)
+	TRAPHANDLER(trap_segnp, T_SEGNP)
+	TRAPHANDLER(trap_stack, T_STACK)
+	TRAPHANDLER(trap_gpflt, T_GPFLT)
+	TRAPHANDLER(trap_pgflt, T_PGFLT)
+	TRAPHANDLER_NOEC(trap_fperr, T_FPERR)
+	TRAPHANDLER(trap_align, T_ALIGN)
+	TRAPHANDLER_NOEC(trap_mchk, T_MCHK)
+	TRAPHANDLER_NOEC(trap_simderr, T_SIMDERR)
+	TRAPHANDLER_NOEC(trap_syscall, T_SYSCALL)
+
+
+
+  TRAPHANDLER_NOEC(irq0, IRQ_OFFSET+0 ); 
+  TRAPHANDLER_NOEC(irq1, IRQ_OFFSET+1 ); 
+  TRAPHANDLER_NOEC(irq2, IRQ_OFFSET+2 ); 
+  TRAPHANDLER_NOEC(irq3, IRQ_OFFSET+3 ); 
+  TRAPHANDLER_NOEC(irq4, IRQ_OFFSET+4 ); 
+  TRAPHANDLER_NOEC(irq5, IRQ_OFFSET+5 ); 
+  TRAPHANDLER_NOEC(irq6, IRQ_OFFSET+6 ); 
+  TRAPHANDLER_NOEC(irq7, IRQ_OFFSET+7 ); 
+  TRAPHANDLER_NOEC(irq8, IRQ_OFFSET+8 ); 
+  TRAPHANDLER_NOEC(irq9, IRQ_OFFSET+9 ); 
+  TRAPHANDLER_NOEC(irq10, IRQ_OFFSET+10 ); 
+  TRAPHANDLER_NOEC(irq11, IRQ_OFFSET+11 ); 
+  TRAPHANDLER_NOEC(irq12, IRQ_OFFSET+12 ); 
+  TRAPHANDLER_NOEC(irq13, IRQ_OFFSET+13 ); 
+  TRAPHANDLER_NOEC(irq14, IRQ_OFFSET+14 ); 
+  TRAPHANDLER_NOEC(irq15, IRQ_OFFSET+15 ); 
 
 
 /*
  * Lab 3: Your code here for _alltraps
  */
 
+_alltraps:
+	pushl %ds
+	pushl %es
+	pushal
+	pushl $GD_KD
+	popl %ds
+	pushl $GD_KD
+	popl %es
+	pushl %esp
+	call trap
+
+
+
+
diff --git a/lib/fd.c b/lib/fd.c
index 77177d6..b7c79d9 100644
--- a/lib/fd.c
+++ b/lib/fd.c
@@ -211,12 +211,12 @@ read(int fdnum, void *buf, size_t n)
 	if ((r = fd_lookup(fdnum, &fd)) < 0
 	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
 		return r;
-	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
+	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) { //O_ACCMODE=mask for open write only
 		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
 		return -E_INVAL;
 	}
 	if (!dev->dev_read)
-		return -E_NOT_SUPP;
+		return -E_NOT_SUPP; //OPERATION NOT SUPPORTED//
 	return (*dev->dev_read)(fd, buf, n);
 }
 
diff --git a/lib/file.c b/lib/file.c
index 39025b2..6091a9c 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -24,8 +24,8 @@ fsipc(unsigned type, void *dstva)
 	if (debug)
 		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);
 
-	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
-	return ipc_recv(NULL, dstva, NULL);
+	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);  //fsipcbuf=pg, type=val
+	return ipc_recv(NULL, dstva, NULL);                //dstva=pg
 }
 
 static int devfile_flush(struct Fd *fd);
@@ -141,7 +141,21 @@ devfile_write(struct Fd *fd, const void *buf, size_t n)
 	// remember that write is always allowed to write *fewer*
 	// bytes than requested.
 	// LAB 5: Your code here
-	panic("devfile_write not implemented");
+     uint32_t max_write = PGSIZE - (sizeof(int) + sizeof(size_t));
+    // Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.
+	if (n > max_write)
+	n = max_write;
+	
+	fsipcbuf.write.req_fileid = fd->fd_file.id;
+	fsipcbuf.write.req_n = n;
+	
+	memmove(fsipcbuf.write.req_buf, buf, n);
+	// Make an FSREQ_WRITE request to the file system server
+    // The number of bytes successfully written.
+	return (fsipc(FSREQ_WRITE, NULL));
+    
+	    //panic("devfile_write not implemented");*/
+	
 }
 
 static int
diff --git a/lib/fork.c b/lib/fork.c
index 61264da..4468ba2 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -7,6 +7,8 @@
 // It is one of the bits explicitly allocated to user processes (PTE_AVAIL).
 #define PTE_COW		0x800
 
+extern void _pgfault_upcall(void);
+
 //
 // Custom page fault handler - if faulting page is copy-on-write,
 // map in our own private writable copy.
@@ -24,7 +26,15 @@ pgfault(struct UTrapframe *utf)
 	//   Use the read-only page table mappings at uvpt
 	//   (see <inc/memlayout.h>).
 
-	// LAB 4: Your code here.
+	// LAB 4: Your code here
+        //check if the page fault is a write.
+        if ((err & FEC_WR) == 0)
+        panic("pgfault: faulting address [%08x] is not a write\n", addr);
+
+        void *page_aligned_addr = (void *) ROUNDDOWN(addr, PGSIZE);
+        uint32_t pgno = (uint32_t) page_aligned_addr / PGSIZE;
+        if (!(uvpt[pgno] & PTE_COW))
+        panic("pgfault: fault was not on a copy-on-write page\n");
 
 	// Allocate a new page, map it at a temporary location (PFTEMP),
 	// copy the data from the old page to the new page, then move the new
@@ -32,9 +42,20 @@ pgfault(struct UTrapframe *utf)
 	// Hint:
 	//   You should make three system calls.
 
-	// LAB 4: Your code here.
+	// LAB 4: Your code here.i
+        if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
+        panic("pgfault: sys_page_alloc: %e\n", r);
+       
+        void *src_addr = (void *) ROUNDDOWN(addr, PGSIZE);
+        memmove(PFTEMP, src_addr, PGSIZE);
 
-	panic("pgfault not implemented");
+       if ((r = sys_page_map(0, PFTEMP, 0, src_addr, PTE_P | PTE_U | PTE_W)) < 0)
+       panic("pgfault: sys_page_map: %e\n", r);
+      
+       if((sys_page_unmap(0, PFTEMP))<0)
+       panic("pgfault/fork: couldn't unmap the page at PFTEMP");
+ 
+	//panic("pgfault not implemented");
 }
 
 //
@@ -48,15 +69,71 @@ pgfault(struct UTrapframe *utf)
 // Returns: 0 on success, < 0 on error.
 // It is also OK to panic on error.
 //
+/*For each writable or copy-on-write page in its address space below UTOP, the parent calls duppage, which should map the page copy-on-write into the address space of the child and then remap the page copy-on-write in its own address space. duppage sets both PTEs so that the page is not writeable, and to contain PTE_COW in the "avail" field to distinguish copy-on-write pages from genuine read-only pages.*/
 static int
 duppage(envid_t envid, unsigned pn)
 {
-	int r;
+     int r;
+     uint32_t perm = PTE_P | PTE_COW | PTE_U;
+     void * addr = (void *)(pn*PGSIZE);
+     
+     if (uvpt[pn] & PTE_SHARE) {  //0X400
+		sys_page_map(thisenv->env_id, addr, envid, addr, uvpt[pn]&PTE_SYSCALL);
+}
+     // LAB 4: Your code here.
+    //If the page passed is marked copy-on-write or writable 
+   else if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W)  //0X800
+     {
+     //then map the page at addr in parent to child at addr in its address space with perm COW
+     if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, perm)) < 0)
+     panic("duppage: sys_page_map: %e\n", r);
+
+     // remap the page at addr in parent with perm that contains COW
+     if ((r = sys_page_map(thisenv->env_id, addr, thisenv->env_id, addr, perm)) < 0)
+     panic("duppage: sys_page_map: %e\n", r);
+
+    } 
+   else // if the page is read-only , map this addr of the page too in the child 
+   if((r = sys_page_map(thisenv->env_id, addr, envid, addr,PTE_P | PTE_U )) < 0)
+   panic("duppage: sys_page_map: %e\n", r);
+
+return 0;
+
+}
+
+
+
+
+ /*if (((uvpt[pn] & PTE_COW) || (uvpt[pn] & PTE_W)) &&!(uvpt[pn] & PTE_SHARE))
+  {
+    sys_page_map(0, PGADDR(0, pn, 0),
+                 envid, PGADDR(0, pn, 0),
+duppage(envid_t envid, unsigned pn)
+    sys_page_map(0, PGADDR(0, pn, 0),
+                 0, PGADDR(0, pn, 0),
+                 ((uvpt[pn] & PTE_SYSCALL) & (~PTE_W)) | PTE_COW);
+                 }
+
+else{
+    sys_page_map(0, PGADDR(0, pn, 0),
+                 envid, PGADDR(0, pn, 0),
+                 (uvpt[pn] & PTE_SYSCALL));
 
-	// LAB 4: Your code here.
-	panic("duppage not implemented");
-	return 0;
 }
+return 0;*/
+
+ /* if (((uvpt[pn] & PTE_COW) || (uvpt[pn] & PTE_W)) && !(uvpt[pn] & PTE_SHARE))
+    {
+     sys_page_map(0, PGADDR(0, pn, 0), envid, PGADDR(0, pn, 0), ((uvpt[pn] & PTE_SYSCALL) & (~PTE_W)) | PTE_COW);
+     sys_page_map(0, PGADDR(0, pn, 0), 0, PGADDR(0, pn, 0), ((uvpt[pn] & PTE_SYSCALL) & (~PTE_W)) | PTE_COW);
+    }
+    else
+    {
+    sys_page_map(0, PGADDR(0, pn, 0), envid, PGADDR(0, pn, 0), (uvpt[pn] & PTE_SYSCALL));
+    }
+    return 0;*/
+
+
 
 //
 // User-level fork with copy-on-write.
@@ -78,7 +155,58 @@ envid_t
 fork(void)
 {
 	// LAB 4: Your code here.
-	panic("fork not implemented");
+	//panic("fork not implemented");
+        envid_t child_envid;
+        int r;
+        set_pgfault_handler(pgfault); // set the pagefault handler to pgfault which is defined above  
+
+        // Allocate a new child environment.
+        // The kernel will initialize it with a copy of our register state,
+        // so that the child will appear to have called sys_exofork() too -
+        // except that in the child, this "fake" call to sys_exofork()
+        // will return 0 instead of the envid of the child.
+        child_envid = sys_exofork();
+        if (child_envid < 0)
+                panic("fork: sys_exofork: %e", child_envid);
+        if (child_envid == 0) {
+                // We're the child.
+                // The copied value of the global variable 'thisenv'
+                // is no longer valid (it refers to the parent!).
+                // Fix it and return 0.
+                thisenv = &envs[ENVX(sys_getenvid())];
+                return 0;
+        }
+
+        // We're the parent.
+        // Eagerly copy our mappings into the child.
+       uint32_t pgno=0;
+       pte_t *pte;
+       for (; pgno < PGNUM(UTOP - PGSIZE); pgno++) 
+       {  //rounddown to the nearest multiple of NPDENTRIES
+       uint32_t pdx = ROUNDDOWN(pgno, NPDENTRIES) / NPDENTRIES; // or use PDX macro with substitution of page numbers
+       if ((uvpd[pdx] & PTE_P) == PTE_P && ((uvpt[pgno] & PTE_P) == PTE_P))  
+// traverse through the uvpt array of the parents environment to find *pte and make sure there is mapping to every page
+       {
+       duppage(child_envid, pgno);
+       }
+      } 
+ 
+        //allocate user exception stack for child
+        if(sys_page_alloc(child_envid,(void *) (UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P)<0)    
+        panic("fork: unable to allocate user exeception stack for the child"); 
+  
+        //copy the parent page fault handler entrypoint to child's environment, in this case _pgfault_upcall in lib/pfentry.S
+ 
+       if ((r = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall)) < 0)
+       panic("fork: sys_env_set_pgfault_upcall", r);
+ 
+    
+        // Now the child is ready to start running
+        if ((r = sys_env_set_status(child_envid, ENV_RUNNABLE)) < 0)
+                panic("sys_env_set_status: %e", r);
+
+        return child_envid;
+        
 }
 
 // Challenge!
diff --git a/lib/ipc.c b/lib/ipc.c
index 2e222b9..9556652 100644
--- a/lib/ipc.c
+++ b/lib/ipc.c
@@ -22,9 +22,26 @@
 int32_t
 ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 {
+	if (!pg) 
+        pg = (void*) -1;
+
+        if (sys_ipc_recv(pg))
+        {
+          *from_env_store = 0;
+          *perm_store = 0;
+           return -E_INVAL;
+        }
+
+        if (from_env_store)
+        *from_env_store = thisenv->env_ipc_from;
+    
+        if (perm_store)
+        *perm_store = thisenv->env_ipc_perm;
+
+        return thisenv->env_ipc_value;
 	// LAB 4: Your code here.
-	panic("ipc_recv not implemented");
-	return 0;
+	//panic("ipc_recv not implemented");
+	//return 0;
 }
 
 // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
@@ -38,8 +55,18 @@ ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 void
 ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
 {
+	int result;
+        if (!pg)
+        pg = (void *)-1;
+        while((result = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) 
+        {
+        sys_yield();
+        }
+
+        if (result)
+        panic ("E_IPC_NOT_RECV %e", result);
 	// LAB 4: Your code here.
-	panic("ipc_send not implemented");
+	//panic("ipc_send not implemented");
 }
 
 // Find the first environment of the given type.  We'll use this to
diff --git a/lib/libmain.c b/lib/libmain.c
index 8a14b29..9829054 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -13,7 +13,8 @@ libmain(int argc, char **argv)
 {
 	// set thisenv to point at our Env structure in envs[].
 	// LAB 3: Your code here.
-	thisenv = 0;
+	//thisenv = 0;
+	thisenv = (struct Env *)envs + ENVX(sys_getenvid());
 
 	// save the name of the program so that panic() can use it
 	if (argc > 0)
diff --git a/lib/pfentry.S b/lib/pfentry.S
index f40aeeb..c303d5d 100644
--- a/lib/pfentry.S
+++ b/lib/pfentry.S
@@ -65,18 +65,24 @@ _pgfault_upcall:
 	// ways as registers become unavailable as scratch space.
 	//
 	// LAB 4: Your code here.
-
+	movl 0x28(%esp), %edx 
+	subl $0x4, 0x30(%esp) 
+	movl 0x30(%esp), %eax 
+	movl %edx, (%eax)
+	addl $0x8, %esp
 	// Restore the trap-time registers.  After you do this, you
 	// can no longer modify any general-purpose registers.
 	// LAB 4: Your code here.
-
+	popal
 	// Restore eflags from the stack.  After you do this, you can
 	// no longer use arithmetic operations or anything else that
 	// modifies eflags.
 	// LAB 4: Your code here.
-
+	addl $0x4, %esp 
+	popfl
 	// Switch back to the adjusted trap-time stack.
 	// LAB 4: Your code here.
-
+	popl %esp
 	// Return to re-execute the instruction that faulted.
 	// LAB 4: Your code here.
+	ret
diff --git a/lib/pgfault.c b/lib/pgfault.c
index a975518..e273c83 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -29,9 +29,14 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 	if (_pgfault_handler == 0) {
 		// First time through!
 		// LAB 4: Your code here.
-		panic("set_pgfault_handler not implemented");
+		//panic("set_pgfault_handler not implemented");
+	   if (sys_page_alloc(thisenv->env_id, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) < 0) 
+			panic("set_pgfault_handler:sys_page_alloc failed");;
 	}
-
 	// Save handler pointer for assembly to call.
 	_pgfault_handler = handler;
+	if (sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall) < 0)
+		panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed");
+	
+	
 }
diff --git a/lib/spawn.c b/lib/spawn.c
index 9d0eb07..955a5c3 100644
--- a/lib/spawn.c
+++ b/lib/spawn.c
@@ -129,7 +129,7 @@ spawn(const char *prog, const char **argv)
 	if ((r = copy_shared_pages(child)) < 0)
 		panic("copy_shared_pages: %e", r);
 
-	child_tf.tf_eflags |= FL_IOPL_3;   // devious: see user/faultio.c
+	//child_tf.tf_eflags |= FL_IOPL_3;   // devious: see user/faultio.c
 	if ((r = sys_env_set_trapframe(child, &child_tf)) < 0)
 		panic("sys_env_set_trapframe: %e", r);
 
@@ -302,6 +302,15 @@ static int
 copy_shared_pages(envid_t child)
 {
 	// LAB 5: Your code here.
+	uintptr_t i;
+       for (i = 0; i < USTACKTOP; i += PGSIZE)
+       {
+        if ((uvpd[PDX(i)] & PTE_P) && (uvpt[PGNUM(i)] & PTE_P) && (uvpt[PGNUM(i)] & PTE_U) && (uvpt[PGNUM(i)] & PTE_SHARE))
+        {
+         sys_page_map(thisenv->env_id, (void*)i, child, (void*)i, (uvpt[PGNUM(i)] & PTE_SYSCALL));
+        }
+       }
+	
 	return 0;
 }
 
diff --git a/lib/syscall.c b/lib/syscall.c
index 9e1a1d9..bc15ed7 100644
--- a/lib/syscall.c
+++ b/lib/syscall.c
@@ -117,8 +117,21 @@ sys_ipc_recv(void *dstva)
 	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
 }
 
+
 unsigned int
 sys_time_msec(void)
 {
 	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
 }
+
+int
+sys_net_tx(void * addr, size_t length)
+{
+ return (int) syscall(SYS_net_tx, 0, (uint32_t)addr, (uint32_t)length, 0, 0, 0);
+}
+
+int
+sys_net_recv(void * addr)
+{
+ return (int) syscall(SYS_net_recv, 0, (uint32_t)addr, 0, 0, 0, 0);
+}
\ No newline at end of file
diff --git a/net/input.c b/net/input.c
index 4e08f0f..b09b964 100644
--- a/net/input.c
+++ b/net/input.c
@@ -13,4 +13,12 @@ input(envid_t ns_envid)
 	// Hint: When you IPC a page to the network server, it will be
 	// reading from it for a while, so don't immediately receive
 	// another packet in to the same physical page.
+	while(1) {
+     while(sys_page_alloc(0, &nsipcbuf, PTE_U | PTE_P | PTE_W) < 0);
+     while((nsipcbuf.pkt.jp_len = sys_net_recv(nsipcbuf.pkt.jp_data)) < 0) {
+         // cprintf("haha\n");
+       sys_yield();
+   }
+   while (sys_ipc_try_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_U | PTE_P | PTE_W) < 0);
+ }
 }
diff --git a/net/output.c b/net/output.c
index f577c4e..0859a1b 100644
--- a/net/output.c
+++ b/net/output.c
@@ -10,4 +10,14 @@ output(envid_t ns_envid)
 	// LAB 6: Your code here:
 	// 	- read a packet from the network server
 	//	- send the packet to the device driver
+	uint32_t req;
+
+ while (1) {
+   req = ipc_recv(0, &nsipcbuf, 0);
+   if (req == NSREQ_OUTPUT) {
+     while(sys_net_tx(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0) {
+       sys_yield();
+     }
+   }
+ }
 }
diff --git a/qemu/bin/qemu-ga b/qemu/bin/qemu-ga
new file mode 100644
index 0000000..0c68675
Binary files /dev/null and b/qemu/bin/qemu-ga differ
diff --git a/qemu/bin/qemu-img b/qemu/bin/qemu-img
new file mode 100644
index 0000000..28ee89f
Binary files /dev/null and b/qemu/bin/qemu-img differ
diff --git a/qemu/bin/qemu-io b/qemu/bin/qemu-io
new file mode 100644
index 0000000..63d3991
Binary files /dev/null and b/qemu/bin/qemu-io differ
diff --git a/qemu/bin/qemu-nbd b/qemu/bin/qemu-nbd
new file mode 100644
index 0000000..74c4500
Binary files /dev/null and b/qemu/bin/qemu-nbd differ
diff --git a/qemu/bin/qemu-system-i386 b/qemu/bin/qemu-system-i386
new file mode 100644
index 0000000..c41d11d
Binary files /dev/null and b/qemu/bin/qemu-system-i386 differ
diff --git a/qemu/bin/qemu-system-x86_64 b/qemu/bin/qemu-system-x86_64
new file mode 100644
index 0000000..9fdfc93
Binary files /dev/null and b/qemu/bin/qemu-system-x86_64 differ
diff --git a/qemu/etc/qemu/target-x86_64.conf b/qemu/etc/qemu/target-x86_64.conf
new file mode 100644
index 0000000..e69de29
diff --git a/qemu/libexec/qemu-bridge-helper b/qemu/libexec/qemu-bridge-helper
new file mode 100644
index 0000000..59f6d32
Binary files /dev/null and b/qemu/libexec/qemu-bridge-helper differ
diff --git a/qemu/share/doc/qemu/qemu-doc.html b/qemu/share/doc/qemu/qemu-doc.html
new file mode 100644
index 0000000..ffa8e3d
--- /dev/null
+++ b/qemu/share/doc/qemu/qemu-doc.html
@@ -0,0 +1,7743 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
+<head>
+<title>QEMU Emulator User Documentation</title>
+
+<meta name="description" content="QEMU Emulator User Documentation">
+<meta name="keywords" content="QEMU Emulator User Documentation">
+<meta name="resource-type" content="document">
+<meta name="distribution" content="global">
+<meta name="Generator" content="makeinfo">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<link href="#Top" rel="start" title="Top">
+<link href="#Index" rel="index" title="Index">
+<link href="#SEC_Contents" rel="contents" title="Table of Contents">
+<link href="dir.html#Top" rel="up" title="(dir)">
+<style type="text/css">
+<!--
+a.summary-letter {text-decoration: none}
+blockquote.indentedblock {margin-right: 0em}
+blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
+blockquote.smallquotation {font-size: smaller}
+div.display {margin-left: 3.2em}
+div.example {margin-left: 3.2em}
+div.lisp {margin-left: 3.2em}
+div.smalldisplay {margin-left: 3.2em}
+div.smallexample {margin-left: 3.2em}
+div.smalllisp {margin-left: 3.2em}
+kbd {font-style: oblique}
+pre.display {font-family: inherit}
+pre.format {font-family: inherit}
+pre.menu-comment {font-family: serif}
+pre.menu-preformatted {font-family: serif}
+pre.smalldisplay {font-family: inherit; font-size: smaller}
+pre.smallexample {font-size: smaller}
+pre.smallformat {font-family: inherit; font-size: smaller}
+pre.smalllisp {font-size: smaller}
+span.nolinebreak {white-space: nowrap}
+span.roman {font-family: initial; font-weight: normal}
+span.sansserif {font-family: sans-serif; font-weight: normal}
+ul.no-bullet {list-style: none}
+-->
+</style>
+
+
+</head>
+
+<body lang="en">
+<h1 class="settitle" align="center">QEMU Emulator User Documentation</h1>
+
+
+
+
+
+<a name="Top"></a>
+<a name="SEC_Top"></a>
+
+
+<a name="SEC_Contents"></a>
+<h2 class="contents-heading">Table of Contents</h2>
+
+<div class="contents">
+
+<ul class="no-bullet">
+  <li><a name="toc-Introduction-1" href="#Introduction">1 Introduction</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Features" href="#intro_005ffeatures">1.1 Features</a></li>
+  </ul></li>
+  <li><a name="toc-Installation-1" href="#Installation">2 Installation</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Linux" href="#install_005flinux">2.1 Linux</a></li>
+    <li><a name="toc-Windows-1" href="#install_005fwindows">2.2 Windows</a></li>
+    <li><a name="toc-Mac-OS-X-1" href="#install_005fmac">2.3 Mac OS X</a></li>
+  </ul></li>
+  <li><a name="toc-QEMU-PC-System-emulator-1" href="#QEMU-PC-System-emulator">3 QEMU PC System emulator</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Introduction-2" href="#pcsys_005fintroduction">3.1 Introduction</a></li>
+    <li><a name="toc-Quick-Start-1" href="#pcsys_005fquickstart">3.2 Quick Start</a></li>
+    <li><a name="toc-Invocation" href="#sec_005finvocation">3.3 Invocation</a></li>
+    <li><a name="toc-Keys" href="#pcsys_005fkeys">3.4 Keys</a></li>
+    <li><a name="toc-QEMU-Monitor" href="#pcsys_005fmonitor">3.5 QEMU Monitor</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Commands" href="#Commands">3.5.1 Commands</a></li>
+      <li><a name="toc-Integer-expressions" href="#Integer-expressions">3.5.2 Integer expressions</a></li>
+    </ul></li>
+    <li><a name="toc-Disk-Images" href="#disk_005fimages">3.6 Disk Images</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Quick-start-for-disk-image-creation" href="#disk_005fimages_005fquickstart">3.6.1 Quick start for disk image creation</a></li>
+      <li><a name="toc-Snapshot-mode" href="#disk_005fimages_005fsnapshot_005fmode">3.6.2 Snapshot mode</a></li>
+      <li><a name="toc-VM-snapshots" href="#vm_005fsnapshots">3.6.3 VM snapshots</a></li>
+      <li><a name="toc-qemu_002dimg-Invocation" href="#qemu_005fimg_005finvocation">3.6.4 <code>qemu-img</code> Invocation</a></li>
+      <li><a name="toc-qemu_002dnbd-Invocation" href="#qemu_005fnbd_005finvocation">3.6.5 <code>qemu-nbd</code> Invocation</a></li>
+      <li><a name="toc-Disk-image-file-formats" href="#disk_005fimages_005fformats">3.6.6 Disk image file formats</a>
+      <ul class="no-bullet">
+        <li><a name="toc-Read_002donly-formats" href="#Read_002donly-formats">3.6.6.1 Read-only formats</a></li>
+      </ul></li>
+      <li><a name="toc-Using-host-drives" href="#host_005fdrives">3.6.7 Using host drives</a>
+      <ul class="no-bullet">
+        <li><a name="toc-Linux-1" href="#Linux-1">3.6.7.1 Linux</a></li>
+        <li><a name="toc-Windows-2" href="#Windows-2">3.6.7.2 Windows</a></li>
+        <li><a name="toc-Mac-OS-X-2" href="#Mac-OS-X-2">3.6.7.3 Mac OS X</a></li>
+      </ul></li>
+      <li><a name="toc-Virtual-FAT-disk-images" href="#disk_005fimages_005ffat_005fimages">3.6.8 Virtual FAT disk images</a></li>
+      <li><a name="toc-NBD-access" href="#disk_005fimages_005fnbd">3.6.9 NBD access</a></li>
+      <li><a name="toc-Sheepdog-disk-images" href="#disk_005fimages_005fsheepdog">3.6.10 Sheepdog disk images</a></li>
+      <li><a name="toc-iSCSI-LUNs" href="#disk_005fimages_005fiscsi">3.6.11 iSCSI LUNs</a></li>
+      <li><a name="toc-GlusterFS-disk-images" href="#disk_005fimages_005fgluster">3.6.12 GlusterFS disk images</a></li>
+      <li><a name="toc-Secure-Shell-_0028ssh_0029-disk-images" href="#disk_005fimages_005fssh">3.6.13 Secure Shell (ssh) disk images</a></li>
+    </ul></li>
+    <li><a name="toc-Network-emulation" href="#pcsys_005fnetwork">3.7 Network emulation</a>
+    <ul class="no-bullet">
+      <li><a name="toc-VLANs" href="#VLANs">3.7.1 VLANs</a></li>
+      <li><a name="toc-Using-TAP-network-interfaces" href="#Using-TAP-network-interfaces">3.7.2 Using TAP network interfaces</a>
+      <ul class="no-bullet">
+        <li><a name="toc-Linux-host" href="#Linux-host">3.7.2.1 Linux host</a></li>
+        <li><a name="toc-Windows-host" href="#Windows-host">3.7.2.2 Windows host</a></li>
+      </ul></li>
+      <li><a name="toc-Using-the-user-mode-network-stack" href="#Using-the-user-mode-network-stack">3.7.3 Using the user mode network stack</a></li>
+      <li><a name="toc-Connecting-VLANs-between-QEMU-instances" href="#Connecting-VLANs-between-QEMU-instances">3.7.4 Connecting VLANs between QEMU instances</a></li>
+    </ul></li>
+    <li><a name="toc-Other-Devices" href="#pcsys_005fother_005fdevs">3.8 Other Devices</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Inter_002dVM-Shared-Memory-device" href="#Inter_002dVM-Shared-Memory-device">3.8.1 Inter-VM Shared Memory device</a></li>
+    </ul></li>
+    <li><a name="toc-Direct-Linux-Boot" href="#direct_005flinux_005fboot">3.9 Direct Linux Boot</a></li>
+    <li><a name="toc-USB-emulation" href="#pcsys_005fusb">3.10 USB emulation</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Connecting-USB-devices" href="#usb_005fdevices">3.10.1 Connecting USB devices</a></li>
+      <li><a name="toc-Using-host-USB-devices-on-a-Linux-host" href="#host_005fusb_005fdevices">3.10.2 Using host USB devices on a Linux host</a></li>
+    </ul></li>
+    <li><a name="toc-VNC-security" href="#vnc_005fsecurity">3.11 VNC security</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Without-passwords" href="#vnc_005fsec_005fnone">3.11.1 Without passwords</a></li>
+      <li><a name="toc-With-passwords" href="#vnc_005fsec_005fpassword">3.11.2 With passwords</a></li>
+      <li><a name="toc-With-x509-certificates" href="#vnc_005fsec_005fcertificate">3.11.3 With x509 certificates</a></li>
+      <li><a name="toc-With-x509-certificates-and-client-verification" href="#vnc_005fsec_005fcertificate_005fverify">3.11.4 With x509 certificates and client verification</a></li>
+      <li><a name="toc-With-x509-certificates_002c-client-verification-and-passwords" href="#vnc_005fsec_005fcertificate_005fpw">3.11.5 With x509 certificates, client verification and passwords</a></li>
+      <li><a name="toc-With-SASL-authentication" href="#vnc_005fsec_005fsasl">3.11.6 With SASL authentication</a></li>
+      <li><a name="toc-With-x509-certificates-and-SASL-authentication" href="#vnc_005fsec_005fcertificate_005fsasl">3.11.7 With x509 certificates and SASL authentication</a></li>
+      <li><a name="toc-Generating-certificates-for-VNC" href="#vnc_005fgenerate_005fcert">3.11.8 Generating certificates for VNC</a>
+      <ul class="no-bullet">
+        <li><a name="toc-Setup-the-Certificate-Authority" href="#vnc_005fgenerate_005fca">3.11.8.1 Setup the Certificate Authority</a></li>
+        <li><a name="toc-Issuing-server-certificates" href="#vnc_005fgenerate_005fserver">3.11.8.2 Issuing server certificates</a></li>
+        <li><a name="toc-Issuing-client-certificates" href="#vnc_005fgenerate_005fclient">3.11.8.3 Issuing client certificates</a></li>
+      </ul></li>
+      <li><a name="toc-Configuring-SASL-mechanisms" href="#vnc_005fsetup_005fsasl">3.11.9 Configuring SASL mechanisms</a></li>
+    </ul></li>
+    <li><a name="toc-GDB-usage" href="#gdb_005fusage">3.12 GDB usage</a></li>
+    <li><a name="toc-Target-OS-specific-information" href="#pcsys_005fos_005fspecific">3.13 Target OS specific information</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Linux-2" href="#Linux-2">3.13.1 Linux</a></li>
+      <li><a name="toc-Windows-3" href="#Windows-3">3.13.2 Windows</a>
+      <ul class="no-bullet">
+        <li><a name="toc-SVGA-graphic-modes-support" href="#SVGA-graphic-modes-support">3.13.2.1 SVGA graphic modes support</a></li>
+        <li><a name="toc-CPU-usage-reduction" href="#CPU-usage-reduction">3.13.2.2 CPU usage reduction</a></li>
+        <li><a name="toc-Windows-2000-disk-full-problem" href="#Windows-2000-disk-full-problem">3.13.2.3 Windows 2000 disk full problem</a></li>
+        <li><a name="toc-Windows-2000-shutdown" href="#Windows-2000-shutdown">3.13.2.4 Windows 2000 shutdown</a></li>
+        <li><a name="toc-Share-a-directory-between-Unix-and-Windows" href="#Share-a-directory-between-Unix-and-Windows">3.13.2.5 Share a directory between Unix and Windows</a></li>
+        <li><a name="toc-Windows-XP-security-problem" href="#Windows-XP-security-problem">3.13.2.6 Windows XP security problem</a></li>
+      </ul></li>
+      <li><a name="toc-MS_002dDOS-and-FreeDOS" href="#MS_002dDOS-and-FreeDOS">3.13.3 MS-DOS and FreeDOS</a>
+      <ul class="no-bullet">
+        <li><a name="toc-CPU-usage-reduction-1" href="#CPU-usage-reduction-1">3.13.3.1 CPU usage reduction</a></li>
+      </ul></li>
+    </ul></li>
+  </ul></li>
+  <li><a name="toc-QEMU-System-emulator-for-non-PC-targets-1" href="#QEMU-System-emulator-for-non-PC-targets">4 QEMU System emulator for non PC targets</a>
+  <ul class="no-bullet">
+    <li><a name="toc-PowerPC-System-emulator-1" href="#PowerPC-System-emulator">4.1 PowerPC System emulator</a></li>
+    <li><a name="toc-Sparc32-System-emulator-1" href="#Sparc32-System-emulator">4.2 Sparc32 System emulator</a></li>
+    <li><a name="toc-Sparc64-System-emulator-1" href="#Sparc64-System-emulator">4.3 Sparc64 System emulator</a></li>
+    <li><a name="toc-MIPS-System-emulator-1" href="#MIPS-System-emulator">4.4 MIPS System emulator</a></li>
+    <li><a name="toc-ARM-System-emulator-1" href="#ARM-System-emulator">4.5 ARM System emulator</a></li>
+    <li><a name="toc-ColdFire-System-emulator-1" href="#ColdFire-System-emulator">4.6 ColdFire System emulator</a></li>
+    <li><a name="toc-Cris-System-emulator-1" href="#Cris-System-emulator">4.7 Cris System emulator</a></li>
+    <li><a name="toc-Microblaze-System-emulator-1" href="#Microblaze-System-emulator">4.8 Microblaze System emulator</a></li>
+    <li><a name="toc-SH4-System-emulator-1" href="#SH4-System-emulator">4.9 SH4 System emulator</a></li>
+    <li><a name="toc-Xtensa-System-emulator-1" href="#Xtensa-System-emulator">4.10 Xtensa System emulator</a></li>
+  </ul></li>
+  <li><a name="toc-QEMU-User-space-emulator-1" href="#QEMU-User-space-emulator">5 QEMU User space emulator</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Supported-Operating-Systems-1" href="#Supported-Operating-Systems">5.1 Supported Operating Systems</a></li>
+    <li><a name="toc-Linux-User-space-emulator-1" href="#Linux-User-space-emulator">5.2 Linux User space emulator</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Quick-Start-2" href="#Quick-Start">5.2.1 Quick Start</a></li>
+      <li><a name="toc-Wine-launch-1" href="#Wine-launch">5.2.2 Wine launch</a></li>
+      <li><a name="toc-Command-line-options-1" href="#Command-line-options">5.2.3 Command line options</a></li>
+      <li><a name="toc-Other-binaries-1" href="#Other-binaries">5.2.4 Other binaries</a></li>
+    </ul></li>
+    <li><a name="toc-BSD-User-space-emulator-1" href="#BSD-User-space-emulator">5.3 BSD User space emulator</a>
+    <ul class="no-bullet">
+      <li><a name="toc-BSD-Status-1" href="#BSD-Status">5.3.1 BSD Status</a></li>
+      <li><a name="toc-Quick-Start-3" href="#BSD-Quick-Start">5.3.2 Quick Start</a></li>
+      <li><a name="toc-Command-line-options-2" href="#BSD-Command-line-options">5.3.3 Command line options</a></li>
+    </ul></li>
+  </ul></li>
+  <li><a name="toc-Compilation-from-the-sources" href="#compilation">6 Compilation from the sources</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Linux_002fUnix-1" href="#Linux_002fUnix">6.1 Linux/Unix</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Compilation" href="#Compilation">6.1.1 Compilation</a></li>
+    </ul></li>
+    <li><a name="toc-Windows-4" href="#Windows">6.2 Windows</a></li>
+    <li><a name="toc-Cross-compilation-for-Windows-with-Linux-1" href="#Cross-compilation-for-Windows-with-Linux">6.3 Cross compilation for Windows with Linux</a></li>
+    <li><a name="toc-Mac-OS-X-3" href="#Mac-OS-X">6.4 Mac OS X</a></li>
+    <li><a name="toc-Make-targets-1" href="#Make-targets">6.5 Make targets</a></li>
+  </ul></li>
+  <li><a name="toc-License-1" href="#License">Appendix A License</a></li>
+  <li><a name="toc-Index-1" href="#Index">Appendix B Index</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Concept-Index-1" href="#Concept-Index">B.1 Concept Index</a></li>
+    <li><a name="toc-Function-Index-1" href="#Function-Index">B.2 Function Index</a></li>
+    <li><a name="toc-Keystroke-Index-1" href="#Keystroke-Index">B.3 Keystroke Index</a></li>
+    <li><a name="toc-Program-Index-1" href="#Program-Index">B.4 Program Index</a></li>
+    <li><a name="toc-Data-Type-Index-1" href="#Data-Type-Index">B.5 Data Type Index</a></li>
+    <li><a name="toc-Variable-Index-1" href="#Variable-Index">B.6 Variable Index</a></li>
+  </ul></li>
+</ul>
+</div>
+
+
+<hr>
+<a name="Introduction"></a>
+<a name="Introduction-1"></a>
+<h2 class="chapter">1 Introduction</h2>
+
+
+<hr>
+<a name="intro_005ffeatures"></a>
+<a name="Features"></a>
+<h3 class="section">1.1 Features</h3>
+
+<p>QEMU is a FAST! processor emulator using dynamic translation to
+achieve good emulation speed.
+</p>
+<p>QEMU has two operating modes:
+</p>
+<ul>
+<li><a name="index-operating-modes"></a>
+
+</li><li> <a name="index-system-emulation"></a>
+Full system emulation. In this mode, QEMU emulates a full system (for
+example a PC), including one or several processors and various
+peripherals. It can be used to launch different Operating Systems
+without rebooting the PC or to debug system code.
+
+</li><li> <a name="index-user-mode-emulation"></a>
+User mode emulation. In this mode, QEMU can launch
+processes compiled for one CPU on another CPU. It can be used to
+launch the Wine Windows API emulator (<a href="http://www.winehq.org">http://www.winehq.org</a>) or
+to ease cross-compilation and cross-debugging.
+
+</li></ul>
+
+<p>QEMU can run without a host kernel driver and yet gives acceptable
+performance.
+</p>
+<p>For system emulation, the following hardware targets are supported:
+</p><ul>
+<li> <a name="index-emulated-target-systems"></a>
+<a name="index-supported-target-systems"></a>
+PC (x86 or x86_64 processor)
+</li><li> ISA PC (old style PC without PCI bus)
+</li><li> PREP (PowerPC processor)
+</li><li> G3 Beige PowerMac (PowerPC processor)
+</li><li> Mac99 PowerMac (PowerPC processor, in progress)
+</li><li> Sun4m/Sun4c/Sun4d (32-bit Sparc processor)
+</li><li> Sun4u/Sun4v (64-bit Sparc processor, in progress)
+</li><li> Malta board (32-bit and 64-bit MIPS processors)
+</li><li> MIPS Magnum (64-bit MIPS processor)
+</li><li> ARM Integrator/CP (ARM)
+</li><li> ARM Versatile baseboard (ARM)
+</li><li> ARM RealView Emulation/Platform baseboard (ARM)
+</li><li> Spitz, Akita, Borzoi, Terrier and Tosa PDAs (PXA270 processor)
+</li><li> Luminary Micro LM3S811EVB (ARM Cortex-M3)
+</li><li> Luminary Micro LM3S6965EVB (ARM Cortex-M3)
+</li><li> Freescale MCF5208EVB (ColdFire V2).
+</li><li> Arnewsh MCF5206 evaluation board (ColdFire V2).
+</li><li> Palm Tungsten|E PDA (OMAP310 processor)
+</li><li> N800 and N810 tablets (OMAP2420 processor)
+</li><li> MusicPal (MV88W8618 ARM processor)
+</li><li> Gumstix &quot;Connex&quot; and &quot;Verdex&quot; motherboards (PXA255/270).
+</li><li> Siemens SX1 smartphone (OMAP310 processor)
+</li><li> AXIS-Devboard88 (CRISv32 ETRAX-FS).
+</li><li> Petalogix Spartan 3aDSP1800 MMU ref design (MicroBlaze).
+</li><li> Avnet LX60/LX110/LX200 boards (Xtensa)
+</li></ul>
+
+<a name="index-supported-user-mode-targets"></a>
+<p>For user emulation, x86 (32 and 64 bit), PowerPC (32 and 64 bit),
+ARM, MIPS (32 bit only), Sparc (32 and 64 bit),
+Alpha, ColdFire(m68k), CRISv32 and MicroBlaze CPUs are supported.
+</p>
+<hr>
+<a name="Installation"></a>
+<a name="Installation-1"></a>
+<h2 class="chapter">2 Installation</h2>
+
+<p>If you want to compile QEMU yourself, see <a href="#compilation">compilation</a>.
+</p>
+
+<hr>
+<a name="install_005flinux"></a>
+<a name="Linux"></a>
+<h3 class="section">2.1 Linux</h3>
+<a name="index-installation-_0028Linux_0029"></a>
+
+<p>If a precompiled package is available for your distribution - you just
+have to install it. Otherwise, see <a href="#compilation">compilation</a>.
+</p>
+<hr>
+<a name="install_005fwindows"></a>
+<a name="Windows-1"></a>
+<h3 class="section">2.2 Windows</h3>
+<a name="index-installation-_0028Windows_0029"></a>
+
+<p>Download the experimental binary installer at
+<a href="http://www.free.oszoo.org/download.html">http://www.free.oszoo.org/download.html</a>.
+TODO (no longer available)
+</p>
+<hr>
+<a name="install_005fmac"></a>
+<a name="Mac-OS-X-1"></a>
+<h3 class="section">2.3 Mac OS X</h3>
+
+<p>Download the experimental binary installer at
+<a href="http://www.free.oszoo.org/download.html">http://www.free.oszoo.org/download.html</a>.
+TODO (no longer available)
+</p>
+<hr>
+<a name="QEMU-PC-System-emulator"></a>
+<a name="QEMU-PC-System-emulator-1"></a>
+<h2 class="chapter">3 QEMU PC System emulator</h2>
+<a name="index-system-emulation-_0028PC_0029"></a>
+
+
+<hr>
+<a name="pcsys_005fintroduction"></a>
+<a name="Introduction-2"></a>
+<h3 class="section">3.1 Introduction</h3>
+
+
+<p>The QEMU PC System emulator simulates the
+following peripherals:
+</p>
+<ul class="no-bullet">
+<li>- i440FX host PCI bridge and PIIX3 PCI to ISA bridge
+</li><li>- Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA
+extensions (hardware level, including all non standard modes).
+</li><li>- PS/2 mouse and keyboard
+</li><li>- 2 PCI IDE interfaces with hard disk and CD-ROM support
+</li><li>- Floppy disk
+</li><li>- PCI and ISA network adapters
+</li><li>- Serial ports
+</li><li>- Creative SoundBlaster 16 sound card
+</li><li>- ENSONIQ AudioPCI ES1370 sound card
+</li><li>- Intel 82801AA AC97 Audio compatible sound card
+</li><li>- Intel HD Audio Controller and HDA codec
+</li><li>- Adlib (OPL2) - Yamaha YM3812 compatible chip
+</li><li>- Gravis Ultrasound GF1 sound card
+</li><li>- CS4231A compatible sound card
+</li><li>- PCI UHCI USB controller and a virtual USB hub.
+</li></ul>
+
+<p>SMP is supported with up to 255 CPUs.
+</p>
+<p>QEMU uses the PC BIOS from the Seabios project and the Plex86/Bochs LGPL
+VGA BIOS.
+</p>
+<p>QEMU uses YM3812 emulation by Tatsuyuki Satoh.
+</p>
+<p>QEMU uses GUS emulation (GUSEMU32 <a href="http://www.deinmeister.de/gusemu/">http://www.deinmeister.de/gusemu/</a>)
+by Tibor &quot;TS&quot; Schütz.
+</p>
+<p>Note that, by default, GUS shares IRQ(7) with parallel ports and so
+QEMU must be told to not have parallel ports to have working GUS.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 dos.img -soundhw gus -parallel none
+</pre></div>
+
+<p>Alternatively:
+</p><div class="example">
+<pre class="example">qemu-system-i386 dos.img -device gus,irq=5
+</pre></div>
+
+<p>Or some other unclaimed IRQ.
+</p>
+<p>CS4231A is the chip used in Windows Sound System and GUSMAX products
+</p>
+
+<hr>
+<a name="pcsys_005fquickstart"></a>
+<a name="Quick-Start-1"></a>
+<h3 class="section">3.2 Quick Start</h3>
+<a name="index-quick-start"></a>
+
+<p>Download and uncompress the linux image (<samp>linux.img</samp>) and type:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img
+</pre></div>
+
+<p>Linux should boot and give you a prompt.
+</p>
+<hr>
+<a name="sec_005finvocation"></a>
+<a name="Invocation"></a>
+<h3 class="section">3.3 Invocation</h3>
+
+<div class="example">
+<pre class="example">usage: qemu-system-i386 [options] [<var>disk_image</var>]
+</pre></div>
+
+<p><var>disk_image</var> is a raw hard disk image for IDE hard disk 0. Some
+targets do not need a disk image.
+</p>
+<p>Standard options:
+</p><dl compact="compact">
+<dt><samp>-h</samp></dt>
+<dd><a name="index-_002dh"></a>
+<p>Display help and exit
+</p></dd>
+<dt><samp>-version</samp></dt>
+<dd><a name="index-_002dversion"></a>
+<p>Display version information and exit
+</p></dd>
+<dt><samp>-machine [type=]<var>name</var>[,prop=<var>value</var>[,...]]</samp></dt>
+<dd><a name="index-_002dmachine"></a>
+<p>Select the emulated machine by <var>name</var>. Use <code>-machine help</code> to list
+available machines. Supported machine properties are:
+</p><dl compact="compact">
+<dt><samp>accel=<var>accels1</var>[:<var>accels2</var>[:...]]</samp></dt>
+<dd><p>This is used to enable an accelerator. Depending on the target architecture,
+kvm, xen, or tcg can be available. By default, tcg is used. If there is more
+than one accelerator specified, the next one is used if the previous one fails
+to initialize.
+</p></dd>
+<dt><samp>kernel_irqchip=on|off</samp></dt>
+<dd><p>Enables in-kernel irqchip support for the chosen accelerator when available.
+</p></dd>
+<dt><samp>vmport=on|off|auto</samp></dt>
+<dd><p>Enables emulation of VMWare IO port, for vmmouse etc. auto says to select the
+value based on accel. For accel=xen the default is off otherwise the default
+is on.
+</p></dd>
+<dt><samp>kvm_shadow_mem=size</samp></dt>
+<dd><p>Defines the size of the KVM shadow MMU.
+</p></dd>
+<dt><samp>dump-guest-core=on|off</samp></dt>
+<dd><p>Include guest memory in a core dump. The default is on.
+</p></dd>
+<dt><samp>mem-merge=on|off</samp></dt>
+<dd><p>Enables or disables memory merge support. This feature, when supported by
+the host, de-duplicates identical memory pages among VMs instances
+(enabled by default).
+</p></dd>
+<dt><samp>iommu=on|off</samp></dt>
+<dd><p>Enables or disables emulated Intel IOMMU (VT-d) support. The default is off.
+</p></dd>
+<dt><samp>aes-key-wrap=on|off</samp></dt>
+<dd><p>Enables or disables AES key wrapping support on s390-ccw hosts. This feature
+controls whether AES wrapping keys will be created to allow
+execution of AES cryptographic functions.  The default is on.
+</p></dd>
+<dt><samp>dea-key-wrap=on|off</samp></dt>
+<dd><p>Enables or disables DEA key wrapping support on s390-ccw hosts. This feature
+controls whether DEA wrapping keys will be created to allow
+execution of DEA cryptographic functions.  The default is on.
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-cpu <var>model</var></samp></dt>
+<dd><a name="index-_002dcpu"></a>
+<p>Select CPU model (<code>-cpu help</code> for list and additional feature selection)
+</p></dd>
+<dt><samp>-smp [cpus=]<var>n</var>[,cores=<var>cores</var>][,threads=<var>threads</var>][,sockets=<var>sockets</var>][,maxcpus=<var>maxcpus</var>]</samp></dt>
+<dd><a name="index-_002dsmp"></a>
+<p>Simulate an SMP system with <var>n</var> CPUs. On the PC target, up to 255
+CPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs
+to 4.
+For the PC target, the number of <var>cores</var> per socket, the number
+of <var>threads</var> per cores and the total number of <var>sockets</var> can be
+specified. Missing values will be computed. If any on the three values is
+given, the total number of CPUs <var>n</var> can be omitted. <var>maxcpus</var>
+specifies the maximum number of hotpluggable CPUs.
+</p></dd>
+<dt><samp>-numa node[,mem=<var>size</var>][,cpus=<var>cpu[-cpu]</var>][,nodeid=<var>node</var>]</samp></dt>
+<dt><samp>-numa node[,memdev=<var>id</var>][,cpus=<var>cpu[-cpu]</var>][,nodeid=<var>node</var>]</samp></dt>
+<dd><a name="index-_002dnuma"></a>
+<p>Simulate a multi node NUMA system. If &lsquo;<samp>mem</samp>&rsquo;, &lsquo;<samp>memdev</samp>&rsquo;
+and &lsquo;<samp>cpus</samp>&rsquo; are omitted, resources are split equally. Also, note
+that the -<samp>numa</samp> option doesn&rsquo;t allocate any of the specified
+resources. That is, it just assigns existing resources to NUMA nodes. This
+means that one still has to use the <samp>-m</samp>, <samp>-smp</samp> options
+to allocate RAM and VCPUs respectively, and possibly <samp>-object</samp>
+to specify the memory backend for the &lsquo;<samp>memdev</samp>&rsquo; suboption.
+</p>
+<p>&lsquo;<samp>mem</samp>&rsquo; and &lsquo;<samp>memdev</samp>&rsquo; are mutually exclusive.  Furthermore, if one
+node uses &lsquo;<samp>memdev</samp>&rsquo;, all of them have to use it.
+</p></dd>
+<dt><samp>-add-fd fd=<var>fd</var>,set=<var>set</var>[,opaque=<var>opaque</var>]</samp></dt>
+<dd><a name="index-_002dadd_002dfd"></a>
+
+<p>Add a file descriptor to an fd set.  Valid options are:
+</p>
+<dl compact="compact">
+<dt><samp>fd=<var>fd</var></samp></dt>
+<dd><p>This option defines the file descriptor of which a duplicate is added to fd set.
+The file descriptor cannot be stdin, stdout, or stderr.
+</p></dd>
+<dt><samp>set=<var>set</var></samp></dt>
+<dd><p>This option defines the ID of the fd set to add the file descriptor to.
+</p></dd>
+<dt><samp>opaque=<var>opaque</var></samp></dt>
+<dd><p>This option defines a free-form string that can be used to describe <var>fd</var>.
+</p></dd>
+</dl>
+
+<p>You can open an image using pre-opened file descriptors from an fd set:
+</p><div class="example">
+<pre class="example">qemu-system-i386
+-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
+-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
+-drive file=/dev/fdset/2,index=0,media=disk
+</pre></div>
+</dd>
+<dt><samp>-set <var>group</var>.<var>id</var>.<var>arg</var>=<var>value</var></samp></dt>
+<dd><a name="index-_002dset"></a>
+<p>Set parameter <var>arg</var> for item <var>id</var> of type <var>group</var>
+&quot;
+</p></dd>
+<dt><samp>-global <var>driver</var>.<var>prop</var>=<var>value</var></samp></dt>
+<dd><a name="index-_002dglobal"></a>
+<p>Set default value of <var>driver</var>&rsquo;s property <var>prop</var> to <var>value</var>, e.g.:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 -global ide-drive.physical_block_size=4096 -drive file=file,if=ide,index=0,media=disk
+</pre></div>
+
+<p>In particular, you can use this to set driver properties for devices which are 
+created automatically by the machine model. To create a device which is not 
+created automatically and set properties on it, use -<samp>device</samp>.
+</p></dd>
+<dt><samp>-boot [order=<var>drives</var>][,once=<var>drives</var>][,menu=on|off][,splash=<var>sp_name</var>][,splash-time=<var>sp_time</var>][,reboot-timeout=<var>rb_timeout</var>][,strict=on|off]</samp></dt>
+<dd><a name="index-_002dboot"></a>
+<p>Specify boot order <var>drives</var> as a string of drive letters. Valid
+drive letters depend on the target achitecture. The x86 PC uses: a, b
+(floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot
+from network adapter 1-4), hard disk boot is the default. To apply a
+particular boot order only on the first startup, specify it via
+<samp>once</samp>.
+</p>
+<p>Interactive boot menus/prompts can be enabled via <samp>menu=on</samp> as far
+as firmware/BIOS supports them. The default is non-interactive boot.
+</p>
+<p>A splash picture could be passed to bios, enabling user to show it as logo,
+when option splash=<var>sp_name</var> is given and menu=on, If firmware/BIOS
+supports them. Currently Seabios for X86 system support it.
+limitation: The splash file could be a jpeg file or a BMP file in 24 BPP
+format(true color). The resolution should be supported by the SVGA mode, so
+the recommended is 320x240, 640x480, 800x640.
+</p>
+<p>A timeout could be passed to bios, guest will pause for <var>rb_timeout</var> ms
+when boot failed, then reboot. If <var>rb_timeout</var> is &rsquo;-1&rsquo;, guest will not
+reboot, qemu passes &rsquo;-1&rsquo; to bios by default. Currently Seabios for X86
+system support it.
+</p>
+<p>Do strict boot via <samp>strict=on</samp> as far as firmware/BIOS
+supports it. This only effects when boot priority is changed by
+bootindex options. The default is non-strict boot.
+</p>
+<div class="example">
+<pre class="example"># try to boot from network first, then from hard disk
+qemu-system-i386 -boot order=nc
+# boot from CD-ROM first, switch back to default order after reboot
+qemu-system-i386 -boot once=d
+# boot with a splash picture for 5 seconds.
+qemu-system-i386 -boot menu=on,splash=/root/boot.bmp,splash-time=5000
+</pre></div>
+
+<p>Note: The legacy format &rsquo;-boot <var>drives</var>&rsquo; is still supported but its
+use is discouraged as it may be removed from future versions.
+</p></dd>
+<dt><samp>-m [size=]<var>megs</var>[,slots=n,maxmem=size]</samp></dt>
+<dd><a name="index-_002dm"></a>
+<p>Sets guest startup RAM size to <var>megs</var> megabytes. Default is 128 MiB.
+Optionally, a suffix of &ldquo;M&rdquo; or &ldquo;G&rdquo; can be used to signify a value in
+megabytes or gigabytes respectively. Optional pair <var>slots</var>, <var>maxmem</var>
+could be used to set amount of hotpluggable memory slots and maximum amount of
+memory. Note that <var>maxmem</var> must be aligned to the page size.
+</p>
+<p>For example, the following command-line sets the guest startup RAM size to
+1GB, creates 3 slots to hotplug additional memory and sets the maximum
+memory the guest can reach to 4GB:
+</p>
+<div class="example">
+<pre class="example">qemu-system-x86_64 -m 1G,slots=3,maxmem=4G
+</pre></div>
+
+<p>If <var>slots</var> and <var>maxmem</var> are not specified, memory hotplug won&rsquo;t
+be enabled and the guest startup RAM will never increase.
+</p></dd>
+<dt><samp>-mem-path <var>path</var></samp></dt>
+<dd><a name="index-_002dmem_002dpath"></a>
+<p>Allocate guest RAM from a temporarily created file in <var>path</var>.
+</p></dd>
+<dt><samp>-mem-prealloc</samp></dt>
+<dd><a name="index-_002dmem_002dprealloc"></a>
+<p>Preallocate memory when using -mem-path.
+</p></dd>
+<dt><samp>-k <var>language</var></samp></dt>
+<dd><a name="index-_002dk"></a>
+<p>Use keyboard layout <var>language</var> (for example <code>fr</code> for
+French). This option is only needed where it is not easy to get raw PC
+keycodes (e.g. on Macs, with some X11 servers or with a VNC
+display). You don&rsquo;t normally need to use it on PC/Linux or PC/Windows
+hosts.
+</p>
+<p>The available layouts are:
+</p><div class="example">
+<pre class="example">ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
+da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
+de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
+</pre></div>
+
+<p>The default is <code>en-us</code>.
+</p></dd>
+<dt><samp>-audio-help</samp></dt>
+<dd><a name="index-_002daudio_002dhelp"></a>
+<p>Will show the audio subsystem help: list of drivers, tunable
+parameters.
+</p></dd>
+<dt><samp>-soundhw <var>card1</var>[,<var>card2</var>,...] or -soundhw all</samp></dt>
+<dd><a name="index-_002dsoundhw"></a>
+<p>Enable audio and selected sound hardware. Use &rsquo;help&rsquo; to print all
+available sound hardware.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 -soundhw sb16,adlib disk.img
+qemu-system-i386 -soundhw es1370 disk.img
+qemu-system-i386 -soundhw ac97 disk.img
+qemu-system-i386 -soundhw hda disk.img
+qemu-system-i386 -soundhw all disk.img
+qemu-system-i386 -soundhw help
+</pre></div>
+
+<p>Note that Linux&rsquo;s i810_audio OSS kernel (for AC97) module might
+require manually specifying clocking.
+</p>
+<div class="example">
+<pre class="example">modprobe i810_audio clocking=48000
+</pre></div>
+</dd>
+<dt><samp>-balloon none</samp></dt>
+<dd><a name="index-_002dballoon"></a>
+<p>Disable balloon device.
+</p></dd>
+<dt><samp>-balloon virtio[,addr=<var>addr</var>]</samp></dt>
+<dd><p>Enable virtio balloon device (default), optionally with PCI address
+<var>addr</var>.
+</p></dd>
+<dt><samp>-device <var>driver</var>[,<var>prop</var>[=<var>value</var>][,...]]</samp></dt>
+<dd><a name="index-_002ddevice"></a>
+<p>Add device <var>driver</var>.  <var>prop</var>=<var>value</var> sets driver
+properties.  Valid properties depend on the driver.  To get help on
+possible drivers and properties, use <code>-device help</code> and
+<code>-device <var>driver</var>,help</code>.
+</p></dd>
+<dt><samp>-name <var>name</var></samp></dt>
+<dd><a name="index-_002dname"></a>
+<p>Sets the <var>name</var> of the guest.
+This name will be displayed in the SDL window caption.
+The <var>name</var> will also be used for the VNC server.
+Also optionally set the top visible process name in Linux.
+Naming of individual threads can also be enabled on Linux to aid debugging.
+</p></dd>
+<dt><samp>-uuid <var>uuid</var></samp></dt>
+<dd><a name="index-_002duuid"></a>
+<p>Set system UUID.
+</p></dd>
+</dl>
+
+<p>Block device options:
+</p><dl compact="compact">
+<dt><samp>-fda <var>file</var></samp></dt>
+<dt><samp>-fdb <var>file</var></samp></dt>
+<dd><a name="index-_002dfda"></a>
+<a name="index-_002dfdb"></a>
+<p>Use <var>file</var> as floppy disk 0/1 image (see <a href="#disk_005fimages">disk_images</a>).
+</p></dd>
+<dt><samp>-hda <var>file</var></samp></dt>
+<dt><samp>-hdb <var>file</var></samp></dt>
+<dt><samp>-hdc <var>file</var></samp></dt>
+<dt><samp>-hdd <var>file</var></samp></dt>
+<dd><a name="index-_002dhda"></a>
+<a name="index-_002dhdb"></a>
+<a name="index-_002dhdc"></a>
+<a name="index-_002dhdd"></a>
+<p>Use <var>file</var> as hard disk 0, 1, 2 or 3 image (see <a href="#disk_005fimages">disk_images</a>).
+</p></dd>
+<dt><samp>-cdrom <var>file</var></samp></dt>
+<dd><a name="index-_002dcdrom"></a>
+<p>Use <var>file</var> as CD-ROM image (you cannot use <samp>-hdc</samp> and
+<samp>-cdrom</samp> at the same time). You can use the host CD-ROM by
+using <samp>/dev/cdrom</samp> as filename (see <a href="#host_005fdrives">host_drives</a>).
+</p></dd>
+<dt><samp>-drive <var>option</var>[,<var>option</var>[,<var>option</var>[,...]]]</samp></dt>
+<dd><a name="index-_002ddrive"></a>
+
+<p>Define a new drive. Valid options are:
+</p>
+<dl compact="compact">
+<dt><samp>file=<var>file</var></samp></dt>
+<dd><p>This option defines which disk image (see <a href="#disk_005fimages">disk_images</a>) to use with
+this drive. If the filename contains comma, you must double it
+(for instance, &quot;file=my,,file&quot; to use file &quot;my,file&quot;).
+</p>
+<p>Special files such as iSCSI devices can be specified using protocol
+specific URLs. See the section for &quot;Device URL Syntax&quot; for more information.
+</p></dd>
+<dt><samp>if=<var>interface</var></samp></dt>
+<dd><p>This option defines on which type on interface the drive is connected.
+Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.
+</p></dd>
+<dt><samp>bus=<var>bus</var>,unit=<var>unit</var></samp></dt>
+<dd><p>These options define where is connected the drive by defining the bus number and
+the unit id.
+</p></dd>
+<dt><samp>index=<var>index</var></samp></dt>
+<dd><p>This option defines where is connected the drive by using an index in the list
+of available connectors of a given interface type.
+</p></dd>
+<dt><samp>media=<var>media</var></samp></dt>
+<dd><p>This option defines the type of the media: disk or cdrom.
+</p></dd>
+<dt><samp>cyls=<var>c</var>,heads=<var>h</var>,secs=<var>s</var>[,trans=<var>t</var>]</samp></dt>
+<dd><p>These options have the same definition as they have in <samp>-hdachs</samp>.
+</p></dd>
+<dt><samp>snapshot=<var>snapshot</var></samp></dt>
+<dd><p><var>snapshot</var> is &quot;on&quot; or &quot;off&quot; and controls snapshot mode for the given drive
+(see <samp>-snapshot</samp>).
+</p></dd>
+<dt><samp>cache=<var>cache</var></samp></dt>
+<dd><p><var>cache</var> is &quot;none&quot;, &quot;writeback&quot;, &quot;unsafe&quot;, &quot;directsync&quot; or &quot;writethrough&quot; and controls how the host cache is used to access block data.
+</p></dd>
+<dt><samp>aio=<var>aio</var></samp></dt>
+<dd><p><var>aio</var> is &quot;threads&quot;, or &quot;native&quot; and selects between pthread based disk I/O and native Linux AIO.
+</p></dd>
+<dt><samp>discard=<var>discard</var></samp></dt>
+<dd><p><var>discard</var> is one of &quot;ignore&quot; (or &quot;off&quot;) or &quot;unmap&quot; (or &quot;on&quot;) and controls whether <em>discard</em> (also known as <em>trim</em> or <em>unmap</em>) requests are ignored or passed to the filesystem.  Some machine types may not support discard requests.
+</p></dd>
+<dt><samp>format=<var>format</var></samp></dt>
+<dd><p>Specify which disk <var>format</var> will be used rather than detecting
+the format.  Can be used to specifiy format=raw to avoid interpreting
+an untrusted format header.
+</p></dd>
+<dt><samp>serial=<var>serial</var></samp></dt>
+<dd><p>This option specifies the serial number to assign to the device.
+</p></dd>
+<dt><samp>addr=<var>addr</var></samp></dt>
+<dd><p>Specify the controller&rsquo;s PCI address (if=virtio only).
+</p></dd>
+<dt><samp>werror=<var>action</var>,rerror=<var>action</var></samp></dt>
+<dd><p>Specify which <var>action</var> to take on write and read errors. Valid actions are:
+&quot;ignore&quot; (ignore the error and try to continue), &quot;stop&quot; (pause QEMU),
+&quot;report&quot; (report the error to the guest), &quot;enospc&quot; (pause QEMU only if the
+host disk is full; report the error to the guest otherwise).
+The default setting is <samp>werror=enospc</samp> and <samp>rerror=report</samp>.
+</p></dd>
+<dt><samp>readonly</samp></dt>
+<dd><p>Open drive <samp>file</samp> as read-only. Guest write attempts will fail.
+</p></dd>
+<dt><samp>copy-on-read=<var>copy-on-read</var></samp></dt>
+<dd><p><var>copy-on-read</var> is &quot;on&quot; or &quot;off&quot; and enables whether to copy read backing
+file sectors into the image file.
+</p></dd>
+<dt><samp>detect-zeroes=<var>detect-zeroes</var></samp></dt>
+<dd><p><var>detect-zeroes</var> is &quot;off&quot;, &quot;on&quot; or &quot;unmap&quot; and enables the automatic
+conversion of plain zero writes by the OS to driver specific optimized
+zero write commands. You may even choose &quot;unmap&quot; if <var>discard</var> is set
+to &quot;unmap&quot; to allow a zero write to be converted to an UNMAP operation.
+</p></dd>
+</dl>
+
+<p>By default, the <samp>cache=writeback</samp> mode is used. It will report data
+writes as completed as soon as the data is present in the host page cache.
+This is safe as long as your guest OS makes sure to correctly flush disk caches
+where needed. If your guest OS does not handle volatile disk write caches
+correctly and your host crashes or loses power, then the guest may experience
+data corruption.
+</p>
+<p>For such guests, you should consider using <samp>cache=writethrough</samp>. This
+means that the host page cache will be used to read and write data, but write
+notification will be sent to the guest only after QEMU has made sure to flush
+each write to the disk. Be aware that this has a major impact on performance.
+</p>
+<p>The host page cache can be avoided entirely with <samp>cache=none</samp>.  This will
+attempt to do disk IO directly to the guest&rsquo;s memory.  QEMU may still perform
+an internal copy of the data. Note that this is considered a writeback mode and
+the guest OS must handle the disk write cache correctly in order to avoid data
+corruption on host crashes.
+</p>
+<p>The host page cache can be avoided while only sending write notifications to
+the guest when the data has been flushed to the disk using
+<samp>cache=directsync</samp>.
+</p>
+<p>In case you don&rsquo;t care about data integrity over host failures, use
+<samp>cache=unsafe</samp>. This option tells QEMU that it never needs to write any
+data to the disk but can instead keep things in cache. If anything goes wrong,
+like your host losing power, the disk storage getting disconnected accidentally,
+etc. your image will most probably be rendered unusable.   When using
+the <samp>-snapshot</samp> option, unsafe caching is always used.
+</p>
+<p>Copy-on-read avoids accessing the same backing file sectors repeatedly and is
+useful when the backing file is over a slow network.  By default copy-on-read
+is off.
+</p>
+<p>Instead of <samp>-cdrom</samp> you can use:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=file,index=2,media=cdrom
+</pre></div>
+
+<p>Instead of <samp>-hda</samp>, <samp>-hdb</samp>, <samp>-hdc</samp>, <samp>-hdd</samp>, you can
+use:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=file,index=0,media=disk
+qemu-system-i386 -drive file=file,index=1,media=disk
+qemu-system-i386 -drive file=file,index=2,media=disk
+qemu-system-i386 -drive file=file,index=3,media=disk
+</pre></div>
+
+<p>You can open an image using pre-opened file descriptors from an fd set:
+</p><div class="example">
+<pre class="example">qemu-system-i386
+-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
+-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
+-drive file=/dev/fdset/2,index=0,media=disk
+</pre></div>
+
+<p>You can connect a CDROM to the slave of ide0:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=file,if=ide,index=1,media=cdrom
+</pre></div>
+
+<p>If you don&rsquo;t specify the &quot;file=&quot; argument, you define an empty drive:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive if=ide,index=1,media=cdrom
+</pre></div>
+
+<p>You can connect a SCSI disk with unit ID 6 on the bus #0:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=file,if=scsi,bus=0,unit=6
+</pre></div>
+
+<p>Instead of <samp>-fda</samp>, <samp>-fdb</samp>, you can use:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=file,index=0,if=floppy
+qemu-system-i386 -drive file=file,index=1,if=floppy
+</pre></div>
+
+<p>By default, <var>interface</var> is &quot;ide&quot; and <var>index</var> is automatically
+incremented:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=a -drive file=b&quot;
+</pre></div>
+<p>is interpreted like:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -hda a -hdb b
+</pre></div>
+</dd>
+<dt><samp>-mtdblock <var>file</var></samp></dt>
+<dd><a name="index-_002dmtdblock"></a>
+<p>Use <var>file</var> as on-board Flash memory image.
+</p></dd>
+<dt><samp>-sd <var>file</var></samp></dt>
+<dd><a name="index-_002dsd"></a>
+<p>Use <var>file</var> as SecureDigital card image.
+</p></dd>
+<dt><samp>-pflash <var>file</var></samp></dt>
+<dd><a name="index-_002dpflash"></a>
+<p>Use <var>file</var> as a parallel flash image.
+</p></dd>
+<dt><samp>-snapshot</samp></dt>
+<dd><a name="index-_002dsnapshot"></a>
+<p>Write to temporary files instead of disk image files. In this case,
+the raw disk image you use is not written back. You can however force
+the write back by pressing <tt class="key">C-a s</tt> (see <a href="#disk_005fimages">disk_images</a>).
+</p></dd>
+<dt><samp>-hdachs <var>c</var>,<var>h</var>,<var>s</var>,[,<var>t</var>]</samp></dt>
+<dd><a name="index-_002dhdachs"></a>
+<p>Force hard disk 0 physical geometry (1 &lt;= <var>c</var> &lt;= 16383, 1 &lt;=
+<var>h</var> &lt;= 16, 1 &lt;= <var>s</var> &lt;= 63) and optionally force the BIOS
+translation mode (<var>t</var>=none, lba or auto). Usually QEMU can guess
+all those parameters. This option is useful for old MS-DOS disk
+images.
+</p>
+</dd>
+<dt><samp>-fsdev <var>fsdriver</var>,id=<var>id</var>,path=<var>path</var>,[security_model=<var>security_model</var>][,writeout=<var>writeout</var>][,readonly][,socket=<var>socket</var>|sock_fd=<var>sock_fd</var>]</samp></dt>
+<dd><a name="index-_002dfsdev"></a>
+<p>Define a new file system device. Valid options are:
+</p><dl compact="compact">
+<dt><samp><var>fsdriver</var></samp></dt>
+<dd><p>This option specifies the fs driver backend to use.
+Currently &quot;local&quot;, &quot;handle&quot; and &quot;proxy&quot; file system drivers are supported.
+</p></dd>
+<dt><samp>id=<var>id</var></samp></dt>
+<dd><p>Specifies identifier for this device
+</p></dd>
+<dt><samp>path=<var>path</var></samp></dt>
+<dd><p>Specifies the export path for the file system device. Files under
+this path will be available to the 9p client on the guest.
+</p></dd>
+<dt><samp>security_model=<var>security_model</var></samp></dt>
+<dd><p>Specifies the security model to be used for this export path.
+Supported security models are &quot;passthrough&quot;, &quot;mapped-xattr&quot;, &quot;mapped-file&quot; and &quot;none&quot;.
+In &quot;passthrough&quot; security model, files are stored using the same
+credentials as they are created on the guest. This requires QEMU
+to run as root. In &quot;mapped-xattr&quot; security model, some of the file
+attributes like uid, gid, mode bits and link target are stored as
+file attributes. For &quot;mapped-file&quot; these attributes are stored in the
+hidden .virtfs_metadata directory. Directories exported by this security model cannot
+interact with other unix tools. &quot;none&quot; security model is same as
+passthrough except the sever won&rsquo;t report failures if it fails to
+set file attributes like ownership. Security model is mandatory
+only for local fsdriver. Other fsdrivers (like handle, proxy) don&rsquo;t take
+security model as a parameter.
+</p></dd>
+<dt><samp>writeout=<var>writeout</var></samp></dt>
+<dd><p>This is an optional argument. The only supported value is &quot;immediate&quot;.
+This means that host page cache will be used to read and write data but
+write notification will be sent to the guest only when the data has been
+reported as written by the storage subsystem.
+</p></dd>
+<dt><samp>readonly</samp></dt>
+<dd><p>Enables exporting 9p share as a readonly mount for guests. By default
+read-write access is given.
+</p></dd>
+<dt><samp>socket=<var>socket</var></samp></dt>
+<dd><p>Enables proxy filesystem driver to use passed socket file for communicating
+with virtfs-proxy-helper
+</p></dd>
+<dt><samp>sock_fd=<var>sock_fd</var></samp></dt>
+<dd><p>Enables proxy filesystem driver to use passed socket descriptor for
+communicating with virtfs-proxy-helper. Usually a helper like libvirt
+will create socketpair and pass one of the fds as sock_fd
+</p></dd>
+</dl>
+
+<p>-fsdev option is used along with -device driver &quot;virtio-9p-pci&quot;.
+</p></dd>
+<dt><samp>-device virtio-9p-pci,fsdev=<var>id</var>,mount_tag=<var>mount_tag</var></samp></dt>
+<dd><p>Options for virtio-9p-pci driver are:
+</p><dl compact="compact">
+<dt><samp>fsdev=<var>id</var></samp></dt>
+<dd><p>Specifies the id value specified along with -fsdev option
+</p></dd>
+<dt><samp>mount_tag=<var>mount_tag</var></samp></dt>
+<dd><p>Specifies the tag name to be used by the guest to mount this export point
+</p></dd>
+</dl>
+
+
+</dd>
+<dt><samp>-virtfs <var>fsdriver</var>[,path=<var>path</var>],mount_tag=<var>mount_tag</var>[,security_model=<var>security_model</var>][,writeout=<var>writeout</var>][,readonly][,socket=<var>socket</var>|sock_fd=<var>sock_fd</var>]</samp></dt>
+<dd><a name="index-_002dvirtfs"></a>
+
+<p>The general form of a Virtual File system pass-through options are:
+</p><dl compact="compact">
+<dt><samp><var>fsdriver</var></samp></dt>
+<dd><p>This option specifies the fs driver backend to use.
+Currently &quot;local&quot;, &quot;handle&quot; and &quot;proxy&quot; file system drivers are supported.
+</p></dd>
+<dt><samp>id=<var>id</var></samp></dt>
+<dd><p>Specifies identifier for this device
+</p></dd>
+<dt><samp>path=<var>path</var></samp></dt>
+<dd><p>Specifies the export path for the file system device. Files under
+this path will be available to the 9p client on the guest.
+</p></dd>
+<dt><samp>security_model=<var>security_model</var></samp></dt>
+<dd><p>Specifies the security model to be used for this export path.
+Supported security models are &quot;passthrough&quot;, &quot;mapped-xattr&quot;, &quot;mapped-file&quot; and &quot;none&quot;.
+In &quot;passthrough&quot; security model, files are stored using the same
+credentials as they are created on the guest. This requires QEMU
+to run as root. In &quot;mapped-xattr&quot; security model, some of the file
+attributes like uid, gid, mode bits and link target are stored as
+file attributes. For &quot;mapped-file&quot; these attributes are stored in the
+hidden .virtfs_metadata directory. Directories exported by this security model cannot
+interact with other unix tools. &quot;none&quot; security model is same as
+passthrough except the sever won&rsquo;t report failures if it fails to
+set file attributes like ownership. Security model is mandatory only
+for local fsdriver. Other fsdrivers (like handle, proxy) don&rsquo;t take security
+model as a parameter.
+</p></dd>
+<dt><samp>writeout=<var>writeout</var></samp></dt>
+<dd><p>This is an optional argument. The only supported value is &quot;immediate&quot;.
+This means that host page cache will be used to read and write data but
+write notification will be sent to the guest only when the data has been
+reported as written by the storage subsystem.
+</p></dd>
+<dt><samp>readonly</samp></dt>
+<dd><p>Enables exporting 9p share as a readonly mount for guests. By default
+read-write access is given.
+</p></dd>
+<dt><samp>socket=<var>socket</var></samp></dt>
+<dd><p>Enables proxy filesystem driver to use passed socket file for
+communicating with virtfs-proxy-helper. Usually a helper like libvirt
+will create socketpair and pass one of the fds as sock_fd
+</p></dd>
+<dt><samp>sock_fd</samp></dt>
+<dd><p>Enables proxy filesystem driver to use passed &rsquo;sock_fd&rsquo; as the socket
+descriptor for interfacing with virtfs-proxy-helper
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-virtfs_synth</samp></dt>
+<dd><a name="index-_002dvirtfs_005fsynth"></a>
+<p>Create synthetic file system image
+</p></dd>
+</dl>
+
+<p>USB options:
+</p><dl compact="compact">
+<dt><samp>-usb</samp></dt>
+<dd><a name="index-_002dusb"></a>
+<p>Enable the USB driver (will be the default soon)
+</p>
+</dd>
+<dt><samp>-usbdevice <var>devname</var></samp></dt>
+<dd><a name="index-_002dusbdevice"></a>
+<p>Add the USB device <var>devname</var>. See <a href="#usb_005fdevices">usb_devices</a>.
+</p>
+<dl compact="compact">
+<dt><samp>mouse</samp></dt>
+<dd><p>Virtual Mouse. This will override the PS/2 mouse emulation when activated.
+</p>
+</dd>
+<dt><samp>tablet</samp></dt>
+<dd><p>Pointer device that uses absolute coordinates (like a touchscreen). This
+means QEMU is able to report the mouse position without having to grab the
+mouse. Also overrides the PS/2 mouse emulation when activated.
+</p>
+</dd>
+<dt><samp>disk:[format=<var>format</var>]:<var>file</var></samp></dt>
+<dd><p>Mass storage device based on file. The optional <var>format</var> argument
+will be used rather than detecting the format. Can be used to specifiy
+<code>format=raw</code> to avoid interpreting an untrusted format header.
+</p>
+</dd>
+<dt><samp>host:<var>bus</var>.<var>addr</var></samp></dt>
+<dd><p>Pass through the host device identified by <var>bus</var>.<var>addr</var> (Linux only).
+</p>
+</dd>
+<dt><samp>host:<var>vendor_id</var>:<var>product_id</var></samp></dt>
+<dd><p>Pass through the host device identified by <var>vendor_id</var>:<var>product_id</var>
+(Linux only).
+</p>
+</dd>
+<dt><samp>serial:[vendorid=<var>vendor_id</var>][,productid=<var>product_id</var>]:<var>dev</var></samp></dt>
+<dd><p>Serial converter to host character device <var>dev</var>, see <code>-serial</code> for the
+available devices.
+</p>
+</dd>
+<dt><samp>braille</samp></dt>
+<dd><p>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+</p>
+</dd>
+<dt><samp>net:<var>options</var></samp></dt>
+<dd><p>Network adapter that supports CDC ethernet and RNDIS protocols.
+</p>
+</dd>
+</dl>
+</dd>
+</dl>
+
+<p>Display options:
+</p><dl compact="compact">
+<dt><samp>-display <var>type</var></samp></dt>
+<dd><a name="index-_002ddisplay"></a>
+<p>Select type of display to use. This option is a replacement for the
+old style -sdl/-curses/... options. Valid values for <var>type</var> are
+</p><dl compact="compact">
+<dt><samp>sdl</samp></dt>
+<dd><p>Display video output via SDL (usually in a separate graphics
+window; see the SDL documentation for other possibilities).
+</p></dd>
+<dt><samp>curses</samp></dt>
+<dd><p>Display video output via curses. For graphics device models which
+support a text mode, QEMU can display this output using a
+curses/ncurses interface. Nothing is displayed when the graphics
+device is in graphical mode or if the graphics device does not support
+a text mode. Generally only the VGA device models support text mode.
+</p></dd>
+<dt><samp>none</samp></dt>
+<dd><p>Do not display video output. The guest will still see an emulated
+graphics card, but its output will not be displayed to the QEMU
+user. This option differs from the -nographic option in that it
+only affects what is done with video output; -nographic also changes
+the destination of the serial and parallel port data.
+</p></dd>
+<dt><samp>gtk</samp></dt>
+<dd><p>Display video output in a GTK window. This interface provides drop-down
+menus and other UI elements to configure and control the VM during
+runtime.
+</p></dd>
+<dt><samp>vnc</samp></dt>
+<dd><p>Start a VNC server on display &lt;arg&gt;
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-nographic</samp></dt>
+<dd><a name="index-_002dnographic"></a>
+<p>Normally, QEMU uses SDL to display the VGA output. With this option,
+you can totally disable graphical output so that QEMU is a simple
+command line application. The emulated serial port is redirected on
+the console and muxed with the monitor (unless redirected elsewhere
+explicitly). Therefore, you can still use QEMU to debug a Linux kernel
+with a serial console.  Use <tt class="key">C-a h</tt> for help on switching between
+the console and monitor.
+</p></dd>
+<dt><samp>-curses</samp></dt>
+<dd><a name="index-_002dcurses"></a>
+<p>Normally, QEMU uses SDL to display the VGA output.  With this option,
+QEMU can display the VGA output when in text mode using a
+curses/ncurses interface.  Nothing is displayed in graphical mode.
+</p></dd>
+<dt><samp>-no-frame</samp></dt>
+<dd><a name="index-_002dno_002dframe"></a>
+<p>Do not use decorations for SDL windows and start them using the whole
+available screen space. This makes the using QEMU in a dedicated desktop
+workspace more convenient.
+</p></dd>
+<dt><samp>-alt-grab</samp></dt>
+<dd><a name="index-_002dalt_002dgrab"></a>
+<p>Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note that this also
+affects the special keys (for fullscreen, monitor-mode switching, etc).
+</p></dd>
+<dt><samp>-ctrl-grab</samp></dt>
+<dd><a name="index-_002dctrl_002dgrab"></a>
+<p>Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note that this also
+affects the special keys (for fullscreen, monitor-mode switching, etc).
+</p></dd>
+<dt><samp>-no-quit</samp></dt>
+<dd><a name="index-_002dno_002dquit"></a>
+<p>Disable SDL window close capability.
+</p></dd>
+<dt><samp>-sdl</samp></dt>
+<dd><a name="index-_002dsdl"></a>
+<p>Enable SDL.
+</p></dd>
+<dt><samp>-spice <var>option</var>[,<var>option</var>[,...]]</samp></dt>
+<dd><a name="index-_002dspice"></a>
+<p>Enable the spice remote desktop protocol. Valid options are
+</p>
+<dl compact="compact">
+<dt><samp>port=&lt;nr&gt;</samp></dt>
+<dd><p>Set the TCP port spice is listening on for plaintext channels.
+</p>
+</dd>
+<dt><samp>addr=&lt;addr&gt;</samp></dt>
+<dd><p>Set the IP address spice is listening on.  Default is any address.
+</p>
+</dd>
+<dt><samp>ipv4</samp></dt>
+<dt><samp>ipv6</samp></dt>
+<dt><samp>unix</samp></dt>
+<dd><p>Force using the specified IP version.
+</p>
+</dd>
+<dt><samp>password=&lt;secret&gt;</samp></dt>
+<dd><p>Set the password you need to authenticate.
+</p>
+</dd>
+<dt><samp>sasl</samp></dt>
+<dd><p>Require that the client use SASL to authenticate with the spice.
+The exact choice of authentication method used is controlled from the
+system / user&rsquo;s SASL configuration file for the &rsquo;qemu&rsquo; service. This
+is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config.
+While some SASL auth methods can also provide data encryption (eg GSSAPI),
+it is recommended that SASL always be combined with the &rsquo;tls&rsquo; and
+&rsquo;x509&rsquo; settings to enable use of SSL and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials.
+</p>
+</dd>
+<dt><samp>disable-ticketing</samp></dt>
+<dd><p>Allow client connects without authentication.
+</p>
+</dd>
+<dt><samp>disable-copy-paste</samp></dt>
+<dd><p>Disable copy paste between the client and the guest.
+</p>
+</dd>
+<dt><samp>disable-agent-file-xfer</samp></dt>
+<dd><p>Disable spice-vdagent based file-xfer between the client and the guest.
+</p>
+</dd>
+<dt><samp>tls-port=&lt;nr&gt;</samp></dt>
+<dd><p>Set the TCP port spice is listening on for encrypted channels.
+</p>
+</dd>
+<dt><samp>x509-dir=&lt;dir&gt;</samp></dt>
+<dd><p>Set the x509 file directory. Expects same filenames as -vnc $display,x509=$dir
+</p>
+</dd>
+<dt><samp>x509-key-file=&lt;file&gt;</samp></dt>
+<dt><samp>x509-key-password=&lt;file&gt;</samp></dt>
+<dt><samp>x509-cert-file=&lt;file&gt;</samp></dt>
+<dt><samp>x509-cacert-file=&lt;file&gt;</samp></dt>
+<dt><samp>x509-dh-key-file=&lt;file&gt;</samp></dt>
+<dd><p>The x509 file names can also be configured individually.
+</p>
+</dd>
+<dt><samp>tls-ciphers=&lt;list&gt;</samp></dt>
+<dd><p>Specify which ciphers to use.
+</p>
+</dd>
+<dt><samp>tls-channel=[main|display|cursor|inputs|record|playback]</samp></dt>
+<dt><samp>plaintext-channel=[main|display|cursor|inputs|record|playback]</samp></dt>
+<dd><p>Force specific channel to be used with or without TLS encryption.  The
+options can be specified multiple times to configure multiple
+channels.  The special name &quot;default&quot; can be used to set the default
+mode.  For channels which are not explicitly forced into one mode the
+spice client is allowed to pick tls/plaintext as he pleases.
+</p>
+</dd>
+<dt><samp>image-compression=[auto_glz|auto_lz|quic|glz|lz|off]</samp></dt>
+<dd><p>Configure image compression (lossless).
+Default is auto_glz.
+</p>
+</dd>
+<dt><samp>jpeg-wan-compression=[auto|never|always]</samp></dt>
+<dt><samp>zlib-glz-wan-compression=[auto|never|always]</samp></dt>
+<dd><p>Configure wan image compression (lossy for slow links).
+Default is auto.
+</p>
+</dd>
+<dt><samp>streaming-video=[off|all|filter]</samp></dt>
+<dd><p>Configure video stream detection.  Default is filter.
+</p>
+</dd>
+<dt><samp>agent-mouse=[on|off]</samp></dt>
+<dd><p>Enable/disable passing mouse events via vdagent.  Default is on.
+</p>
+</dd>
+<dt><samp>playback-compression=[on|off]</samp></dt>
+<dd><p>Enable/disable audio stream compression (using celt 0.5.1).  Default is on.
+</p>
+</dd>
+<dt><samp>seamless-migration=[on|off]</samp></dt>
+<dd><p>Enable/disable spice seamless migration. Default is off.
+</p>
+</dd>
+</dl>
+</dd>
+<dt><samp>-portrait</samp></dt>
+<dd><a name="index-_002dportrait"></a>
+<p>Rotate graphical output 90 deg left (only PXA LCD).
+</p></dd>
+<dt><samp>-rotate <var>deg</var></samp></dt>
+<dd><a name="index-_002drotate"></a>
+<p>Rotate graphical output some deg left (only PXA LCD).
+</p></dd>
+<dt><samp>-vga <var>type</var></samp></dt>
+<dd><a name="index-_002dvga"></a>
+<p>Select type of VGA card to emulate. Valid values for <var>type</var> are
+</p><dl compact="compact">
+<dt><samp>cirrus</samp></dt>
+<dd><p>Cirrus Logic GD5446 Video card. All Windows versions starting from
+Windows 95 should recognize and use this graphic card. For optimal
+performances, use 16 bit color depth in the guest and the host OS.
+(This one is the default)
+</p></dd>
+<dt><samp>std</samp></dt>
+<dd><p>Standard VGA card with Bochs VBE extensions.  If your guest OS
+supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want
+to use high resolution modes (&gt;= 1280x1024x16) then you should use
+this option.
+</p></dd>
+<dt><samp>vmware</samp></dt>
+<dd><p>VMWare SVGA-II compatible adapter. Use it if you have sufficiently
+recent XFree86/XOrg server or Windows guest with a driver for this
+card.
+</p></dd>
+<dt><samp>qxl</samp></dt>
+<dd><p>QXL paravirtual graphic card.  It is VGA compatible (including VESA
+2.0 VBE support).  Works best with qxl guest drivers installed though.
+Recommended choice when using the spice protocol.
+</p></dd>
+<dt><samp>tcx</samp></dt>
+<dd><p>(sun4m only) Sun TCX framebuffer. This is the default framebuffer for
+sun4m machines and offers both 8-bit and 24-bit colour depths at a
+fixed resolution of 1024x768.
+</p></dd>
+<dt><samp>cg3</samp></dt>
+<dd><p>(sun4m only) Sun cgthree framebuffer. This is a simple 8-bit framebuffer
+for sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900 (OBP)
+resolutions aimed at people wishing to run older Solaris versions.
+</p></dd>
+<dt><samp>none</samp></dt>
+<dd><p>Disable VGA card.
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-full-screen</samp></dt>
+<dd><a name="index-_002dfull_002dscreen"></a>
+<p>Start in full screen.
+</p></dd>
+<dt><samp>-g <var>width</var>x<var>height</var>[x<var>depth</var>]</samp></dt>
+<dd><a name="index-_002dg"></a>
+<p>Set the initial graphical resolution and depth (PPC, SPARC only).
+</p></dd>
+<dt><samp>-vnc <var>display</var>[,<var>option</var>[,<var>option</var>[,...]]]</samp></dt>
+<dd><a name="index-_002dvnc"></a>
+<p>Normally, QEMU uses SDL to display the VGA output.  With this option,
+you can have QEMU listen on VNC display <var>display</var> and redirect the VGA
+display over the VNC session.  It is very useful to enable the usb
+tablet device when using this option (option <samp>-usbdevice
+tablet</samp>). When using the VNC display, you must use the <samp>-k</samp>
+parameter to set the keyboard layout if you are not using en-us. Valid
+syntax for the <var>display</var> is
+</p>
+<dl compact="compact">
+<dt><samp><var>host</var>:<var>d</var></samp></dt>
+<dd>
+<p>TCP connections will only be allowed from <var>host</var> on display <var>d</var>.
+By convention the TCP port is 5900+<var>d</var>. Optionally, <var>host</var> can
+be omitted in which case the server will accept connections from any host.
+</p>
+</dd>
+<dt><samp>unix:<var>path</var></samp></dt>
+<dd>
+<p>Connections will be allowed over UNIX domain sockets where <var>path</var> is the
+location of a unix socket to listen for connections on.
+</p>
+</dd>
+<dt><samp>none</samp></dt>
+<dd>
+<p>VNC is initialized but not started. The monitor <code>change</code> command
+can be used to later start the VNC server.
+</p>
+</dd>
+</dl>
+
+<p>Following the <var>display</var> value there may be one or more <var>option</var> flags
+separated by commas. Valid options are
+</p>
+<dl compact="compact">
+<dt><samp>reverse</samp></dt>
+<dd>
+<p>Connect to a listening VNC client via a &ldquo;reverse&rdquo; connection. The
+client is specified by the <var>display</var>. For reverse network
+connections (<var>host</var>:<var>d</var>,<code>reverse</code>), the <var>d</var> argument
+is a TCP port number, not a display number.
+</p>
+</dd>
+<dt><samp>websocket</samp></dt>
+<dd>
+<p>Opens an additional TCP listening port dedicated to VNC Websocket connections.
+By definition the Websocket port is 5700+<var>display</var>. If <var>host</var> is
+specified connections will only be allowed from this host.
+As an alternative the Websocket port could be specified by using
+<code>websocket</code>=<var>port</var>.
+TLS encryption for the Websocket connection is supported if the required
+certificates are specified with the VNC option <samp>x509</samp>.
+</p>
+</dd>
+<dt><samp>password</samp></dt>
+<dd>
+<p>Require that password based authentication is used for client connections.
+</p>
+<p>The password must be set separately using the <code>set_password</code> command in
+the <a href="#pcsys_005fmonitor">pcsys_monitor</a>. The syntax to change your password is:
+<code>set_password &lt;protocol&gt; &lt;password&gt;</code> where &lt;protocol&gt; could be either
+&quot;vnc&quot; or &quot;spice&quot;.
+</p>
+<p>If you would like to change &lt;protocol&gt; password expiration, you should use
+<code>expire_password &lt;protocol&gt; &lt;expiration-time&gt;</code> where expiration time could
+be one of the following options: now, never, +seconds or UNIX time of
+expiration, e.g. +60 to make password expire in 60 seconds, or 1335196800
+to make password expire on &quot;Mon Apr 23 12:00:00 EDT 2012&quot; (UNIX time for this
+date and time).
+</p>
+<p>You can also use keywords &quot;now&quot; or &quot;never&quot; for the expiration time to
+allow &lt;protocol&gt; password to expire immediately or never expire.
+</p>
+</dd>
+<dt><samp>tls</samp></dt>
+<dd>
+<p>Require that client use TLS when communicating with the VNC server. This
+uses anonymous TLS credentials so is susceptible to a man-in-the-middle
+attack. It is recommended that this option be combined with either the
+<samp>x509</samp> or <samp>x509verify</samp> options.
+</p>
+</dd>
+<dt><samp>x509=<var>/path/to/certificate/dir</var></samp></dt>
+<dd>
+<p>Valid if <samp>tls</samp> is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client. It is recommended that a password be set on the VNC server
+to provide authentication of the client when this is used. The path following
+this option specifies where the x509 certificates are to be loaded from.
+See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on generating certificates.
+</p>
+</dd>
+<dt><samp>x509verify=<var>/path/to/certificate/dir</var></samp></dt>
+<dd>
+<p>Valid if <samp>tls</samp> is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client, and request that the client send its own x509 certificate.
+The server will validate the client&rsquo;s certificate against the CA certificate,
+and reject clients when validation fails. If the certificate authority is
+trusted, this is a sufficient authentication mechanism. You may still wish
+to set a password on the VNC server as a second authentication layer. The
+path following this option specifies where the x509 certificates are to
+be loaded from. See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on generating
+certificates.
+</p>
+</dd>
+<dt><samp>sasl</samp></dt>
+<dd>
+<p>Require that the client use SASL to authenticate with the VNC server.
+The exact choice of authentication method used is controlled from the
+system / user&rsquo;s SASL configuration file for the &rsquo;qemu&rsquo; service. This
+is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config.
+While some SASL auth methods can also provide data encryption (eg GSSAPI),
+it is recommended that SASL always be combined with the &rsquo;tls&rsquo; and
+&rsquo;x509&rsquo; settings to enable use of SSL and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials. See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on using
+SASL authentication.
+</p>
+</dd>
+<dt><samp>acl</samp></dt>
+<dd>
+<p>Turn on access control lists for checking of the x509 client certificate
+and SASL party. For x509 certs, the ACL check is made against the
+certificate&rsquo;s distinguished name. This is something that looks like
+<code>C=GB,O=ACME,L=Boston,CN=bob</code>. For SASL party, the ACL check is
+made against the username, which depending on the SASL plugin, may
+include a realm component, eg <code>bob</code> or <code>bob@EXAMPLE.COM</code>.
+When the <samp>acl</samp> flag is set, the initial access list will be
+empty, with a <code>deny</code> policy. Thus no one will be allowed to
+use the VNC server until the ACLs have been loaded. This can be
+achieved using the <code>acl</code> monitor command.
+</p>
+</dd>
+<dt><samp>lossy</samp></dt>
+<dd>
+<p>Enable lossy compression methods (gradient, JPEG, ...). If this
+option is set, VNC client may receive lossy framebuffer updates
+depending on its encoding settings. Enabling this option can save
+a lot of bandwidth at the expense of quality.
+</p>
+</dd>
+<dt><samp>non-adaptive</samp></dt>
+<dd>
+<p>Disable adaptive encodings. Adaptive encodings are enabled by default.
+An adaptive encoding will try to detect frequently updated screen regions,
+and send updates in these regions using a lossy encoding (like JPEG).
+This can be really helpful to save bandwidth when playing videos. Disabling
+adaptive encodings restores the original static behavior of encodings
+like Tight.
+</p>
+</dd>
+<dt><samp>share=[allow-exclusive|force-shared|ignore]</samp></dt>
+<dd>
+<p>Set display sharing policy.  &rsquo;allow-exclusive&rsquo; allows clients to ask
+for exclusive access.  As suggested by the rfb spec this is
+implemented by dropping other connections.  Connecting multiple
+clients in parallel requires all clients asking for a shared session
+(vncviewer: -shared switch).  This is the default.  &rsquo;force-shared&rsquo;
+disables exclusive client access.  Useful for shared desktop sessions,
+where you don&rsquo;t want someone forgetting specify -shared disconnect
+everybody else.  &rsquo;ignore&rsquo; completely ignores the shared flag and
+allows everybody connect unconditionally.  Doesn&rsquo;t conform to the rfb
+spec but is traditional QEMU behavior.
+</p>
+</dd>
+</dl>
+</dd>
+</dl>
+
+<p>i386 target only:
+</p><dl compact="compact">
+<dt><samp>-win2k-hack</samp></dt>
+<dd><a name="index-_002dwin2k_002dhack"></a>
+<p>Use it when installing Windows 2000 to avoid a disk full bug. After
+Windows 2000 is installed, you no longer need this option (this option
+slows down the IDE transfers).
+</p></dd>
+<dt><samp>-no-fd-bootchk</samp></dt>
+<dd><a name="index-_002dno_002dfd_002dbootchk"></a>
+<p>Disable boot signature checking for floppy disks in BIOS. May
+be needed to boot from old floppy disks.
+</p></dd>
+<dt><samp>-no-acpi</samp></dt>
+<dd><a name="index-_002dno_002dacpi"></a>
+<p>Disable ACPI (Advanced Configuration and Power Interface) support. Use
+it if your guest OS complains about ACPI problems (PC target machine
+only).
+</p></dd>
+<dt><samp>-no-hpet</samp></dt>
+<dd><a name="index-_002dno_002dhpet"></a>
+<p>Disable HPET support.
+</p></dd>
+<dt><samp>-acpitable [sig=<var>str</var>][,rev=<var>n</var>][,oem_id=<var>str</var>][,oem_table_id=<var>str</var>][,oem_rev=<var>n</var>] [,asl_compiler_id=<var>str</var>][,asl_compiler_rev=<var>n</var>][,data=<var>file1</var>[:<var>file2</var>]...]</samp></dt>
+<dd><a name="index-_002dacpitable"></a>
+<p>Add ACPI table with specified header fields and context from specified files.
+For file=, take whole ACPI table from the specified files, including all
+ACPI headers (possible overridden by other options).
+For data=, only data
+portion of the table is used, all header information is specified in the
+command line.
+</p></dd>
+<dt><samp>-smbios file=<var>binary</var></samp></dt>
+<dd><a name="index-_002dsmbios"></a>
+<p>Load SMBIOS entry from binary file.
+</p>
+</dd>
+<dt><samp>-smbios type=0[,vendor=<var>str</var>][,version=<var>str</var>][,date=<var>str</var>][,release=<var>%d.%d</var>][,uefi=on|off]</samp></dt>
+<dd><p>Specify SMBIOS type 0 fields
+</p>
+</dd>
+<dt><samp>-smbios type=1[,manufacturer=<var>str</var>][,product=<var>str</var>][,version=<var>str</var>][,serial=<var>str</var>][,uuid=<var>uuid</var>][,sku=<var>str</var>][,family=<var>str</var>]</samp></dt>
+<dd><p>Specify SMBIOS type 1 fields
+</p>
+</dd>
+<dt><samp>-smbios type=2[,manufacturer=<var>str</var>][,product=<var>str</var>][,version=<var>str</var>][,serial=<var>str</var>][,asset=<var>str</var>][,location=<var>str</var>][,family=<var>str</var>]</samp></dt>
+<dd><p>Specify SMBIOS type 2 fields
+</p>
+</dd>
+<dt><samp>-smbios type=3[,manufacturer=<var>str</var>][,version=<var>str</var>][,serial=<var>str</var>][,asset=<var>str</var>][,sku=<var>str</var>]</samp></dt>
+<dd><p>Specify SMBIOS type 3 fields
+</p>
+</dd>
+<dt><samp>-smbios type=4[,sock_pfx=<var>str</var>][,manufacturer=<var>str</var>][,version=<var>str</var>][,serial=<var>str</var>][,asset=<var>str</var>][,part=<var>str</var>]</samp></dt>
+<dd><p>Specify SMBIOS type 4 fields
+</p>
+</dd>
+<dt><samp>-smbios type=17[,loc_pfx=<var>str</var>][,bank=<var>str</var>][,manufacturer=<var>str</var>][,serial=<var>str</var>][,asset=<var>str</var>][,part=<var>str</var>][,speed=<var>%d</var>]</samp></dt>
+<dd><p>Specify SMBIOS type 17 fields
+</p></dd>
+</dl>
+
+<p>Network options:
+</p><dl compact="compact">
+<dt><samp>-net nic[,vlan=<var>n</var>][,macaddr=<var>mac</var>][,model=<var>type</var>] [,name=<var>name</var>][,addr=<var>addr</var>][,vectors=<var>v</var>]</samp></dt>
+<dd><a name="index-_002dnet"></a>
+<p>Create a new Network Interface Card and connect it to VLAN <var>n</var> (<var>n</var>
+= 0 is the default). The NIC is an e1000 by default on the PC
+target. Optionally, the MAC address can be changed to <var>mac</var>, the
+device address set to <var>addr</var> (PCI cards only),
+and a <var>name</var> can be assigned for use in monitor commands.
+Optionally, for PCI cards, you can specify the number <var>v</var> of MSI-X vectors
+that the card should have; this option currently only affects virtio cards; set
+<var>v</var> = 0 to disable MSI-X. If no <samp>-net</samp> option is specified, a single
+NIC is created.  QEMU can emulate several different models of network card.
+Valid values for <var>type</var> are
+<code>virtio</code>, <code>i82551</code>, <code>i82557b</code>, <code>i82559er</code>,
+<code>ne2k_pci</code>, <code>ne2k_isa</code>, <code>pcnet</code>, <code>rtl8139</code>,
+<code>e1000</code>, <code>smc91c111</code>, <code>lance</code> and <code>mcf_fec</code>.
+Not all devices are supported on all targets.  Use <code>-net nic,model=help</code>
+for a list of available devices for your target.
+</p>
+</dd>
+<dt><samp>-netdev user,id=<var>id</var>[,<var>option</var>][,<var>option</var>][,...]</samp></dt>
+<dd><a name="index-_002dnetdev"></a>
+</dd>
+<dt><samp>-net user[,<var>option</var>][,<var>option</var>][,...]</samp></dt>
+<dd><p>Use the user mode network stack which requires no administrator
+privilege to run. Valid options are:
+</p>
+<dl compact="compact">
+<dt><samp>vlan=<var>n</var></samp></dt>
+<dd><p>Connect user mode stack to VLAN <var>n</var> (<var>n</var> = 0 is the default).
+</p>
+</dd>
+<dt><samp>id=<var>id</var></samp></dt>
+<dt><samp>name=<var>name</var></samp></dt>
+<dd><p>Assign symbolic name for use in monitor commands.
+</p>
+</dd>
+<dt><samp>net=<var>addr</var>[/<var>mask</var>]</samp></dt>
+<dd><p>Set IP network address the guest will see. Optionally specify the netmask,
+either in the form a.b.c.d or as number of valid top-most bits. Default is
+10.0.2.0/24.
+</p>
+</dd>
+<dt><samp>host=<var>addr</var></samp></dt>
+<dd><p>Specify the guest-visible address of the host. Default is the 2nd IP in the
+guest network, i.e. x.x.x.2.
+</p>
+</dd>
+<dt><samp>restrict=on|off</samp></dt>
+<dd><p>If this option is enabled, the guest will be isolated, i.e. it will not be
+able to contact the host and no guest IP packets will be routed over the host
+to the outside. This option does not affect any explicitly set forwarding rules.
+</p>
+</dd>
+<dt><samp>hostname=<var>name</var></samp></dt>
+<dd><p>Specifies the client hostname reported by the built-in DHCP server.
+</p>
+</dd>
+<dt><samp>dhcpstart=<var>addr</var></samp></dt>
+<dd><p>Specify the first of the 16 IPs the built-in DHCP server can assign. Default
+is the 15th to 31st IP in the guest network, i.e. x.x.x.15 to x.x.x.31.
+</p>
+</dd>
+<dt><samp>dns=<var>addr</var></samp></dt>
+<dd><p>Specify the guest-visible address of the virtual nameserver. The address must
+be different from the host address. Default is the 3rd IP in the guest network,
+i.e. x.x.x.3.
+</p>
+</dd>
+<dt><samp>dnssearch=<var>domain</var></samp></dt>
+<dd><p>Provides an entry for the domain-search list sent by the built-in
+DHCP server. More than one domain suffix can be transmitted by specifying
+this option multiple times. If supported, this will cause the guest to
+automatically try to append the given domain suffix(es) in case a domain name
+can not be resolved.
+</p>
+<p>Example:
+</p><div class="example">
+<pre class="example">qemu -net user,dnssearch=mgmt.example.org,dnssearch=example.org [...]
+</pre></div>
+
+</dd>
+<dt><samp>tftp=<var>dir</var></samp></dt>
+<dd><p>When using the user mode network stack, activate a built-in TFTP
+server. The files in <var>dir</var> will be exposed as the root of a TFTP server.
+The TFTP client on the guest must be configured in binary mode (use the command
+<code>bin</code> of the Unix TFTP client).
+</p>
+</dd>
+<dt><samp>bootfile=<var>file</var></samp></dt>
+<dd><p>When using the user mode network stack, broadcast <var>file</var> as the BOOTP
+filename. In conjunction with <samp>tftp</samp>, this can be used to network boot
+a guest from a local directory.
+</p>
+<p>Example (using pxelinux):
+</p><div class="example">
+<pre class="example">qemu-system-i386 -hda linux.img -boot n -net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
+</pre></div>
+
+</dd>
+<dt><samp>smb=<var>dir</var>[,smbserver=<var>addr</var>]</samp></dt>
+<dd><p>When using the user mode network stack, activate a built-in SMB
+server so that Windows OSes can access to the host files in <samp><var>dir</var></samp>
+transparently. The IP address of the SMB server can be set to <var>addr</var>. By
+default the 4th IP in the guest network is used, i.e. x.x.x.4.
+</p>
+<p>In the guest Windows OS, the line:
+</p><div class="example">
+<pre class="example">10.0.2.4 smbserver
+</pre></div>
+<p>must be added in the file <samp>C:\WINDOWS\LMHOSTS</samp> (for windows 9x/Me)
+or <samp>C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS</samp> (Windows NT/2000).
+</p>
+<p>Then <samp><var>dir</var></samp> can be accessed in <samp>\smbserver\qemu</samp>.
+</p>
+<p>Note that a SAMBA server must be installed on the host OS.
+QEMU was tested successfully with smbd versions from Red Hat 9,
+Fedora Core 3 and OpenSUSE 11.x.
+</p>
+</dd>
+<dt><samp>hostfwd=[tcp|udp]:[<var>hostaddr</var>]:<var>hostport</var>-[<var>guestaddr</var>]:<var>guestport</var></samp></dt>
+<dd><p>Redirect incoming TCP or UDP connections to the host port <var>hostport</var> to
+the guest IP address <var>guestaddr</var> on guest port <var>guestport</var>. If
+<var>guestaddr</var> is not specified, its value is x.x.x.15 (default first address
+given by the built-in DHCP server). By specifying <var>hostaddr</var>, the rule can
+be bound to a specific host interface. If no connection type is set, TCP is
+used. This option can be given multiple times.
+</p>
+<p>For example, to redirect host X11 connection from screen 1 to guest
+screen 0, use the following:
+</p>
+<div class="example">
+<pre class="example"># on the host
+qemu-system-i386 -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]
+# this host xterm should open in the guest X11 server
+xterm -display :1
+</pre></div>
+
+<p>To redirect telnet connections from host port 5555 to telnet port on
+the guest, use the following:
+</p>
+<div class="example">
+<pre class="example"># on the host
+qemu-system-i386 -net user,hostfwd=tcp::5555-:23 [...]
+telnet localhost 5555
+</pre></div>
+
+<p>Then when you use on the host <code>telnet localhost 5555</code>, you
+connect to the guest telnet server.
+</p>
+</dd>
+<dt><samp>guestfwd=[tcp]:<var>server</var>:<var>port</var>-<var>dev</var></samp></dt>
+<dt><samp>guestfwd=[tcp]:<var>server</var>:<var>port</var>-<var>cmd:command</var></samp></dt>
+<dd><p>Forward guest TCP connections to the IP address <var>server</var> on port <var>port</var>
+to the character device <var>dev</var> or to a program executed by <var>cmd:command</var>
+which gets spawned for each connection. This option can be given multiple times.
+</p>
+<p>You can either use a chardev directly and have that one used throughout QEMU&rsquo;s
+lifetime, like in the following example:
+</p>
+<div class="example">
+<pre class="example"># open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
+# the guest accesses it
+qemu -net user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321 [...]
+</pre></div>
+
+<p>Or you can execute a command on every TCP connection established by the guest,
+so that QEMU behaves similar to an inetd process for that virtual server:
+</p>
+<div class="example">
+<pre class="example"># call &quot;netcat 10.10.1.1 4321&quot; on every TCP connection to 10.0.2.100:1234
+# and connect the TCP stream to its stdin/stdout
+qemu -net 'user,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'
+</pre></div>
+
+</dd>
+</dl>
+
+<p>Note: Legacy stand-alone options -tftp, -bootp, -smb and -redir are still
+processed and applied to -net user. Mixing them with the new configuration
+syntax gives undefined results. Their use for new applications is discouraged
+as they will be removed from future versions.
+</p>
+</dd>
+<dt><samp>-netdev tap,id=<var>id</var>[,fd=<var>h</var>][,ifname=<var>name</var>][,script=<var>file</var>][,downscript=<var>dfile</var>][,helper=<var>helper</var>]</samp></dt>
+<dt><samp>-net tap[,vlan=<var>n</var>][,name=<var>name</var>][,fd=<var>h</var>][,ifname=<var>name</var>][,script=<var>file</var>][,downscript=<var>dfile</var>][,helper=<var>helper</var>]</samp></dt>
+<dd><p>Connect the host TAP network interface <var>name</var> to VLAN <var>n</var>.
+</p>
+<p>Use the network script <var>file</var> to configure it and the network script
+<var>dfile</var> to deconfigure it. If <var>name</var> is not provided, the OS
+automatically provides one. The default network configure script is
+<samp>/etc/qemu-ifup</samp> and the default network deconfigure script is
+<samp>/etc/qemu-ifdown</samp>. Use <samp>script=no</samp> or <samp>downscript=no</samp>
+to disable script execution.
+</p>
+<p>If running QEMU as an unprivileged user, use the network helper
+<var>helper</var> to configure the TAP interface. The default network
+helper executable is <samp>/path/to/qemu-bridge-helper</samp>.
+</p>
+<p><samp>fd</samp>=<var>h</var> can be used to specify the handle of an already
+opened host TAP interface.
+</p>
+<p>Examples:
+</p>
+<div class="example">
+<pre class="example">#launch a QEMU instance with the default network script
+qemu-system-i386 linux.img -net nic -net tap
+</pre></div>
+
+<div class="example">
+<pre class="example">#launch a QEMU instance with two NICs, each one connected
+#to a TAP device
+qemu-system-i386 linux.img \
+-net nic,vlan=0 -net tap,vlan=0,ifname=tap0 \
+-net nic,vlan=1 -net tap,vlan=1,ifname=tap1
+</pre></div>
+
+<div class="example">
+<pre class="example">#launch a QEMU instance with the default network helper to
+#connect a TAP device to bridge br0
+qemu-system-i386 linux.img \
+-net nic -net tap,&quot;helper=/path/to/qemu-bridge-helper&quot;
+</pre></div>
+
+</dd>
+<dt><samp>-netdev bridge,id=<var>id</var>[,br=<var>bridge</var>][,helper=<var>helper</var>]</samp></dt>
+<dt><samp>-net bridge[,vlan=<var>n</var>][,name=<var>name</var>][,br=<var>bridge</var>][,helper=<var>helper</var>]</samp></dt>
+<dd><p>Connect a host TAP network interface to a host bridge device.
+</p>
+<p>Use the network helper <var>helper</var> to configure the TAP interface and
+attach it to the bridge. The default network helper executable is
+<samp>/path/to/qemu-bridge-helper</samp> and the default bridge
+device is <samp>br0</samp>.
+</p>
+<p>Examples:
+</p>
+<div class="example">
+<pre class="example">#launch a QEMU instance with the default network helper to
+#connect a TAP device to bridge br0
+qemu-system-i386 linux.img -net bridge -net nic,model=virtio
+</pre></div>
+
+<div class="example">
+<pre class="example">#launch a QEMU instance with the default network helper to
+#connect a TAP device to bridge qemubr0
+qemu-system-i386 linux.img -net bridge,br=qemubr0 -net nic,model=virtio
+</pre></div>
+
+</dd>
+<dt><samp>-netdev socket,id=<var>id</var>[,fd=<var>h</var>][,listen=[<var>host</var>]:<var>port</var>][,connect=<var>host</var>:<var>port</var>]</samp></dt>
+<dt><samp>-net socket[,vlan=<var>n</var>][,name=<var>name</var>][,fd=<var>h</var>] [,listen=[<var>host</var>]:<var>port</var>][,connect=<var>host</var>:<var>port</var>]</samp></dt>
+<dd>
+<p>Connect the VLAN <var>n</var> to a remote VLAN in another QEMU virtual
+machine using a TCP socket connection. If <samp>listen</samp> is
+specified, QEMU waits for incoming connections on <var>port</var>
+(<var>host</var> is optional). <samp>connect</samp> is used to connect to
+another QEMU instance using the <samp>listen</samp> option. <samp>fd</samp>=<var>h</var>
+specifies an already opened TCP socket.
+</p>
+<p>Example:
+</p><div class="example">
+<pre class="example"># launch a first QEMU instance
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:56 \
+-net socket,listen=:1234
+# connect the VLAN 0 of this instance to the VLAN 0
+# of the first instance
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:57 \
+-net socket,connect=127.0.0.1:1234
+</pre></div>
+
+</dd>
+<dt><samp>-netdev socket,id=<var>id</var>[,fd=<var>h</var>][,mcast=<var>maddr</var>:<var>port</var>[,localaddr=<var>addr</var>]]</samp></dt>
+<dt><samp>-net socket[,vlan=<var>n</var>][,name=<var>name</var>][,fd=<var>h</var>][,mcast=<var>maddr</var>:<var>port</var>[,localaddr=<var>addr</var>]]</samp></dt>
+<dd>
+<p>Create a VLAN <var>n</var> shared with another QEMU virtual
+machines using a UDP multicast socket, effectively making a bus for
+every QEMU with same multicast address <var>maddr</var> and <var>port</var>.
+NOTES:
+</p><ol>
+<li> Several QEMU can be running on different hosts and share same bus (assuming
+correct multicast setup for these hosts).
+</li><li> mcast support is compatible with User Mode Linux (argument <samp>eth<var>N</var>=mcast</samp>), see
+<a href="http://user-mode-linux.sf.net">http://user-mode-linux.sf.net</a>.
+</li><li> Use <samp>fd=h</samp> to specify an already opened UDP multicast socket.
+</li></ol>
+
+<p>Example:
+</p><div class="example">
+<pre class="example"># launch one QEMU instance
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=230.0.0.1:1234
+# launch another QEMU instance on same &quot;bus&quot;
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:57 \
+-net socket,mcast=230.0.0.1:1234
+# launch yet another QEMU instance on same &quot;bus&quot;
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:58 \
+-net socket,mcast=230.0.0.1:1234
+</pre></div>
+
+<p>Example (User Mode Linux compat.):
+</p><div class="example">
+<pre class="example"># launch QEMU instance (note mcast address selected
+# is UML's default)
+qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=239.192.168.1:1102
+# launch UML
+/path/to/linux ubd0=/path/to/root_fs eth0=mcast
+</pre></div>
+
+<p>Example (send packets from host&rsquo;s 1.2.3.4):
+</p><div class="example">
+<pre class="example">qemu-system-i386 linux.img \
+-net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4
+</pre></div>
+
+</dd>
+<dt><samp>-netdev l2tpv3,id=<var>id</var>,src=<var>srcaddr</var>,dst=<var>dstaddr</var>[,srcport=<var>srcport</var>][,dstport=<var>dstport</var>],txsession=<var>txsession</var>[,rxsession=<var>rxsession</var>][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=<var>txcookie</var>][,rxcookie=<var>rxcookie</var>][,offset=<var>offset</var>]</samp></dt>
+<dt><samp>-net l2tpv3[,vlan=<var>n</var>][,name=<var>name</var>],src=<var>srcaddr</var>,dst=<var>dstaddr</var>[,srcport=<var>srcport</var>][,dstport=<var>dstport</var>],txsession=<var>txsession</var>[,rxsession=<var>rxsession</var>][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=<var>txcookie</var>][,rxcookie=<var>rxcookie</var>][,offset=<var>offset</var>]</samp></dt>
+<dd><p>Connect VLAN <var>n</var> to L2TPv3 pseudowire. L2TPv3 (RFC3391) is a popular
+protocol to transport Ethernet (and other Layer 2) data frames between
+two systems. It is present in routers, firewalls and the Linux kernel
+(from version 3.3 onwards).
+</p>
+<p>This transport allows a VM to communicate to another VM, router or firewall directly.
+</p>
+</dd>
+<dt><samp>src=<var>srcaddr</var></samp></dt>
+<dd><p>source address (mandatory)
+</p></dd>
+<dt><samp>dst=<var>dstaddr</var></samp></dt>
+<dd><p>destination address (mandatory)
+</p></dd>
+<dt><samp>udp</samp></dt>
+<dd><p>select udp encapsulation (default is ip).
+</p></dd>
+<dt><samp>srcport=<var>srcport</var></samp></dt>
+<dd><p>source udp port.
+</p></dd>
+<dt><samp>dstport=<var>dstport</var></samp></dt>
+<dd><p>destination udp port.
+</p></dd>
+<dt><samp>ipv6</samp></dt>
+<dd><p>force v6, otherwise defaults to v4.
+</p></dd>
+<dt><samp>rxcookie=<var>rxcookie</var></samp></dt>
+<dt><samp>txcookie=<var>txcookie</var></samp></dt>
+<dd><p>Cookies are a weak form of security in the l2tpv3 specification.
+Their function is mostly to prevent misconfiguration. By default they are 32
+bit.
+</p></dd>
+<dt><samp>cookie64</samp></dt>
+<dd><p>Set cookie size to 64 bit instead of the default 32
+</p></dd>
+<dt><samp>counter=off</samp></dt>
+<dd><p>Force a &rsquo;cut-down&rsquo; L2TPv3 with no counter as in
+draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00
+</p></dd>
+<dt><samp>pincounter=on</samp></dt>
+<dd><p>Work around broken counter handling in peer. This may also help on
+networks which have packet reorder.
+</p></dd>
+<dt><samp>offset=<var>offset</var></samp></dt>
+<dd><p>Add an extra offset between header and data
+</p>
+<p>For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to the bridge br-lan
+on the remote Linux host 1.2.3.4:
+</p><div class="example">
+<pre class="example"># Setup tunnel on linux host using raw ip as encapsulation
+# on 1.2.3.4
+ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \
+encap udp udp_sport 16384 udp_dport 16384
+ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \
+0xFFFFFFFF peer_session_id 0xFFFFFFFF
+ifconfig vmtunnel0 mtu 1500
+ifconfig vmtunnel0 up
+brctl addif br-lan vmtunnel0
+
+
+# on 4.3.2.1
+# launch QEMU instance - if your network has reorder or is very lossy add ,pincounter
+
+qemu-system-i386 linux.img -net nic -net l2tpv3,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter
+
+
+</pre></div>
+
+</dd>
+<dt><samp>-netdev vde,id=<var>id</var>[,sock=<var>socketpath</var>][,port=<var>n</var>][,group=<var>groupname</var>][,mode=<var>octalmode</var>]</samp></dt>
+<dt><samp>-net vde[,vlan=<var>n</var>][,name=<var>name</var>][,sock=<var>socketpath</var>] [,port=<var>n</var>][,group=<var>groupname</var>][,mode=<var>octalmode</var>]</samp></dt>
+<dd><p>Connect VLAN <var>n</var> to PORT <var>n</var> of a vde switch running on host and
+listening for incoming connections on <var>socketpath</var>. Use GROUP <var>groupname</var>
+and MODE <var>octalmode</var> to change default ownership and permissions for
+communication port. This option is only available if QEMU has been compiled
+with vde support enabled.
+</p>
+<p>Example:
+</p><div class="example">
+<pre class="example"># launch vde switch
+vde_switch -F -sock /tmp/myswitch
+# launch QEMU instance
+qemu-system-i386 linux.img -net nic -net vde,sock=/tmp/myswitch
+</pre></div>
+
+</dd>
+<dt><samp>-netdev hubport,id=<var>id</var>,hubid=<var>hubid</var></samp></dt>
+<dd>
+<p>Create a hub port on QEMU &quot;vlan&quot; <var>hubid</var>.
+</p>
+<p>The hubport netdev lets you connect a NIC to a QEMU &quot;vlan&quot; instead of a single
+netdev.  <code>-net</code> and <code>-device</code> with parameter <samp>vlan</samp> create the
+required hub automatically.
+</p>
+</dd>
+<dt><samp>-netdev vhost-user,chardev=<var>id</var>[,vhostforce=on|off]</samp></dt>
+<dd>
+<p>Establish a vhost-user netdev, backed by a chardev <var>id</var>. The chardev should
+be a unix domain socket backed one. The vhost-user uses a specifically defined
+protocol to pass vhost ioctl replacement messages to an application on the other
+end of the socket. On non-MSIX guests, the feature can be forced with
+<var>vhostforce</var>.
+</p>
+<p>Example:
+</p><div class="example">
+<pre class="example">qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \
+-numa node,memdev=mem \
+-chardev socket,path=/path/to/socket \
+-netdev type=vhost-user,id=net0,chardev=chr0 \
+-device virtio-net-pci,netdev=net0
+</pre></div>
+
+</dd>
+<dt><samp>-net dump[,vlan=<var>n</var>][,file=<var>file</var>][,len=<var>len</var>]</samp></dt>
+<dd><p>Dump network traffic on VLAN <var>n</var> to file <var>file</var> (<samp>qemu-vlan0.pcap</samp> by default).
+At most <var>len</var> bytes (64k by default) per packet are stored. The file format is
+libpcap, so it can be analyzed with tools such as tcpdump or Wireshark.
+</p>
+</dd>
+<dt><samp>-net none</samp></dt>
+<dd><p>Indicate that no network devices should be configured. It is used to
+override the default configuration (<samp>-net nic -net user</samp>) which
+is activated if no <samp>-net</samp> options are provided.
+</p></dd>
+</dl>
+
+<p>Character device options:
+</p>
+<p>The general form of a character device option is:
+</p><dl compact="compact">
+<dt><samp>-chardev <var>backend</var> ,id=<var>id</var> [,mux=on|off] [,<var>options</var>]</samp></dt>
+<dd><a name="index-_002dchardev"></a>
+<p>Backend is one of:
+<samp>null</samp>,
+<samp>socket</samp>,
+<samp>udp</samp>,
+<samp>msmouse</samp>,
+<samp>vc</samp>,
+<samp>ringbuf</samp>,
+<samp>file</samp>,
+<samp>pipe</samp>,
+<samp>console</samp>,
+<samp>serial</samp>,
+<samp>pty</samp>,
+<samp>stdio</samp>,
+<samp>braille</samp>,
+<samp>tty</samp>,
+<samp>parallel</samp>,
+<samp>parport</samp>,
+<samp>spicevmc</samp>.
+<samp>spiceport</samp>.
+The specific backend will determine the applicable options.
+</p>
+<p>All devices must have an id, which can be any string up to 127 characters long.
+It is used to uniquely identify this device in other command line directives.
+</p>
+<p>A character device may be used in multiplexing mode by multiple front-ends.
+The key sequence of <tt class="key">Control-a</tt> and <tt class="key">c</tt> will rotate the input focus
+between attached front-ends. Specify <samp>mux=on</samp> to enable this mode.
+</p>
+<p>Options to each backend are described below.
+</p>
+</dd>
+<dt><samp>-chardev null ,id=<var>id</var></samp></dt>
+<dd><p>A void device. This device will not emit any data, and will drop any data it
+receives. The null backend does not take any options.
+</p>
+</dd>
+<dt><samp>-chardev socket ,id=<var>id</var> [<var>TCP options</var> or <var>unix options</var>] [,server] [,nowait] [,telnet] [,reconnect=<var>seconds</var>]</samp></dt>
+<dd>
+<p>Create a two-way stream socket, which can be either a TCP or a unix socket. A
+unix socket will be created if <samp>path</samp> is specified. Behaviour is
+undefined if TCP options are specified for a unix socket.
+</p>
+<p><samp>server</samp> specifies that the socket shall be a listening socket.
+</p>
+<p><samp>nowait</samp> specifies that QEMU should not block waiting for a client to
+connect to a listening socket.
+</p>
+<p><samp>telnet</samp> specifies that traffic on the socket should interpret telnet
+escape sequences.
+</p>
+<p><samp>reconnect</samp> sets the timeout for reconnecting on non-server sockets when
+the remote end goes away.  qemu will delay this many seconds and then attempt
+to reconnect.  Zero disables reconnecting, and is the default.
+</p>
+<p>TCP and unix socket options are given below:
+</p>
+<dl compact="compact">
+<dt><samp>TCP options: port=<var>port</var> [,host=<var>host</var>] [,to=<var>to</var>] [,ipv4] [,ipv6] [,nodelay]</samp></dt>
+<dd>
+<p><samp>host</samp> for a listening socket specifies the local address to be bound.
+For a connecting socket species the remote host to connect to. <samp>host</samp> is
+optional for listening sockets. If not specified it defaults to <code>0.0.0.0</code>.
+</p>
+<p><samp>port</samp> for a listening socket specifies the local port to be bound. For a
+connecting socket specifies the port on the remote host to connect to.
+<samp>port</samp> can be given as either a port number or a service name.
+<samp>port</samp> is required.
+</p>
+<p><samp>to</samp> is only relevant to listening sockets. If it is specified, and
+<samp>port</samp> cannot be bound, QEMU will attempt to bind to subsequent ports up
+to and including <samp>to</samp> until it succeeds. <samp>to</samp> must be specified
+as a port number.
+</p>
+<p><samp>ipv4</samp> and <samp>ipv6</samp> specify that either IPv4 or IPv6 must be used.
+If neither is specified the socket may use either protocol.
+</p>
+<p><samp>nodelay</samp> disables the Nagle algorithm.
+</p>
+</dd>
+<dt><samp>unix options: path=<var>path</var></samp></dt>
+<dd>
+<p><samp>path</samp> specifies the local path of the unix socket. <samp>path</samp> is
+required.
+</p>
+</dd>
+</dl>
+
+</dd>
+<dt><samp>-chardev udp ,id=<var>id</var> [,host=<var>host</var>] ,port=<var>port</var> [,localaddr=<var>localaddr</var>] [,localport=<var>localport</var>] [,ipv4] [,ipv6]</samp></dt>
+<dd>
+<p>Sends all traffic from the guest to a remote host over UDP.
+</p>
+<p><samp>host</samp> specifies the remote host to connect to. If not specified it
+defaults to <code>localhost</code>.
+</p>
+<p><samp>port</samp> specifies the port on the remote host to connect to. <samp>port</samp>
+is required.
+</p>
+<p><samp>localaddr</samp> specifies the local address to bind to. If not specified it
+defaults to <code>0.0.0.0</code>.
+</p>
+<p><samp>localport</samp> specifies the local port to bind to. If not specified any
+available local port will be used.
+</p>
+<p><samp>ipv4</samp> and <samp>ipv6</samp> specify that either IPv4 or IPv6 must be used.
+If neither is specified the device may use either protocol.
+</p>
+</dd>
+<dt><samp>-chardev msmouse ,id=<var>id</var></samp></dt>
+<dd>
+<p>Forward QEMU&rsquo;s emulated msmouse events to the guest. <samp>msmouse</samp> does not
+take any options.
+</p>
+</dd>
+<dt><samp>-chardev vc ,id=<var>id</var> [[,width=<var>width</var>] [,height=<var>height</var>]] [[,cols=<var>cols</var>] [,rows=<var>rows</var>]]</samp></dt>
+<dd>
+<p>Connect to a QEMU text console. <samp>vc</samp> may optionally be given a specific
+size.
+</p>
+<p><samp>width</samp> and <samp>height</samp> specify the width and height respectively of
+the console, in pixels.
+</p>
+<p><samp>cols</samp> and <samp>rows</samp> specify that the console be sized to fit a text
+console with the given dimensions.
+</p>
+</dd>
+<dt><samp>-chardev ringbuf ,id=<var>id</var> [,size=<var>size</var>]</samp></dt>
+<dd>
+<p>Create a ring buffer with fixed size <samp>size</samp>.
+<var>size</var> must be a power of two, and defaults to <code>64K</code>).
+</p>
+</dd>
+<dt><samp>-chardev file ,id=<var>id</var> ,path=<var>path</var></samp></dt>
+<dd>
+<p>Log all traffic received from the guest to a file.
+</p>
+<p><samp>path</samp> specifies the path of the file to be opened. This file will be
+created if it does not already exist, and overwritten if it does. <samp>path</samp>
+is required.
+</p>
+</dd>
+<dt><samp>-chardev pipe ,id=<var>id</var> ,path=<var>path</var></samp></dt>
+<dd>
+<p>Create a two-way connection to the guest. The behaviour differs slightly between
+Windows hosts and other hosts:
+</p>
+<p>On Windows, a single duplex pipe will be created at
+<samp>\.pipe\<samp>path</samp></samp>.
+</p>
+<p>On other hosts, 2 pipes will be created called <samp><samp>path</samp>.in</samp> and
+<samp><samp>path</samp>.out</samp>. Data written to <samp><samp>path</samp>.in</samp> will be
+received by the guest. Data written by the guest can be read from
+<samp><samp>path</samp>.out</samp>. QEMU will not create these fifos, and requires them to
+be present.
+</p>
+<p><samp>path</samp> forms part of the pipe path as described above. <samp>path</samp> is
+required.
+</p>
+</dd>
+<dt><samp>-chardev console ,id=<var>id</var></samp></dt>
+<dd>
+<p>Send traffic from the guest to QEMU&rsquo;s standard output. <samp>console</samp> does not
+take any options.
+</p>
+<p><samp>console</samp> is only available on Windows hosts.
+</p>
+</dd>
+<dt><samp>-chardev serial ,id=<var>id</var> ,path=<samp>path</samp></samp></dt>
+<dd>
+<p>Send traffic from the guest to a serial device on the host.
+</p>
+<p>On Unix hosts serial will actually accept any tty device,
+not only serial lines.
+</p>
+<p><samp>path</samp> specifies the name of the serial device to open.
+</p>
+</dd>
+<dt><samp>-chardev pty ,id=<var>id</var></samp></dt>
+<dd>
+<p>Create a new pseudo-terminal on the host and connect to it. <samp>pty</samp> does
+not take any options.
+</p>
+<p><samp>pty</samp> is not available on Windows hosts.
+</p>
+</dd>
+<dt><samp>-chardev stdio ,id=<var>id</var> [,signal=on|off]</samp></dt>
+<dd><p>Connect to standard input and standard output of the QEMU process.
+</p>
+<p><samp>signal</samp> controls if signals are enabled on the terminal, that includes
+exiting QEMU with the key sequence <tt class="key">Control-c</tt>. This option is enabled by
+default, use <samp>signal=off</samp> to disable it.
+</p>
+<p><samp>stdio</samp> is not available on Windows hosts.
+</p>
+</dd>
+<dt><samp>-chardev braille ,id=<var>id</var></samp></dt>
+<dd>
+<p>Connect to a local BrlAPI server. <samp>braille</samp> does not take any options.
+</p>
+</dd>
+<dt><samp>-chardev tty ,id=<var>id</var> ,path=<var>path</var></samp></dt>
+<dd>
+<p><samp>tty</samp> is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and
+DragonFlyBSD hosts.  It is an alias for <samp>serial</samp>.
+</p>
+<p><samp>path</samp> specifies the path to the tty. <samp>path</samp> is required.
+</p>
+</dd>
+<dt><samp>-chardev parallel ,id=<var>id</var> ,path=<var>path</var></samp></dt>
+<dt><samp>-chardev parport ,id=<var>id</var> ,path=<var>path</var></samp></dt>
+<dd>
+<p><samp>parallel</samp> is only available on Linux, FreeBSD and DragonFlyBSD hosts.
+</p>
+<p>Connect to a local parallel port.
+</p>
+<p><samp>path</samp> specifies the path to the parallel port device. <samp>path</samp> is
+required.
+</p>
+</dd>
+<dt><samp>-chardev spicevmc ,id=<var>id</var> ,debug=<var>debug</var>, name=<var>name</var></samp></dt>
+<dd>
+<p><samp>spicevmc</samp> is only available when spice support is built in.
+</p>
+<p><samp>debug</samp> debug level for spicevmc
+</p>
+<p><samp>name</samp> name of spice channel to connect to
+</p>
+<p>Connect to a spice virtual machine channel, such as vdiport.
+</p>
+</dd>
+<dt><samp>-chardev spiceport ,id=<var>id</var> ,debug=<var>debug</var>, name=<var>name</var></samp></dt>
+<dd>
+<p><samp>spiceport</samp> is only available when spice support is built in.
+</p>
+<p><samp>debug</samp> debug level for spicevmc
+</p>
+<p><samp>name</samp> name of spice port to connect to
+</p>
+<p>Connect to a spice port, allowing a Spice client to handle the traffic
+identified by a name (preferably a fqdn).
+</p></dd>
+</dl>
+
+<p>Device URL Syntax:
+</p>
+<p>In addition to using normal file images for the emulated storage devices,
+QEMU can also use networked resources such as iSCSI devices. These are
+specified using a special URL syntax.
+</p>
+<dl compact="compact">
+<dt><samp>iSCSI</samp></dt>
+<dd><p>iSCSI support allows QEMU to access iSCSI resources directly and use as
+images for the guest storage. Both disk and cdrom images are supported.
+</p>
+<p>Syntax for specifying iSCSI LUNs is
+&ldquo;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&rdquo;
+</p>
+<p>By default qemu will use the iSCSI initiator-name
+&rsquo;iqn.2008-11.org.linux-kvm[:&lt;name&gt;]&rsquo; but this can also be set from the command
+line or a configuration file.
+</p>
+
+<p>Example (without authentication):
+</p><div class="example">
+<pre class="example">qemu-system-i386 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \
+-cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \
+-drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
+</pre></div>
+
+<p>Example (CHAP username/password via URL):
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1
+</pre></div>
+
+<p>Example (CHAP username/password via environment variables):
+</p><div class="example">
+<pre class="example">LIBISCSI_CHAP_USERNAME=&quot;user&quot; \
+LIBISCSI_CHAP_PASSWORD=&quot;password&quot; \
+qemu-system-i386 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
+</pre></div>
+
+<p>iSCSI support is an optional feature of QEMU and only available when
+compiled and linked against libiscsi.
+</p>
+<p>iSCSI parameters such as username and password can also be specified via
+a configuration file. See qemu-doc for more information and examples.
+</p>
+</dd>
+<dt><samp>NBD</samp></dt>
+<dd><p>QEMU supports NBD (Network Block Devices) both using TCP protocol as well
+as Unix Domain Sockets.
+</p>
+<p>Syntax for specifying a NBD device using TCP
+&ldquo;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&rdquo;
+</p>
+<p>Syntax for specifying a NBD device using Unix Domain Sockets
+&ldquo;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&rdquo;
+</p>
+
+<p>Example for TCP
+</p><div class="example">
+<pre class="example">qemu-system-i386 --drive file=nbd:192.0.2.1:30000
+</pre></div>
+
+<p>Example for Unix Domain Sockets
+</p><div class="example">
+<pre class="example">qemu-system-i386 --drive file=nbd:unix:/tmp/nbd-socket
+</pre></div>
+
+</dd>
+<dt><samp>SSH</samp></dt>
+<dd><p>QEMU supports SSH (Secure Shell) access to remote disks.
+</p>
+<p>Examples:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -drive file=ssh://user@host/path/to/disk.img
+qemu-system-i386 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img
+</pre></div>
+
+<p>Currently authentication must be done using ssh-agent.  Other
+authentication methods may be supported in future.
+</p>
+</dd>
+<dt><samp>Sheepdog</samp></dt>
+<dd><p>Sheepdog is a distributed storage system for QEMU.
+QEMU supports using either local sheepdog devices or remote networked
+devices.
+</p>
+<p>Syntax for specifying a sheepdog device
+</p><div class="example">
+<pre class="example">sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]
+</pre></div>
+
+<p>Example
+</p><div class="example">
+<pre class="example">qemu-system-i386 --drive file=sheepdog://192.0.2.1:30000/MyVirtualMachine
+</pre></div>
+
+<p>See also <a href="http://http://www.osrg.net/sheepdog/">http://http://www.osrg.net/sheepdog/</a>.
+</p>
+</dd>
+<dt><samp>GlusterFS</samp></dt>
+<dd><p>GlusterFS is an user space distributed file system.
+QEMU supports the use of GlusterFS volumes for hosting VM disk images using
+TCP, Unix Domain Sockets and RDMA transport protocols.
+</p>
+<p>Syntax for specifying a VM disk image on GlusterFS volume is
+</p><div class="example">
+<pre class="example">gluster[+transport]://[server[:port]]/volname/image[?socket=...]
+</pre></div>
+
+
+<p>Example
+</p><div class="example">
+<pre class="example">qemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img
+</pre></div>
+
+<p>See also <a href="http://www.gluster.org">http://www.gluster.org</a>.
+</p>
+</dd>
+<dt><samp>HTTP/HTTPS/FTP/FTPS/TFTP</samp></dt>
+<dd><p>QEMU supports read-only access to files accessed over http(s), ftp(s) and tftp.
+</p>
+<p>Syntax using a single filename:
+</p><div class="example">
+<pre class="example">&lt;protocol&gt;://[&lt;username&gt;[:&lt;password&gt;]@]&lt;host&gt;/&lt;path&gt;
+</pre></div>
+
+<p>where:
+</p><dl compact="compact">
+<dt><samp>protocol</samp></dt>
+<dd><p>&rsquo;http&rsquo;, &rsquo;https&rsquo;, &rsquo;ftp&rsquo;, &rsquo;ftps&rsquo;, or &rsquo;tftp&rsquo;.
+</p>
+</dd>
+<dt><samp>username</samp></dt>
+<dd><p>Optional username for authentication to the remote server.
+</p>
+</dd>
+<dt><samp>password</samp></dt>
+<dd><p>Optional password for authentication to the remote server.
+</p>
+</dd>
+<dt><samp>host</samp></dt>
+<dd><p>Address of the remote server.
+</p>
+</dd>
+<dt><samp>path</samp></dt>
+<dd><p>Path on the remote server, including any query string.
+</p></dd>
+</dl>
+
+<p>The following options are also supported:
+</p><dl compact="compact">
+<dt><samp>url</samp></dt>
+<dd><p>The full URL when passing options to the driver explicitly.
+</p>
+</dd>
+<dt><samp>readahead</samp></dt>
+<dd><p>The amount of data to read ahead with each range request to the remote server.
+This value may optionally have the suffix &rsquo;T&rsquo;, &rsquo;G&rsquo;, &rsquo;M&rsquo;, &rsquo;K&rsquo;, &rsquo;k&rsquo; or &rsquo;b&rsquo;. If it
+does not have a suffix, it will be assumed to be in bytes. The value must be a
+multiple of 512 bytes. It defaults to 256k.
+</p>
+</dd>
+<dt><samp>sslverify</samp></dt>
+<dd><p>Whether to verify the remote server&rsquo;s certificate when connecting over SSL. It
+can have the value &rsquo;on&rsquo; or &rsquo;off&rsquo;. It defaults to &rsquo;on&rsquo;.
+</p>
+</dd>
+<dt><samp>cookie</samp></dt>
+<dd><p>Send this cookie (it can also be a list of cookies separated by &rsquo;;&rsquo;) with
+each outgoing request.  Only supported when using protocols such as HTTP
+which support cookies, otherwise ignored.
+</p>
+</dd>
+<dt><samp>timeout</samp></dt>
+<dd><p>Set the timeout in seconds of the CURL connection. This timeout is the time
+that CURL waits for a response from the remote server to get the size of the
+image to be downloaded. If not set, the default timeout of 5 seconds is used.
+</p></dd>
+</dl>
+
+<p>Note that when passing options to qemu explicitly, <samp>driver</samp> is the value
+of &lt;protocol&gt;.
+</p>
+<p>Example: boot from a remote Fedora 20 live ISO image
+</p><div class="example">
+<pre class="example">qemu-system-x86_64 --drive media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
+
+qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
+</pre></div>
+
+<p>Example: boot from a remote Fedora 20 cloud image using a local overlay for
+writes, copy-on-read, and a readahead of 64k
+</p><div class="example">
+<pre class="example">qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;http&quot;,, &quot;file.url&quot;:&quot;https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;}' /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2
+
+qemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on
+</pre></div>
+
+<p>Example: boot from an image stored on a VMware vSphere server with a self-signed
+certificate using a local overlay for writes, a readahead of 64k and a timeout
+of 10 seconds.
+</p><div class="example">
+<pre class="example">qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;https&quot;,, &quot;file.url&quot;:&quot;https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&amp;dsName=datastore1&quot;,, &quot;file.sslverify&quot;:&quot;off&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;,, &quot;file.timeout&quot;:10}' /tmp/test.qcow2
+
+qemu-system-x86_64 -drive file=/tmp/test.qcow2
+</pre></div>
+</dd>
+</dl>
+<p>Bluetooth(R) options:
+</p><dl compact="compact">
+<dt><samp>-bt hci[...]</samp></dt>
+<dd><a name="index-_002dbt"></a>
+<p>Defines the function of the corresponding Bluetooth HCI.  -bt options
+are matched with the HCIs present in the chosen machine type.  For
+example when emulating a machine with only one HCI built into it, only
+the first <code>-bt hci[...]</code> option is valid and defines the HCI&rsquo;s
+logic.  The Transport Layer is decided by the machine type.  Currently
+the machines <code>n800</code> and <code>n810</code> have one HCI and all other
+machines have none.
+</p>
+<a name="bt_002dhcis"></a><p>The following three types are recognized:
+</p>
+<dl compact="compact">
+<dt><samp>-bt hci,null</samp></dt>
+<dd><p>(default) The corresponding Bluetooth HCI assumes no internal logic
+and will not respond to any HCI commands or emit events.
+</p>
+</dd>
+<dt><samp>-bt hci,host[:<var>id</var>]</samp></dt>
+<dd><p>(<code>bluez</code> only) The corresponding HCI passes commands / events
+to / from the physical HCI identified by the name <var>id</var> (default:
+<code>hci0</code>) on the computer running QEMU.  Only available on <code>bluez</code>
+capable systems like Linux.
+</p>
+</dd>
+<dt><samp>-bt hci[,vlan=<var>n</var>]</samp></dt>
+<dd><p>Add a virtual, standard HCI that will participate in the Bluetooth
+scatternet <var>n</var> (default <code>0</code>).  Similarly to <samp>-net</samp>
+VLANs, devices inside a bluetooth network <var>n</var> can only communicate
+with other devices in the same network (scatternet).
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>-bt vhci[,vlan=<var>n</var>]</samp></dt>
+<dd><p>(Linux-host only) Create a HCI in scatternet <var>n</var> (default 0) attached
+to the host bluetooth stack instead of to the emulated target.  This
+allows the host and target machines to participate in a common scatternet
+and communicate.  Requires the Linux <code>vhci</code> driver installed.  Can
+be used as following:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5
+</pre></div>
+
+</dd>
+<dt><samp>-bt device:<var>dev</var>[,vlan=<var>n</var>]</samp></dt>
+<dd><p>Emulate a bluetooth device <var>dev</var> and place it in network <var>n</var>
+(default <code>0</code>).  QEMU can only emulate one type of bluetooth devices
+currently:
+</p>
+<dl compact="compact">
+<dt><samp>keyboard</samp></dt>
+<dd><p>Virtual wireless keyboard implementing the HIDP bluetooth profile.
+</p></dd>
+</dl>
+</dd>
+</dl>
+
+<p>TPM device options:
+</p>
+<p>The general form of a TPM device option is:
+</p><dl compact="compact">
+<dt><samp>-tpmdev <var>backend</var> ,id=<var>id</var> [,<var>options</var>]</samp></dt>
+<dd><a name="index-_002dtpmdev"></a>
+<p>Backend type must be:
+<samp>passthrough</samp>.
+</p>
+<p>The specific backend type will determine the applicable options.
+The <code>-tpmdev</code> option creates the TPM backend and requires a
+<code>-device</code> option that specifies the TPM frontend interface model.
+</p>
+<p>Options to each backend are described below.
+</p>
+<p>Use &rsquo;help&rsquo; to print all available TPM backend types.
+</p><div class="example">
+<pre class="example">qemu -tpmdev help
+</pre></div>
+
+</dd>
+<dt><samp>-tpmdev passthrough, id=<var>id</var>, path=<var>path</var>, cancel-path=<var>cancel-path</var></samp></dt>
+<dd>
+<p>(Linux-host only) Enable access to the host&rsquo;s TPM using the passthrough
+driver.
+</p>
+<p><samp>path</samp> specifies the path to the host&rsquo;s TPM device, i.e., on
+a Linux host this would be <code>/dev/tpm0</code>.
+<samp>path</samp> is optional and by default <code>/dev/tpm0</code> is used.
+</p>
+<p><samp>cancel-path</samp> specifies the path to the host TPM device&rsquo;s sysfs
+entry allowing for cancellation of an ongoing TPM command.
+<samp>cancel-path</samp> is optional and by default QEMU will search for the
+sysfs entry to use.
+</p>
+<p>Some notes about using the host&rsquo;s TPM with the passthrough driver:
+</p>
+<p>The TPM device accessed by the passthrough driver must not be
+used by any other application on the host.
+</p>
+<p>Since the host&rsquo;s firmware (BIOS/UEFI) has already initialized the TPM,
+the VM&rsquo;s firmware (BIOS/UEFI) will not be able to initialize the
+TPM again and may therefore not show a TPM-specific menu that would
+otherwise allow the user to configure the TPM, e.g., allow the user to
+enable/disable or activate/deactivate the TPM.
+Further, if TPM ownership is released from within a VM then the host&rsquo;s TPM
+will get disabled and deactivated. To enable and activate the
+TPM again afterwards, the host has to be rebooted and the user is
+required to enter the firmware&rsquo;s menu to enable and activate the TPM.
+If the TPM is left disabled and/or deactivated most TPM commands will fail.
+</p>
+<p>To create a passthrough TPM use the following two options:
+</p><div class="example">
+<pre class="example">-tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0
+</pre></div>
+<p>Note that the <code>-tpmdev</code> id is <code>tpm0</code> and is referenced by
+<code>tpmdev=tpm0</code> in the device option.
+</p>
+</dd>
+</dl>
+
+
+<p>Linux/Multiboot boot specific:
+</p>
+<p>When using these options, you can use a given Linux or Multiboot
+kernel without installing it in the disk image. It can be useful
+for easier testing of various kernels.
+</p>
+<dl compact="compact">
+<dt><samp>-kernel <var>bzImage</var></samp></dt>
+<dd><a name="index-_002dkernel"></a>
+<p>Use <var>bzImage</var> as kernel image. The kernel can be either a Linux kernel
+or in multiboot format.
+</p></dd>
+<dt><samp>-append <var>cmdline</var></samp></dt>
+<dd><a name="index-_002dappend"></a>
+<p>Use <var>cmdline</var> as kernel command line
+</p></dd>
+<dt><samp>-initrd <var>file</var></samp></dt>
+<dd><a name="index-_002dinitrd"></a>
+<p>Use <var>file</var> as initial ram disk.
+</p>
+</dd>
+<dt><samp>-initrd &quot;<var>file1</var> arg=foo,<var>file2</var>&quot;</samp></dt>
+<dd>
+<p>This syntax is only available with multiboot.
+</p>
+<p>Use <var>file1</var> and <var>file2</var> as modules and pass arg=foo as parameter to the
+first module.
+</p></dd>
+<dt><samp>-dtb <var>file</var></samp></dt>
+<dd><a name="index-_002ddtb"></a>
+<p>Use <var>file</var> as a device tree binary (dtb) image and pass it to the kernel
+on boot.
+</p></dd>
+</dl>
+
+<p>Debug/Expert options:
+</p><dl compact="compact">
+<dt><samp>-serial <var>dev</var></samp></dt>
+<dd><a name="index-_002dserial"></a>
+<p>Redirect the virtual serial port to host character device
+<var>dev</var>. The default device is <code>vc</code> in graphical mode and
+<code>stdio</code> in non graphical mode.
+</p>
+<p>This option can be used several times to simulate up to 4 serial
+ports.
+</p>
+<p>Use <code>-serial none</code> to disable all serial ports.
+</p>
+<p>Available character devices are:
+</p><dl compact="compact">
+<dt><samp>vc[:<var>W</var>x<var>H</var>]</samp></dt>
+<dd><p>Virtual console. Optionally, a width and height can be given in pixel with
+</p><div class="example">
+<pre class="example">vc:800x600
+</pre></div>
+<p>It is also possible to specify width or height in characters:
+</p><div class="example">
+<pre class="example">vc:80Cx24C
+</pre></div>
+</dd>
+<dt><samp>pty</samp></dt>
+<dd><p>[Linux only] Pseudo TTY (a new PTY is automatically allocated)
+</p></dd>
+<dt><samp>none</samp></dt>
+<dd><p>No device is allocated.
+</p></dd>
+<dt><samp>null</samp></dt>
+<dd><p>void device
+</p></dd>
+<dt><samp>chardev:<var>id</var></samp></dt>
+<dd><p>Use a named character device defined with the <code>-chardev</code> option.
+</p></dd>
+<dt><samp>/dev/XXX</samp></dt>
+<dd><p>[Linux only] Use host tty, e.g. <samp>/dev/ttyS0</samp>. The host serial port
+parameters are set according to the emulated ones.
+</p></dd>
+<dt><samp>/dev/parport<var>N</var></samp></dt>
+<dd><p>[Linux only, parallel port only] Use host parallel port
+<var>N</var>. Currently SPP and EPP parallel port features can be used.
+</p></dd>
+<dt><samp>file:<var>filename</var></samp></dt>
+<dd><p>Write output to <var>filename</var>. No character can be read.
+</p></dd>
+<dt><samp>stdio</samp></dt>
+<dd><p>[Unix only] standard input/output
+</p></dd>
+<dt><samp>pipe:<var>filename</var></samp></dt>
+<dd><p>name pipe <var>filename</var>
+</p></dd>
+<dt><samp>COM<var>n</var></samp></dt>
+<dd><p>[Windows only] Use host serial port <var>n</var>
+</p></dd>
+<dt><samp>udp:[<var>remote_host</var>]:<var>remote_port</var>[@[<var>src_ip</var>]:<var>src_port</var>]</samp></dt>
+<dd><p>This implements UDP Net Console.
+When <var>remote_host</var> or <var>src_ip</var> are not specified
+they default to <code>0.0.0.0</code>.
+When not using a specified <var>src_port</var> a random port is automatically chosen.
+</p>
+<p>If you just want a simple readonly console you can use <code>netcat</code> or
+<code>nc</code>, by starting QEMU with: <code>-serial udp::4555</code> and nc as:
+<code>nc -u -l -p 4555</code>. Any time QEMU writes something to that port it
+will appear in the netconsole session.
+</p>
+<p>If you plan to send characters back via netconsole or you want to stop
+and start QEMU a lot of times, you should have QEMU use the same
+source port each time by using something like <code>-serial
+udp::4555@:4556</code> to QEMU. Another approach is to use a patched
+version of netcat which can listen to a TCP port and send and receive
+characters via udp.  If you have a patched version of netcat which
+activates telnet remote echo and single char transfer, then you can
+use the following options to step up a netcat redirector to allow
+telnet on port 5555 to access the QEMU port.
+</p><dl compact="compact">
+<dt><code>QEMU Options:</code></dt>
+<dd><p>-serial udp::4555@:4556
+</p></dd>
+<dt><code>netcat options:</code></dt>
+<dd><p>-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T
+</p></dd>
+<dt><code>telnet options:</code></dt>
+<dd><p>localhost 5555
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>tcp:[<var>host</var>]:<var>port</var>[,<var>server</var>][,nowait][,nodelay][,reconnect=<var>seconds</var>]</samp></dt>
+<dd><p>The TCP Net Console has two modes of operation.  It can send the serial
+I/O to a location or wait for a connection from a location.  By default
+the TCP Net Console is sent to <var>host</var> at the <var>port</var>.  If you use
+the <var>server</var> option QEMU will wait for a client socket application
+to connect to the port before continuing, unless the <code>nowait</code>
+option was specified.  The <code>nodelay</code> option disables the Nagle buffering
+algorithm.  The <code>reconnect</code> option only applies if <var>noserver</var> is
+set, if the connection goes down it will attempt to reconnect at the
+given interval.  If <var>host</var> is omitted, 0.0.0.0 is assumed. Only
+one TCP connection at a time is accepted. You can use <code>telnet</code> to
+connect to the corresponding character device.
+</p><dl compact="compact">
+<dt><code>Example to send tcp console to 192.168.0.2 port 4444</code></dt>
+<dd><p>-serial tcp:192.168.0.2:4444
+</p></dd>
+<dt><code>Example to listen and wait on port 4444 for connection</code></dt>
+<dd><p>-serial tcp::4444,server
+</p></dd>
+<dt><code>Example to not wait and listen on ip 192.168.0.100 port 4444</code></dt>
+<dd><p>-serial tcp:192.168.0.100:4444,server,nowait
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>telnet:<var>host</var>:<var>port</var>[,server][,nowait][,nodelay]</samp></dt>
+<dd><p>The telnet protocol is used instead of raw tcp sockets.  The options
+work the same as if you had specified <code>-serial tcp</code>.  The
+difference is that the port acts like a telnet server or client using
+telnet option negotiation.  This will also allow you to send the
+MAGIC_SYSRQ sequence if you use a telnet that supports sending the break
+sequence.  Typically in unix telnet you do it with Control-] and then
+type &quot;send break&quot; followed by pressing the enter key.
+</p>
+</dd>
+<dt><samp>unix:<var>path</var>[,server][,nowait][,reconnect=<var>seconds</var>]</samp></dt>
+<dd><p>A unix domain socket is used instead of a tcp socket.  The option works the
+same as if you had specified <code>-serial tcp</code> except the unix domain socket
+<var>path</var> is used for connections.
+</p>
+</dd>
+<dt><samp>mon:<var>dev_string</var></samp></dt>
+<dd><p>This is a special option to allow the monitor to be multiplexed onto
+another serial port.  The monitor is accessed with key sequence of
+<tt class="key">Control-a</tt> and then pressing <tt class="key">c</tt>.
+<var>dev_string</var> should be any one of the serial devices specified
+above.  An example to multiplex the monitor onto a telnet server
+listening on port 4444 would be:
+</p><dl compact="compact">
+<dt><code>-serial mon:telnet::4444,server,nowait</code></dt>
+</dl>
+<p>When the monitor is multiplexed to stdio in this way, Ctrl+C will not terminate
+QEMU any more but will be passed to the guest instead.
+</p>
+</dd>
+<dt><samp>braille</samp></dt>
+<dd><p>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+</p>
+</dd>
+<dt><samp>msmouse</samp></dt>
+<dd><p>Three button serial mouse. Configure the guest to use Microsoft protocol.
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-parallel <var>dev</var></samp></dt>
+<dd><a name="index-_002dparallel"></a>
+<p>Redirect the virtual parallel port to host device <var>dev</var> (same
+devices as the serial port). On Linux hosts, <samp>/dev/parportN</samp> can
+be used to use hardware devices connected on the corresponding host
+parallel port.
+</p>
+<p>This option can be used several times to simulate up to 3 parallel
+ports.
+</p>
+<p>Use <code>-parallel none</code> to disable all parallel ports.
+</p></dd>
+<dt><samp>-monitor <var>dev</var></samp></dt>
+<dd><a name="index-_002dmonitor"></a>
+<p>Redirect the monitor to host device <var>dev</var> (same devices as the
+serial port).
+The default device is <code>vc</code> in graphical mode and <code>stdio</code> in
+non graphical mode.
+Use <code>-monitor none</code> to disable the default monitor.
+</p></dd>
+<dt><samp>-qmp <var>dev</var></samp></dt>
+<dd><a name="index-_002dqmp"></a>
+<p>Like -monitor but opens in &rsquo;control&rsquo; mode.
+</p></dd>
+<dt><samp>-qmp-pretty <var>dev</var></samp></dt>
+<dd><a name="index-_002dqmp_002dpretty"></a>
+<p>Like -qmp but uses pretty JSON formatting.
+</p></dd>
+<dt><samp>-mon [chardev=]name[,mode=readline|control][,default]</samp></dt>
+<dd><a name="index-_002dmon"></a>
+<p>Setup monitor on chardev <var>name</var>.
+</p></dd>
+<dt><samp>-debugcon <var>dev</var></samp></dt>
+<dd><a name="index-_002ddebugcon"></a>
+<p>Redirect the debug console to host device <var>dev</var> (same devices as the
+serial port).  The debug console is an I/O port which is typically port
+0xe9; writing to that I/O port sends output to this device.
+The default device is <code>vc</code> in graphical mode and <code>stdio</code> in
+non graphical mode.
+</p></dd>
+<dt><samp>-pidfile <var>file</var></samp></dt>
+<dd><a name="index-_002dpidfile"></a>
+<p>Store the QEMU process PID in <var>file</var>. It is useful if you launch QEMU
+from a script.
+</p></dd>
+<dt><samp>-singlestep</samp></dt>
+<dd><a name="index-_002dsinglestep"></a>
+<p>Run the emulation in single step mode.
+</p></dd>
+<dt><samp>-S</samp></dt>
+<dd><a name="index-_002dS"></a>
+<p>Do not start CPU at startup (you must type &rsquo;c&rsquo; in the monitor).
+</p></dd>
+<dt><samp>-realtime mlock=on|off</samp></dt>
+<dd><a name="index-_002drealtime"></a>
+<p>Run qemu with realtime features.
+mlocking qemu and guest memory can be enabled via <samp>mlock=on</samp>
+(enabled by default).
+</p></dd>
+<dt><samp>-gdb <var>dev</var></samp></dt>
+<dd><a name="index-_002dgdb"></a>
+<p>Wait for gdb connection on device <var>dev</var> (see <a href="#gdb_005fusage">gdb_usage</a>). Typical
+connections will likely be TCP-based, but also UDP, pseudo TTY, or even
+stdio are reasonable use case. The latter is allowing to start QEMU from
+within gdb and establish the connection via a pipe:
+</p><div class="example">
+<pre class="example">(gdb) target remote | exec qemu-system-i386 -gdb stdio ...
+</pre></div>
+</dd>
+<dt><samp>-s</samp></dt>
+<dd><a name="index-_002ds"></a>
+<p>Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234
+(see <a href="#gdb_005fusage">gdb_usage</a>).
+</p></dd>
+<dt><samp>-d <var>item1</var>[,...]</samp></dt>
+<dd><a name="index-_002dd"></a>
+<p>Enable logging of specified items. Use &rsquo;-d help&rsquo; for a list of log items.
+</p></dd>
+<dt><samp>-D <var>logfile</var></samp></dt>
+<dd><a name="index-_002dD"></a>
+<p>Output log in <var>logfile</var> instead of to stderr
+</p></dd>
+<dt><samp>-L  <var>path</var></samp></dt>
+<dd><a name="index-_002dL"></a>
+<p>Set the directory for the BIOS, VGA BIOS and keymaps.
+</p></dd>
+<dt><samp>-bios <var>file</var></samp></dt>
+<dd><a name="index-_002dbios"></a>
+<p>Set the filename for the BIOS.
+</p></dd>
+<dt><samp>-enable-kvm</samp></dt>
+<dd><a name="index-_002denable_002dkvm"></a>
+<p>Enable KVM full virtualization support. This option is only available
+if KVM support is enabled when compiling.
+</p></dd>
+<dt><samp>-xen-domid <var>id</var></samp></dt>
+<dd><a name="index-_002dxen_002ddomid"></a>
+<p>Specify xen guest domain <var>id</var> (XEN only).
+</p></dd>
+<dt><samp>-xen-create</samp></dt>
+<dd><a name="index-_002dxen_002dcreate"></a>
+<p>Create domain using xen hypercalls, bypassing xend.
+Warning: should not be used when xend is in use (XEN only).
+</p></dd>
+<dt><samp>-xen-attach</samp></dt>
+<dd><a name="index-_002dxen_002dattach"></a>
+<p>Attach to existing xen domain.
+xend will use this when starting QEMU (XEN only).
+</p></dd>
+<dt><samp>-no-reboot</samp></dt>
+<dd><a name="index-_002dno_002dreboot"></a>
+<p>Exit instead of rebooting.
+</p></dd>
+<dt><samp>-no-shutdown</samp></dt>
+<dd><a name="index-_002dno_002dshutdown"></a>
+<p>Don&rsquo;t exit QEMU on guest shutdown, but instead only stop the emulation.
+This allows for instance switching to monitor to commit changes to the
+disk image.
+</p></dd>
+<dt><samp>-loadvm <var>file</var></samp></dt>
+<dd><a name="index-_002dloadvm"></a>
+<p>Start right away with a saved state (<code>loadvm</code> in monitor)
+</p></dd>
+<dt><samp>-daemonize</samp></dt>
+<dd><a name="index-_002ddaemonize"></a>
+<p>Daemonize the QEMU process after initialization.  QEMU will not detach from
+standard IO until it is ready to receive connections on any of its devices.
+This option is a useful way for external programs to launch QEMU without having
+to cope with initialization race conditions.
+</p></dd>
+<dt><samp>-option-rom <var>file</var></samp></dt>
+<dd><a name="index-_002doption_002drom"></a>
+<p>Load the contents of <var>file</var> as an option ROM.
+This option is useful to load things like EtherBoot.
+</p>
+</dd>
+<dt><samp>-rtc [base=utc|localtime|<var>date</var>][,clock=host|vm][,driftfix=none|slew]</samp></dt>
+<dd><a name="index-_002drtc"></a>
+<p>Specify <samp>base</samp> as <code>utc</code> or <code>localtime</code> to let the RTC start at the current
+UTC or local time, respectively. <code>localtime</code> is required for correct date in
+MS-DOS or Windows. To start at a specific point in time, provide <var>date</var> in the
+format <code>2006-06-17T16:01:21</code> or <code>2006-06-17</code>. The default base is UTC.
+</p>
+<p>By default the RTC is driven by the host system time. This allows using of the
+RTC as accurate reference clock inside the guest, specifically if the host
+time is smoothly following an accurate external reference clock, e.g. via NTP.
+If you want to isolate the guest time from the host, you can set <samp>clock</samp>
+to <code>rt</code> instead.  To even prevent it from progressing during suspension,
+you can set it to <code>vm</code>.
+</p>
+<p>Enable <samp>driftfix</samp> (i386 targets only) if you experience time drift problems,
+specifically with Windows&rsquo; ACPI HAL. This option will try to figure out how
+many timer interrupts were not processed by the Windows guest and will
+re-inject them.
+</p></dd>
+<dt><samp>-icount [shift=<var>N</var>|auto]</samp></dt>
+<dd><a name="index-_002dicount"></a>
+<p>Enable virtual instruction counter.  The virtual cpu will execute one
+instruction every 2^<var>N</var> ns of virtual time.  If <code>auto</code> is specified
+then the virtual cpu speed will be automatically adjusted to keep virtual
+time within a few seconds of real time.
+</p>
+<p>Note that while this option can give deterministic behavior, it does not
+provide cycle accurate emulation.  Modern CPUs contain superscalar out of
+order cores with complex cache hierarchies.  The number of instructions
+executed often has little or no correlation with actual performance.
+</p>
+<p><samp>align=on</samp> will activate the delay algorithm which will try to
+to synchronise the host clock and the virtual clock. The goal is to
+have a guest running at the real frequency imposed by the shift option.
+Whenever the guest clock is behind the host clock and if
+<samp>align=on</samp> is specified then we print a messsage to the user
+to inform about the delay.
+Currently this option does not work when <samp>shift</samp> is <code>auto</code>.
+Note: The sync algorithm will work for those shift values for which
+the guest clock runs ahead of the host clock. Typically this happens
+when the shift value is high (how high depends on the host machine).
+</p></dd>
+<dt><samp>-watchdog <var>model</var></samp></dt>
+<dd><a name="index-_002dwatchdog"></a>
+<p>Create a virtual hardware watchdog device.  Once enabled (by a guest
+action), the watchdog must be periodically polled by an agent inside
+the guest or else the guest will be restarted.
+</p>
+<p>The <var>model</var> is the model of hardware watchdog to emulate.  Choices
+for model are: <code>ib700</code> (iBASE 700) which is a very simple ISA
+watchdog with a single timer, or <code>i6300esb</code> (Intel 6300ESB I/O
+controller hub) which is a much more featureful PCI-based dual-timer
+watchdog.  Choose a model for which your guest has drivers.
+</p>
+<p>Use <code>-watchdog help</code> to list available hardware models.  Only one
+watchdog can be enabled for a guest.
+</p></dd>
+<dt><samp>-watchdog-action <var>action</var></samp></dt>
+<dd><a name="index-_002dwatchdog_002daction"></a>
+
+<p>The <var>action</var> controls what QEMU will do when the watchdog timer
+expires.
+The default is
+<code>reset</code> (forcefully reset the guest).
+Other possible actions are:
+<code>shutdown</code> (attempt to gracefully shutdown the guest),
+<code>poweroff</code> (forcefully poweroff the guest),
+<code>pause</code> (pause the guest),
+<code>debug</code> (print a debug message and continue), or
+<code>none</code> (do nothing).
+</p>
+<p>Note that the <code>shutdown</code> action requires that the guest responds
+to ACPI signals, which it may not be able to do in the sort of
+situations where the watchdog would have expired, and thus
+<code>-watchdog-action shutdown</code> is not recommended for production use.
+</p>
+<p>Examples:
+</p>
+<dl compact="compact">
+<dt><code>-watchdog i6300esb -watchdog-action pause</code></dt>
+<dt><code>-watchdog ib700</code></dt>
+</dl>
+
+</dd>
+<dt><samp>-echr <var>numeric_ascii_value</var></samp></dt>
+<dd><a name="index-_002dechr"></a>
+<p>Change the escape character used for switching to the monitor when using
+monitor and serial sharing.  The default is <code>0x01</code> when using the
+<code>-nographic</code> option.  <code>0x01</code> is equal to pressing
+<code>Control-a</code>.  You can select a different character from the ascii
+control keys where 1 through 26 map to Control-a through Control-z.  For
+instance you could use the either of the following to change the escape
+character to Control-t.
+</p><dl compact="compact">
+<dt><code>-echr 0x14</code></dt>
+<dt><code>-echr 20</code></dt>
+</dl>
+</dd>
+<dt><samp>-virtioconsole <var>c</var></samp></dt>
+<dd><a name="index-_002dvirtioconsole"></a>
+<p>Set virtio console.
+</p>
+<p>This option is maintained for backward compatibility.
+</p>
+<p>Please use <code>-device virtconsole</code> for the new way of invocation.
+</p></dd>
+<dt><samp>-show-cursor</samp></dt>
+<dd><a name="index-_002dshow_002dcursor"></a>
+<p>Show cursor.
+</p></dd>
+<dt><samp>-tb-size <var>n</var></samp></dt>
+<dd><a name="index-_002dtb_002dsize"></a>
+<p>Set TB size.
+</p></dd>
+<dt><samp>-incoming tcp:[<var>host</var>]:<var>port</var>[,to=<var>maxport</var>][,ipv4][,ipv6]</samp></dt>
+<dt><samp>-incoming rdma:<var>host</var>:<var>port</var>[,ipv4][,ipv6]</samp></dt>
+<dd><a name="index-_002dincoming"></a>
+<p>Prepare for incoming migration, listen on a given tcp port.
+</p>
+</dd>
+<dt><samp>-incoming unix:<var>socketpath</var></samp></dt>
+<dd><p>Prepare for incoming migration, listen on a given unix socket.
+</p>
+</dd>
+<dt><samp>-incoming fd:<var>fd</var></samp></dt>
+<dd><p>Accept incoming migration from a given filedescriptor.
+</p>
+</dd>
+<dt><samp>-incoming exec:<var>cmdline</var></samp></dt>
+<dd><p>Accept incoming migration as an output from specified external command.
+</p></dd>
+<dt><samp>-nodefaults</samp></dt>
+<dd><a name="index-_002dnodefaults"></a>
+<p>Don&rsquo;t create default devices. Normally, QEMU sets the default devices like serial
+port, parallel port, virtual console, monitor device, VGA adapter, floppy and
+CD-ROM drive and others. The <code>-nodefaults</code> option will disable all those
+default devices.
+</p></dd>
+<dt><samp>-chroot <var>dir</var></samp></dt>
+<dd><a name="index-_002dchroot"></a>
+<p>Immediately before starting guest execution, chroot to the specified
+directory.  Especially useful in combination with -runas.
+</p></dd>
+<dt><samp>-runas <var>user</var></samp></dt>
+<dd><a name="index-_002drunas"></a>
+<p>Immediately before starting guest execution, drop root privileges, switching
+to the specified user.
+</p></dd>
+<dt><samp>-prom-env <var>variable</var>=<var>value</var></samp></dt>
+<dd><a name="index-_002dprom_002denv"></a>
+<p>Set OpenBIOS nvram <var>variable</var> to given <var>value</var> (PPC, SPARC only).
+</p></dd>
+<dt><samp>-semihosting</samp></dt>
+<dd><a name="index-_002dsemihosting"></a>
+<p>Enable semihosting mode (ARM, M68K, Xtensa only).
+</p></dd>
+<dt><samp>-semihosting-config [enable=on|off,]target=native|gdb|auto</samp></dt>
+<dd><a name="index-_002dsemihosting_002dconfig"></a>
+<p>Enable semihosting and define where the semihosting calls will be addressed,
+to QEMU (<code>native</code>) or to GDB (<code>gdb</code>). The default is <code>auto</code>, which means
+<code>gdb</code> during debug sessions and <code>native</code> otherwise (ARM, M68K, Xtensa only).
+</p></dd>
+<dt><samp>-old-param</samp></dt>
+<dd><a name="index-_002dold_002dparam-_0028ARM_0029"></a>
+<p>Old param mode (ARM only).
+</p></dd>
+<dt><samp>-sandbox <var>arg</var></samp></dt>
+<dd><a name="index-_002dsandbox"></a>
+<p>Enable Seccomp mode 2 system call filter. &rsquo;on&rsquo; will enable syscall filtering and &rsquo;off&rsquo; will
+disable it.  The default is &rsquo;off&rsquo;.
+</p></dd>
+<dt><samp>-readconfig <var>file</var></samp></dt>
+<dd><a name="index-_002dreadconfig"></a>
+<p>Read device configuration from <var>file</var>. This approach is useful when you want to spawn
+QEMU process with many command line options but you don&rsquo;t want to exceed the command line
+character limit.
+</p></dd>
+<dt><samp>-writeconfig <var>file</var></samp></dt>
+<dd><a name="index-_002dwriteconfig"></a>
+<p>Write device configuration to <var>file</var>. The <var>file</var> can be either filename to save
+command line and device configuration into file or dash <code>-</code>) character to print the
+output to stdout. This can be later used as input file for <code>-readconfig</code> option.
+</p></dd>
+<dt><samp>-nodefconfig</samp></dt>
+<dd><a name="index-_002dnodefconfig"></a>
+<p>Normally QEMU loads configuration files from <var>sysconfdir</var> and <var>datadir</var> at startup.
+The <code>-nodefconfig</code> option will prevent QEMU from loading any of those config files.
+</p></dd>
+<dt><samp>-no-user-config</samp></dt>
+<dd><a name="index-_002dno_002duser_002dconfig"></a>
+<p>The <code>-no-user-config</code> option makes QEMU not load any of the user-provided
+config files on <var>sysconfdir</var>, but won&rsquo;t make it skip the QEMU-provided config
+files from <var>datadir</var>.
+</p></dd>
+<dt><samp>-trace [events=<var>file</var>][,file=<var>file</var>]</samp></dt>
+<dd><a name="index-_002dtrace"></a>
+
+<p>Specify tracing options.
+</p>
+<dl compact="compact">
+<dt><samp>events=<var>file</var></samp></dt>
+<dd><p>Immediately enable events listed in <var>file</var>.
+The file must contain one event name (as listed in the <var>trace-events</var> file)
+per line.
+This option is only available if QEMU has been compiled with
+either <var>simple</var> or <var>stderr</var> tracing backend.
+</p></dd>
+<dt><samp>file=<var>file</var></samp></dt>
+<dd><p>Log output traces to <var>file</var>.
+</p>
+<p>This option is only available if QEMU has been compiled with
+the <var>simple</var> tracing backend.
+</p></dd>
+</dl>
+</dd>
+<dt><samp>-enable-fips</samp></dt>
+<dd><a name="index-_002denable_002dfips"></a>
+<p>Enable FIPS 140-2 compliance mode.
+</p></dd>
+<dt><samp>-object <var>typename</var>[,<var>prop1</var>=<var>value1</var>,...]</samp></dt>
+<dd><a name="index-_002dobject"></a>
+<p>Create an new object of type <var>typename</var> setting properties
+in the order they are specified.  Note that the &rsquo;id&rsquo;
+property must be set.  These objects are placed in the
+&rsquo;/objects&rsquo; path.
+</p></dd>
+<dt><samp>-msg timestamp[=on|off]</samp></dt>
+<dd><a name="index-_002dmsg"></a>
+<p>prepend a timestamp to each log message.(default:on)
+</p></dd>
+<dt><samp>-dump-vmstate <var>file</var></samp></dt>
+<dd><a name="index-_002ddump_002dvmstate"></a>
+<p>Dump json-encoded vmstate information for current machine type to file
+in <var>file</var>
+</p></dd>
+</dl>
+
+
+<hr>
+<a name="pcsys_005fkeys"></a>
+<a name="Keys"></a>
+<h3 class="section">3.4 Keys</h3>
+
+
+<p>During the graphical emulation, you can use special key combinations to change
+modes. The default key mappings are shown below, but if you use <code>-alt-grab</code>
+then the modifier is Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use
+<code>-ctrl-grab</code> then the modifier is the right Ctrl key (instead of Ctrl-Alt):
+</p>
+<dl compact="compact">
+<dt><tt class="key">Ctrl-Alt-f</tt></dt>
+<dd><a name="index-Ctrl_002dAlt_002df"></a>
+<p>Toggle full screen
+</p>
+</dd>
+<dt><tt class="key">Ctrl-Alt-+</tt></dt>
+<dd><a name="index-Ctrl_002dAlt_002d_002b"></a>
+<p>Enlarge the screen
+</p>
+</dd>
+<dt><tt class="key">Ctrl-Alt--</tt></dt>
+<dd><a name="index-Ctrl_002dAlt_002d_002d"></a>
+<p>Shrink the screen
+</p>
+</dd>
+<dt><tt class="key">Ctrl-Alt-u</tt></dt>
+<dd><a name="index-Ctrl_002dAlt_002du"></a>
+<p>Restore the screen&rsquo;s un-scaled dimensions
+</p>
+</dd>
+<dt><tt class="key">Ctrl-Alt-n</tt></dt>
+<dd><a name="index-Ctrl_002dAlt_002dn"></a>
+<p>Switch to virtual console &rsquo;n&rsquo;. Standard console mappings are:
+</p><dl compact="compact">
+<dt><em>1</em></dt>
+<dd><p>Target system display
+</p></dd>
+<dt><em>2</em></dt>
+<dd><p>Monitor
+</p></dd>
+<dt><em>3</em></dt>
+<dd><p>Serial port
+</p></dd>
+</dl>
+
+</dd>
+<dt><tt class="key">Ctrl-Alt</tt></dt>
+<dd><a name="index-Ctrl_002dAlt"></a>
+<p>Toggle mouse and keyboard grab.
+</p></dd>
+</dl>
+
+<a name="index-Ctrl_002dUp"></a>
+<a name="index-Ctrl_002dDown"></a>
+<a name="index-Ctrl_002dPageUp"></a>
+<a name="index-Ctrl_002dPageDown"></a>
+<p>In the virtual consoles, you can use <tt class="key">Ctrl-Up</tt>, <tt class="key">Ctrl-Down</tt>,
+<tt class="key">Ctrl-PageUp</tt> and <tt class="key">Ctrl-PageDown</tt> to move in the back log.
+</p>
+<a name="index-Ctrl_002da-h"></a>
+<p>During emulation, if you are using the <samp>-nographic</samp> option, use
+<tt class="key">Ctrl-a h</tt> to get terminal commands:
+</p>
+<dl compact="compact">
+<dt><tt class="key">Ctrl-a h</tt></dt>
+<dd><a name="index-Ctrl_002da-h-1"></a>
+</dd>
+<dt><tt class="key">Ctrl-a ?</tt></dt>
+<dd><a name="index-Ctrl_002da-_003f"></a>
+<p>Print this help
+</p></dd>
+<dt><tt class="key">Ctrl-a x</tt></dt>
+<dd><a name="index-Ctrl_002da-x"></a>
+<p>Exit emulator
+</p></dd>
+<dt><tt class="key">Ctrl-a s</tt></dt>
+<dd><a name="index-Ctrl_002da-s"></a>
+<p>Save disk data back to file (if -snapshot)
+</p></dd>
+<dt><tt class="key">Ctrl-a t</tt></dt>
+<dd><a name="index-Ctrl_002da-t"></a>
+<p>Toggle console timestamps
+</p></dd>
+<dt><tt class="key">Ctrl-a b</tt></dt>
+<dd><a name="index-Ctrl_002da-b"></a>
+<p>Send break (magic sysrq in Linux)
+</p></dd>
+<dt><tt class="key">Ctrl-a c</tt></dt>
+<dd><a name="index-Ctrl_002da-c"></a>
+<p>Switch between console and monitor
+</p></dd>
+<dt><tt class="key">Ctrl-a Ctrl-a</tt></dt>
+<dd><a name="index-Ctrl_002da-a"></a>
+<p>Send Ctrl-a
+</p></dd>
+</dl>
+
+
+<hr>
+<a name="pcsys_005fmonitor"></a>
+<a name="QEMU-Monitor"></a>
+<h3 class="section">3.5 QEMU Monitor</h3>
+<a name="index-QEMU-monitor"></a>
+
+<p>The QEMU monitor is used to give complex commands to the QEMU
+emulator. You can use it to:
+</p>
+<ul class="no-bullet">
+<li>- Remove or insert removable media images
+(such as CD-ROM or floppies).
+
+</li><li>- Freeze/unfreeze the Virtual Machine (VM) and save or restore its state
+from a disk file.
+
+</li><li>- Inspect the VM state without an external debugger.
+
+</li></ul>
+
+<a name="Commands"></a>
+<h4 class="subsection">3.5.1 Commands</h4>
+
+<p>The following commands are available:
+</p>
+<dl compact="compact">
+<dt><samp>help or ? [<var>cmd</var>]</samp></dt>
+<dd><a name="index-help"></a>
+<p>Show the help for all commands or just for command <var>cmd</var>.
+</p></dd>
+<dt><samp>commit</samp></dt>
+<dd><a name="index-commit"></a>
+<p>Commit changes to the disk images (if -snapshot is used) or backing files.
+If the backing file is smaller than the snapshot, then the backing file will be
+resized to be the same size as the snapshot.  If the snapshot is smaller than
+the backing file, the backing file will not be truncated.  If you want the
+backing file to match the size of the smaller snapshot, you can safely truncate
+it yourself once the commit operation successfully completes.
+</p></dd>
+<dt><samp>q or quit</samp></dt>
+<dd><a name="index-quit"></a>
+<p>Quit the emulator.
+</p></dd>
+<dt><samp>block_resize</samp></dt>
+<dd><a name="index-block_005fresize"></a>
+<p>Resize a block image while a guest is running.  Usually requires guest
+action to see the updated size.  Resize to a lower size is supported,
+but should be used with extreme caution.  Note that this command only
+resizes image files, it can not resize block devices like LVM volumes.
+</p></dd>
+<dt><samp>block_stream</samp></dt>
+<dd><a name="index-block_005fstream"></a>
+<p>Copy data from a backing file into a block device.
+</p></dd>
+<dt><samp>block_job_set_speed</samp></dt>
+<dd><a name="index-block_005fjob_005fset_005fspeed"></a>
+<p>Set maximum speed for a background block operation.
+</p></dd>
+<dt><samp>block_job_cancel</samp></dt>
+<dd><a name="index-block_005fjob_005fcancel"></a>
+<p>Stop an active background block operation (streaming, mirroring).
+</p></dd>
+<dt><samp>block_job_complete</samp></dt>
+<dd><a name="index-block_005fjob_005fcomplete"></a>
+<p>Manually trigger completion of an active background block operation.
+For mirroring, this will switch the device to the destination path.
+</p></dd>
+<dt><samp>block_job_pause</samp></dt>
+<dd><a name="index-block_005fjob_005fpause"></a>
+<p>Pause an active block streaming operation.
+</p></dd>
+<dt><samp>block_job_resume</samp></dt>
+<dd><a name="index-block_005fjob_005fresume"></a>
+<p>Resume a paused block streaming operation.
+</p></dd>
+<dt><samp>eject [-f] <var>device</var></samp></dt>
+<dd><a name="index-eject"></a>
+<p>Eject a removable medium (use -f to force it).
+</p></dd>
+<dt><samp>drive_del <var>device</var></samp></dt>
+<dd><a name="index-drive_005fdel"></a>
+<p>Remove host block device.  The result is that guest generated IO is no longer
+submitted against the host device underlying the disk.  Once a drive has
+been deleted, the QEMU Block layer returns -EIO which results in IO
+errors in the guest for applications that are reading/writing to the device.
+These errors are always reported to the guest, regardless of the drive&rsquo;s error
+actions (drive options rerror, werror).
+</p></dd>
+<dt><samp>change <var>device</var> <var>setting</var></samp></dt>
+<dd><a name="index-change"></a>
+<p>Change the configuration of a device.
+</p>
+<dl compact="compact">
+<dt><samp>change <var>diskdevice</var> <var>filename</var> [<var>format</var>]</samp></dt>
+<dd><p>Change the medium for a removable disk device to point to <var>filename</var>. eg
+</p>
+<div class="example">
+<pre class="example">(qemu) change ide1-cd0 /path/to/some.iso
+</pre></div>
+
+<p><var>format</var> is optional.
+</p>
+</dd>
+<dt><samp>change vnc <var>display</var>,<var>options</var></samp></dt>
+<dd><p>Change the configuration of the VNC server. The valid syntax for <var>display</var>
+and <var>options</var> are described at <a href="#sec_005finvocation">sec_invocation</a>. eg
+</p>
+<div class="example">
+<pre class="example">(qemu) change vnc localhost:1
+</pre></div>
+
+</dd>
+<dt><samp>change vnc password [<var>password</var>]</samp></dt>
+<dd>
+<p>Change the password associated with the VNC server. If the new password is not
+supplied, the monitor will prompt for it to be entered. VNC passwords are only
+significant up to 8 letters. eg
+</p>
+<div class="example">
+<pre class="example">(qemu) change vnc password
+Password: ********
+</pre></div>
+
+</dd>
+</dl>
+</dd>
+<dt><samp>screendump <var>filename</var></samp></dt>
+<dd><a name="index-screendump"></a>
+<p>Save screen into PPM image <var>filename</var>.
+</p></dd>
+<dt><samp>logfile <var>filename</var></samp></dt>
+<dd><a name="index-logfile"></a>
+<p>Output logs to <var>filename</var>.
+</p></dd>
+<dt><samp>trace-event</samp></dt>
+<dd><a name="index-trace_002devent"></a>
+<p>changes status of a trace event
+</p></dd>
+<dt><samp>trace-file on|off|flush</samp></dt>
+<dd><a name="index-trace_002dfile"></a>
+<p>Open, close, or flush the trace file.  If no argument is given, the status of the trace file is displayed.
+</p></dd>
+<dt><samp>log <var>item1</var>[,...]</samp></dt>
+<dd><a name="index-log"></a>
+<p>Activate logging of the specified items.
+</p></dd>
+<dt><samp>savevm [<var>tag</var>|<var>id</var>]</samp></dt>
+<dd><a name="index-savevm"></a>
+<p>Create a snapshot of the whole virtual machine. If <var>tag</var> is
+provided, it is used as human readable identifier. If there is already
+a snapshot with the same tag or ID, it is replaced. More info at
+<a href="#vm_005fsnapshots">vm_snapshots</a>.
+</p></dd>
+<dt><samp>loadvm <var>tag</var>|<var>id</var></samp></dt>
+<dd><a name="index-loadvm"></a>
+<p>Set the whole virtual machine to the snapshot identified by the tag
+<var>tag</var> or the unique snapshot ID <var>id</var>.
+</p></dd>
+<dt><samp>delvm <var>tag</var>|<var>id</var></samp></dt>
+<dd><a name="index-delvm"></a>
+<p>Delete the snapshot identified by <var>tag</var> or <var>id</var>.
+</p></dd>
+<dt><samp>singlestep [off]</samp></dt>
+<dd><a name="index-singlestep"></a>
+<p>Run the emulation in single step mode.
+If called with option off, the emulation returns to normal mode.
+</p></dd>
+<dt><samp>stop</samp></dt>
+<dd><a name="index-stop"></a>
+<p>Stop emulation.
+</p></dd>
+<dt><samp>c or cont</samp></dt>
+<dd><a name="index-cont"></a>
+<p>Resume emulation.
+</p></dd>
+<dt><samp>system_wakeup</samp></dt>
+<dd><a name="index-system_005fwakeup"></a>
+<p>Wakeup guest from suspend.
+</p></dd>
+<dt><samp>gdbserver [<var>port</var>]</samp></dt>
+<dd><a name="index-gdbserver"></a>
+<p>Start gdbserver session (default <var>port</var>=1234)
+</p></dd>
+<dt><samp>x/fmt <var>addr</var></samp></dt>
+<dd><a name="index-x"></a>
+<p>Virtual memory dump starting at <var>addr</var>.
+</p></dd>
+<dt><samp>xp /<var>fmt</var> <var>addr</var></samp></dt>
+<dd><a name="index-xp"></a>
+<p>Physical memory dump starting at <var>addr</var>.
+</p>
+<p><var>fmt</var> is a format which tells the command how to format the
+data. Its syntax is: <samp>/{count}{format}{size}</samp>
+</p>
+<dl compact="compact">
+<dt><var>count</var></dt>
+<dd><p>is the number of items to be dumped.
+</p>
+</dd>
+<dt><var>format</var></dt>
+<dd><p>can be x (hex), d (signed decimal), u (unsigned decimal), o (octal),
+c (char) or i (asm instruction).
+</p>
+</dd>
+<dt><var>size</var></dt>
+<dd><p>can be b (8 bits), h (16 bits), w (32 bits) or g (64 bits). On x86,
+<code>h</code> or <code>w</code> can be specified with the <code>i</code> format to
+respectively select 16 or 32 bit code instruction size.
+</p>
+</dd>
+</dl>
+
+<p>Examples:
+</p><ul>
+<li> Dump 10 instructions at the current instruction pointer:
+<div class="example">
+<pre class="example">(qemu) x/10i $eip
+0x90107063:  ret
+0x90107064:  sti
+0x90107065:  lea    0x0(%esi,1),%esi
+0x90107069:  lea    0x0(%edi,1),%edi
+0x90107070:  ret
+0x90107071:  jmp    0x90107080
+0x90107073:  nop
+0x90107074:  nop
+0x90107075:  nop
+0x90107076:  nop
+</pre></div>
+
+</li><li> Dump 80 16 bit values at the start of the video memory.
+<div class="smallexample">
+<pre class="smallexample">(qemu) xp/80hx 0xb8000
+0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42
+0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41
+0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72
+0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73
+0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20
+0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720
+0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+</pre></div>
+</li></ul>
+</dd>
+<dt><samp>p or print/<var>fmt</var> <var>expr</var></samp></dt>
+<dd><a name="index-print"></a>
+<p>Print expression value. Only the <var>format</var> part of <var>fmt</var> is
+used.
+</p></dd>
+<dt><samp>i/<var>fmt</var> <var>addr</var> [.<var>index</var>]</samp></dt>
+<dd><a name="index-i"></a>
+<p>Read I/O port.
+</p></dd>
+<dt><samp>o/<var>fmt</var> <var>addr</var> <var>val</var></samp></dt>
+<dd><a name="index-o"></a>
+<p>Write to I/O port.
+</p></dd>
+<dt><samp>sendkey <var>keys</var></samp></dt>
+<dd><a name="index-sendkey"></a>
+<p>Send <var>keys</var> to the guest. <var>keys</var> could be the name of the
+key or the raw value in hexadecimal format. Use <code>-</code> to press
+several keys simultaneously. Example:
+</p><div class="example">
+<pre class="example">sendkey ctrl-alt-f1
+</pre></div>
+
+<p>This command is useful to send keys that your graphical user interface
+intercepts at low level, such as <code>ctrl-alt-f1</code> in X Window.
+</p></dd>
+<dt><samp>system_reset</samp></dt>
+<dd><a name="index-system_005freset"></a>
+<p>Reset the system.
+</p></dd>
+<dt><samp>system_powerdown</samp></dt>
+<dd><a name="index-system_005fpowerdown"></a>
+<p>Power down the system (if supported).
+</p></dd>
+<dt><samp>sum <var>addr</var> <var>size</var></samp></dt>
+<dd><a name="index-sum"></a>
+<p>Compute the checksum of a memory region.
+</p></dd>
+<dt><samp>usb_add <var>devname</var></samp></dt>
+<dd><a name="index-usb_005fadd"></a>
+<p>Add the USB device <var>devname</var>.  For details of available devices see
+<a href="#usb_005fdevices">usb_devices</a>
+</p></dd>
+<dt><samp>usb_del <var>devname</var></samp></dt>
+<dd><a name="index-usb_005fdel"></a>
+<p>Remove the USB device <var>devname</var> from the QEMU virtual USB
+hub. <var>devname</var> has the syntax <code>bus.addr</code>. Use the monitor
+command <code>info usb</code> to see the devices you can remove.
+</p></dd>
+<dt><samp>device_add <var>config</var></samp></dt>
+<dd><a name="index-device_005fadd"></a>
+<p>Add device.
+</p></dd>
+<dt><samp>device_del <var>id</var></samp></dt>
+<dd><a name="index-device_005fdel"></a>
+<p>Remove device <var>id</var>.
+</p></dd>
+<dt><samp>cpu <var>index</var></samp></dt>
+<dd><a name="index-cpu"></a>
+<p>Set the default CPU.
+</p></dd>
+<dt><samp>mouse_move <var>dx</var> <var>dy</var> [<var>dz</var>]</samp></dt>
+<dd><a name="index-mouse_005fmove"></a>
+<p>Move the active mouse to the specified coordinates <var>dx</var> <var>dy</var>
+with optional scroll axis <var>dz</var>.
+</p></dd>
+<dt><samp>mouse_button <var>val</var></samp></dt>
+<dd><a name="index-mouse_005fbutton"></a>
+<p>Change the active mouse button state <var>val</var> (1=L, 2=M, 4=R).
+</p></dd>
+<dt><samp>mouse_set <var>index</var></samp></dt>
+<dd><a name="index-mouse_005fset"></a>
+<p>Set which mouse device receives events at given <var>index</var>, index
+can be obtained with
+</p><div class="example">
+<pre class="example">info mice
+</pre></div>
+</dd>
+<dt><samp>wavcapture <var>filename</var> [<var>frequency</var> [<var>bits</var> [<var>channels</var>]]]</samp></dt>
+<dd><a name="index-wavcapture"></a>
+<p>Capture audio into <var>filename</var>. Using sample rate <var>frequency</var>
+bits per sample <var>bits</var> and number of channels <var>channels</var>.
+</p>
+<p>Defaults:
+</p><ul class="no-bullet">
+<li>- Sample rate = 44100 Hz - CD quality
+</li><li>- Bits = 16
+</li><li>- Number of channels = 2 - Stereo
+</li></ul>
+</dd>
+<dt><samp>stopcapture <var>index</var></samp></dt>
+<dd><a name="index-stopcapture"></a>
+<p>Stop capture with a given <var>index</var>, index can be obtained with
+</p><div class="example">
+<pre class="example">info capture
+</pre></div>
+</dd>
+<dt><samp>memsave <var>addr</var> <var>size</var> <var>file</var></samp></dt>
+<dd><a name="index-memsave"></a>
+<p>save to disk virtual memory dump starting at <var>addr</var> of size <var>size</var>.
+</p></dd>
+<dt><samp>pmemsave <var>addr</var> <var>size</var> <var>file</var></samp></dt>
+<dd><a name="index-pmemsave"></a>
+<p>save to disk physical memory dump starting at <var>addr</var> of size <var>size</var>.
+</p></dd>
+<dt><samp>boot_set <var>bootdevicelist</var></samp></dt>
+<dd><a name="index-boot_005fset"></a>
+<p>Define new values for the boot device list. Those values will override
+the values specified on the command line through the <code>-boot</code> option.
+</p>
+<p>The values that can be specified here depend on the machine type, but are
+the same that can be specified in the <code>-boot</code> command line option.
+</p></dd>
+<dt><samp>nmi <var>cpu</var></samp></dt>
+<dd><a name="index-nmi"></a>
+<p>Inject an NMI on the default CPU (x86/s390) or all CPUs (ppc64).
+</p>
+</dd>
+<dt><samp>ringbuf_write <var>device</var> <var>data</var></samp></dt>
+<dd><a name="index-ringbuf_005fwrite"></a>
+<p>Write <var>data</var> to ring buffer character device <var>device</var>.
+<var>data</var> must be a UTF-8 string.
+</p>
+</dd>
+<dt><samp>ringbuf_read <var>device</var></samp></dt>
+<dd><a name="index-ringbuf_005fread"></a>
+<p>Read and print up to <var>size</var> bytes from ring buffer character
+device <var>device</var>.
+Certain non-printable characters are printed \uXXXX, where XXXX is the
+character code in hexadecimal.  Character \ is printed \.
+Bug: can screw up when the buffer contains invalid UTF-8 sequences,
+NUL characters, after the ring buffer lost data, and when reading
+stops because the size limit is reached.
+</p>
+</dd>
+<dt><samp>migrate [-d] [-b] [-i] <var>uri</var></samp></dt>
+<dd><a name="index-migrate"></a>
+<p>Migrate to <var>uri</var> (using -d to not wait for completion).
+-b for migration with full copy of disk
+-i for migration with incremental copy of disk (base image is shared)
+</p></dd>
+<dt><samp>migrate_cancel</samp></dt>
+<dd><a name="index-migrate_005fcancel"></a>
+<p>Cancel the current VM migration.
+</p>
+</dd>
+<dt><samp>migrate_incoming <var>uri</var></samp></dt>
+<dd><a name="index-migrate_005fincoming"></a>
+<p>Continue an incoming migration using the <var>uri</var> (that has the same syntax
+as the -incoming option).
+</p>
+</dd>
+<dt><samp>migrate_set_cache_size <var>value</var></samp></dt>
+<dd><a name="index-migrate_005fset_005fcache_005fsize"></a>
+<p>Set cache size to <var>value</var> (in bytes) for xbzrle migrations.
+</p></dd>
+<dt><samp>migrate_set_speed <var>value</var></samp></dt>
+<dd><a name="index-migrate_005fset_005fspeed"></a>
+<p>Set maximum speed to <var>value</var> (in bytes) for migrations.
+</p></dd>
+<dt><samp>migrate_set_downtime <var>second</var></samp></dt>
+<dd><a name="index-migrate_005fset_005fdowntime"></a>
+<p>Set maximum tolerated downtime (in seconds) for migration.
+</p></dd>
+<dt><samp>migrate_set_capability <var>capability</var> <var>state</var></samp></dt>
+<dd><a name="index-migrate_005fset_005fcapability"></a>
+<p>Enable/Disable the usage of a capability <var>capability</var> for migration.
+</p></dd>
+<dt><samp>client_migrate_info <var>protocol</var> <var>hostname</var> <var>port</var> <var>tls-port</var> <var>cert-subject</var></samp></dt>
+<dd><a name="index-client_005fmigrate_005finfo"></a>
+<p>Set the spice/vnc connection info for the migration target.  The spice/vnc
+server will ask the spice/vnc client to automatically reconnect using the
+new parameters (if specified) once the vm migration finished successfully.
+</p></dd>
+<dt><samp>dump-guest-memory [-p] <var>filename</var> <var>begin</var> <var>length</var></samp></dt>
+<dt><samp>dump-guest-memory [-z|-l|-s] <var>filename</var></samp></dt>
+<dd><a name="index-dump_002dguest_002dmemory"></a>
+<p>Dump guest memory to <var>protocol</var>. The file can be processed with crash or
+gdb. Without -z|-l|-s, the dump format is ELF.
+-p: do paging to get guest&rsquo;s memory mapping.
+-z: dump in kdump-compressed format, with zlib compression.
+-l: dump in kdump-compressed format, with lzo compression.
+-s: dump in kdump-compressed format, with snappy compression.
+filename: dump file name.
+begin: the starting physical address. It&rsquo;s optional, and should be
+specified together with length.
+length: the memory size, in bytes. It&rsquo;s optional, and should be specified
+together with begin.
+</p></dd>
+<dt><samp>snapshot_blkdev</samp></dt>
+<dd><a name="index-snapshot_005fblkdev"></a>
+<p>Snapshot device, using snapshot file as target if provided
+</p></dd>
+<dt><samp>snapshot_blkdev_internal</samp></dt>
+<dd><a name="index-snapshot_005fblkdev_005finternal"></a>
+<p>Take an internal snapshot on device if it support
+</p></dd>
+<dt><samp>snapshot_delete_blkdev_internal</samp></dt>
+<dd><a name="index-snapshot_005fdelete_005fblkdev_005finternal"></a>
+<p>Delete an internal snapshot on device if it support
+</p></dd>
+<dt><samp>drive_mirror</samp></dt>
+<dd><a name="index-drive_005fmirror"></a>
+<p>Start mirroring a block device&rsquo;s writes to a new destination,
+using the specified target.
+</p></dd>
+<dt><samp>drive_backup</samp></dt>
+<dd><a name="index-drive_005fbackup"></a>
+<p>Start a point-in-time copy of a block device to a specificed target.
+</p></dd>
+<dt><samp>drive_add</samp></dt>
+<dd><a name="index-drive_005fadd"></a>
+<p>Add drive to PCI storage controller.
+</p></dd>
+<dt><samp>pcie_aer_inject_error</samp></dt>
+<dd><a name="index-pcie_005faer_005finject_005ferror"></a>
+<p>Inject PCIe AER error
+</p></dd>
+<dt><samp>host_net_add</samp></dt>
+<dd><a name="index-host_005fnet_005fadd"></a>
+<p>Add host VLAN client.
+</p></dd>
+<dt><samp>host_net_remove</samp></dt>
+<dd><a name="index-host_005fnet_005fremove"></a>
+<p>Remove host VLAN client.
+</p></dd>
+<dt><samp>netdev_add</samp></dt>
+<dd><a name="index-netdev_005fadd"></a>
+<p>Add host network device.
+</p></dd>
+<dt><samp>netdev_del</samp></dt>
+<dd><a name="index-netdev_005fdel"></a>
+<p>Remove host network device.
+</p></dd>
+<dt><samp>object_add</samp></dt>
+<dd><a name="index-object_005fadd"></a>
+<p>Create QOM object.
+</p></dd>
+<dt><samp>object_del</samp></dt>
+<dd><a name="index-object_005fdel"></a>
+<p>Destroy QOM object.
+</p></dd>
+<dt><samp>hostfwd_add</samp></dt>
+<dd><a name="index-hostfwd_005fadd"></a>
+<p>Redirect TCP or UDP connections from host to guest (requires -net user).
+</p></dd>
+<dt><samp>hostfwd_remove</samp></dt>
+<dd><a name="index-hostfwd_005fremove"></a>
+<p>Remove host-to-guest TCP or UDP redirection.
+</p></dd>
+<dt><samp>balloon <var>value</var></samp></dt>
+<dd><a name="index-balloon"></a>
+<p>Request VM to change its memory allocation to <var>value</var> (in MB).
+</p></dd>
+<dt><samp>set_link <var>name</var> [on|off]</samp></dt>
+<dd><a name="index-set_005flink"></a>
+<p>Switch link <var>name</var> on (i.e. up) or off (i.e. down).
+</p></dd>
+<dt><samp>watchdog_action</samp></dt>
+<dd><a name="index-watchdog_005faction"></a>
+<p>Change watchdog action.
+</p></dd>
+<dt><samp>acl_show <var>aclname</var></samp></dt>
+<dd><a name="index-acl_005fshow"></a>
+<p>List all the matching rules in the access control list, and the default
+policy. There are currently two named access control lists,
+<var>vnc.x509dname</var> and <var>vnc.username</var> matching on the x509 client
+certificate distinguished name, and SASL username respectively.
+</p></dd>
+<dt><samp>acl_policy <var>aclname</var> <code>allow|deny</code></samp></dt>
+<dd><a name="index-acl_005fpolicy"></a>
+<p>Set the default access control list policy, used in the event that
+none of the explicit rules match. The default policy at startup is
+always <code>deny</code>.
+</p></dd>
+<dt><samp>acl_add <var>aclname</var> <var>match</var> <code>allow|deny</code> [<var>index</var>]</samp></dt>
+<dd><a name="index-acl_005fadd"></a>
+<p>Add a match rule to the access control list, allowing or denying access.
+The match will normally be an exact username or x509 distinguished name,
+but can optionally include wildcard globs. eg <code>*@EXAMPLE.COM</code> to
+allow all users in the <code>EXAMPLE.COM</code> kerberos realm. The match will
+normally be appended to the end of the ACL, but can be inserted
+earlier in the list if the optional <var>index</var> parameter is supplied.
+</p></dd>
+<dt><samp>acl_remove <var>aclname</var> <var>match</var></samp></dt>
+<dd><a name="index-acl_005fremove"></a>
+<p>Remove the specified match rule from the access control list.
+</p></dd>
+<dt><samp>acl_reset <var>aclname</var></samp></dt>
+<dd><a name="index-acl_005freset"></a>
+<p>Remove all matches from the access control list, and set the default
+policy back to <code>deny</code>.
+</p></dd>
+<dt><samp>nbd_server_start <var>host</var>:<var>port</var></samp></dt>
+<dd><a name="index-nbd_005fserver_005fstart"></a>
+<p>Start an NBD server on the given host and/or port.  If the <samp>-a</samp>
+option is included, all of the virtual machine&rsquo;s block devices that
+have an inserted media on them are automatically exported; in this case,
+the <samp>-w</samp> option makes the devices writable too.
+</p></dd>
+<dt><samp>nbd_server_add <var>device</var></samp></dt>
+<dd><a name="index-nbd_005fserver_005fadd"></a>
+<p>Export a block device through QEMU&rsquo;s NBD server, which must be started
+beforehand with <code>nbd_server_start</code>.  The <samp>-w</samp> option makes the
+exported device writable too.
+</p></dd>
+<dt><samp>nbd_server_stop</samp></dt>
+<dd><a name="index-nbd_005fserver_005fstop"></a>
+<p>Stop the QEMU embedded NBD server.
+</p></dd>
+<dt><samp>mce <var>cpu</var> <var>bank</var> <var>status</var> <var>mcgstatus</var> <var>addr</var> <var>misc</var></samp></dt>
+<dd><a name="index-mce-_0028x86_0029"></a>
+<p>Inject an MCE on the given CPU (x86 only).
+</p></dd>
+<dt><samp>getfd <var>fdname</var></samp></dt>
+<dd><a name="index-getfd"></a>
+<p>If a file descriptor is passed alongside this command using the SCM_RIGHTS
+mechanism on unix sockets, it is stored using the name <var>fdname</var> for
+later use by other monitor commands.
+</p></dd>
+<dt><samp>closefd <var>fdname</var></samp></dt>
+<dd><a name="index-closefd"></a>
+<p>Close the file descriptor previously assigned to <var>fdname</var> using the
+<code>getfd</code> command. This is only needed if the file descriptor was never
+used by another monitor command.
+</p></dd>
+<dt><samp>block_passwd <var>device</var> <var>password</var></samp></dt>
+<dd><a name="index-block_005fpasswd"></a>
+<p>Set the encrypted device <var>device</var> password to <var>password</var>
+</p></dd>
+<dt><samp>block_set_io_throttle <var>device</var> <var>bps</var> <var>bps_rd</var> <var>bps_wr</var> <var>iops</var> <var>iops_rd</var> <var>iops_wr</var></samp></dt>
+<dd><a name="index-block_005fset_005fio_005fthrottle"></a>
+<p>Change I/O throttle limits for a block drive to <var>bps</var> <var>bps_rd</var> <var>bps_wr</var> <var>iops</var> <var>iops_rd</var> <var>iops_wr</var>
+</p></dd>
+<dt><samp>set_password [ vnc | spice ] password [ action-if-connected ]</samp></dt>
+<dd><a name="index-set_005fpassword"></a>
+<p>Change spice/vnc password.  Use zero to make the password stay valid
+forever.  <var>action-if-connected</var> specifies what should happen in
+case a connection is established: <var>fail</var> makes the password change
+fail.  <var>disconnect</var> changes the password and disconnects the
+client.  <var>keep</var> changes the password and keeps the connection up.
+<var>keep</var> is the default.
+</p></dd>
+<dt><samp>expire_password [ vnc | spice ] expire-time</samp></dt>
+<dd><a name="index-expire_005fpassword"></a>
+<p>Specify when a password for spice/vnc becomes
+invalid. <var>expire-time</var> accepts:
+</p>
+<dl compact="compact">
+<dt><var>now</var></dt>
+<dd><p>Invalidate password instantly.
+</p>
+</dd>
+<dt><var>never</var></dt>
+<dd><p>Password stays valid forever.
+</p>
+</dd>
+<dt><var>+nsec</var></dt>
+<dd><p>Password stays valid for <var>nsec</var> seconds starting now.
+</p>
+</dd>
+<dt><var>nsec</var></dt>
+<dd><p>Password is invalidated at the given time.  <var>nsec</var> are the seconds
+passed since 1970, i.e. unix epoch.
+</p>
+</dd>
+</dl>
+</dd>
+<dt><samp>chardev-add args</samp></dt>
+<dd><a name="index-chardev_002dadd"></a>
+<p>chardev_add accepts the same parameters as the -chardev command line switch.
+</p>
+</dd>
+<dt><samp>chardev-remove id</samp></dt>
+<dd><a name="index-chardev_002dremove"></a>
+<p>Removes the chardev <var>id</var>.
+</p>
+</dd>
+<dt><samp>qemu-io <var>device</var> <var>command</var></samp></dt>
+<dd><a name="index-qemu_002dio"></a>
+<p>Executes a qemu-io command on the given block device.
+</p>
+</dd>
+<dt><samp>cpu-add <var>id</var></samp></dt>
+<dd><a name="index-cpu_002dadd"></a>
+<p>Add CPU with id <var>id</var>
+</p></dd>
+<dt><samp>qom-list [<var>path</var>]</samp></dt>
+<dd><p>Print QOM properties of object at location <var>path</var>
+</p></dd>
+<dt><samp>qom-set <var>path</var> <var>property</var> <var>value</var></samp></dt>
+<dd><p>Set QOM property <var>property</var> of object at location <var>path</var> to value <var>value</var>
+</p></dd>
+<dt><samp>info <var>subcommand</var></samp></dt>
+<dd><a name="index-info"></a>
+<p>Show various information about the system state.
+</p>
+<dl compact="compact">
+<dt><samp>info version</samp></dt>
+<dd><p>show the version of QEMU
+</p></dd>
+<dt><samp>info network</samp></dt>
+<dd><p>show the various VLANs and the associated devices
+</p></dd>
+<dt><samp>info chardev</samp></dt>
+<dd><p>show the character devices
+</p></dd>
+<dt><samp>info block</samp></dt>
+<dd><p>show the block devices
+</p></dd>
+<dt><samp>info blockstats</samp></dt>
+<dd><p>show block device statistics
+</p></dd>
+<dt><samp>info registers</samp></dt>
+<dd><p>show the cpu registers
+</p></dd>
+<dt><samp>info cpus</samp></dt>
+<dd><p>show infos for each CPU
+</p></dd>
+<dt><samp>info history</samp></dt>
+<dd><p>show the command line history
+</p></dd>
+<dt><samp>info irq</samp></dt>
+<dd><p>show the interrupts statistics (if available)
+</p></dd>
+<dt><samp>info pic</samp></dt>
+<dd><p>show i8259 (PIC) state
+</p></dd>
+<dt><samp>info pci</samp></dt>
+<dd><p>show emulated PCI device info
+</p></dd>
+<dt><samp>info tlb</samp></dt>
+<dd><p>show virtual to physical memory mappings (i386, SH4, SPARC, PPC, and Xtensa only)
+</p></dd>
+<dt><samp>info mem</samp></dt>
+<dd><p>show the active virtual memory mappings (i386 only)
+</p></dd>
+<dt><samp>info jit</samp></dt>
+<dd><p>show dynamic compiler info
+</p></dd>
+<dt><samp>info numa</samp></dt>
+<dd><p>show NUMA information
+</p></dd>
+<dt><samp>info kvm</samp></dt>
+<dd><p>show KVM information
+</p></dd>
+<dt><samp>info usb</samp></dt>
+<dd><p>show USB devices plugged on the virtual USB hub
+</p></dd>
+<dt><samp>info usbhost</samp></dt>
+<dd><p>show all USB host devices
+</p></dd>
+<dt><samp>info profile</samp></dt>
+<dd><p>show profiling information
+</p></dd>
+<dt><samp>info capture</samp></dt>
+<dd><p>show information about active capturing
+</p></dd>
+<dt><samp>info snapshots</samp></dt>
+<dd><p>show list of VM snapshots
+</p></dd>
+<dt><samp>info status</samp></dt>
+<dd><p>show the current VM status (running|paused)
+</p></dd>
+<dt><samp>info mice</samp></dt>
+<dd><p>show which guest mouse is receiving events
+</p></dd>
+<dt><samp>info vnc</samp></dt>
+<dd><p>show the vnc server status
+</p></dd>
+<dt><samp>info name</samp></dt>
+<dd><p>show the current VM name
+</p></dd>
+<dt><samp>info uuid</samp></dt>
+<dd><p>show the current VM UUID
+</p></dd>
+<dt><samp>info cpustats</samp></dt>
+<dd><p>show CPU statistics
+</p></dd>
+<dt><samp>info usernet</samp></dt>
+<dd><p>show user network stack connection states
+</p></dd>
+<dt><samp>info migrate</samp></dt>
+<dd><p>show migration status
+</p></dd>
+<dt><samp>info migrate_capabilities</samp></dt>
+<dd><p>show current migration capabilities
+</p></dd>
+<dt><samp>info migrate_cache_size</samp></dt>
+<dd><p>show current migration XBZRLE cache size
+</p></dd>
+<dt><samp>info balloon</samp></dt>
+<dd><p>show balloon information
+</p></dd>
+<dt><samp>info qtree</samp></dt>
+<dd><p>show device tree
+</p></dd>
+<dt><samp>info qdm</samp></dt>
+<dd><p>show qdev device model list
+</p></dd>
+<dt><samp>info qom-tree</samp></dt>
+<dd><p>show object composition tree
+</p></dd>
+<dt><samp>info roms</samp></dt>
+<dd><p>show roms
+</p></dd>
+<dt><samp>info tpm</samp></dt>
+<dd><p>show the TPM device
+</p></dd>
+<dt><samp>info memory-devices</samp></dt>
+<dd><p>show the memory devices
+</p></dd>
+</dl>
+</dd>
+<dt><samp>info trace-events</samp></dt>
+<dd><p>show available trace events and their state
+</p></dd>
+</dl>
+
+<a name="Integer-expressions"></a>
+<h4 class="subsection">3.5.2 Integer expressions</h4>
+
+<p>The monitor understands integers expressions for every integer
+argument. You can use register names to get the value of specifics
+CPU registers by prefixing them with <em>$</em>.
+</p>
+<hr>
+<a name="disk_005fimages"></a>
+<a name="Disk-Images"></a>
+<h3 class="section">3.6 Disk Images</h3>
+
+<p>Since version 0.6.1, QEMU supports many disk image formats, including
+growable disk images (their size increase as non empty sectors are
+written), compressed and encrypted disk images. Version 0.8.3 added
+the new qcow2 disk image format which is essential to support VM
+snapshots.
+</p>
+
+<hr>
+<a name="disk_005fimages_005fquickstart"></a>
+<a name="Quick-start-for-disk-image-creation"></a>
+<h4 class="subsection">3.6.1 Quick start for disk image creation</h4>
+
+<p>You can create a disk image with the command:
+</p><div class="example">
+<pre class="example">qemu-img create myimage.img mysize
+</pre></div>
+<p>where <var>myimage.img</var> is the disk image filename and <var>mysize</var> is its
+size in kilobytes. You can add an <code>M</code> suffix to give the size in
+megabytes and a <code>G</code> suffix for gigabytes.
+</p>
+<p>See <a href="#qemu_005fimg_005finvocation">qemu_img_invocation</a> for more information.
+</p>
+<hr>
+<a name="disk_005fimages_005fsnapshot_005fmode"></a>
+<a name="Snapshot-mode"></a>
+<h4 class="subsection">3.6.2 Snapshot mode</h4>
+
+<p>If you use the option <samp>-snapshot</samp>, all disk images are
+considered as read only. When sectors in written, they are written in
+a temporary file created in <samp>/tmp</samp>. You can however force the
+write back to the raw disk images by using the <code>commit</code> monitor
+command (or <tt class="key">C-a s</tt> in the serial console).
+</p>
+<hr>
+<a name="vm_005fsnapshots"></a>
+<a name="VM-snapshots"></a>
+<h4 class="subsection">3.6.3 VM snapshots</h4>
+
+<p>VM snapshots are snapshots of the complete virtual machine including
+CPU state, RAM, device state and the content of all the writable
+disks. In order to use VM snapshots, you must have at least one non
+removable and writable block device using the <code>qcow2</code> disk image
+format. Normally this device is the first virtual hard drive.
+</p>
+<p>Use the monitor command <code>savevm</code> to create a new VM snapshot or
+replace an existing one. A human readable name can be assigned to each
+snapshot in addition to its numerical ID.
+</p>
+<p>Use <code>loadvm</code> to restore a VM snapshot and <code>delvm</code> to remove
+a VM snapshot. <code>info snapshots</code> lists the available snapshots
+with their associated information:
+</p>
+<div class="example">
+<pre class="example">(qemu) info snapshots
+Snapshot devices: hda
+Snapshot list (from hda):
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+1         start                   41M 2006-08-06 12:38:02   00:00:14.954
+2                                 40M 2006-08-06 12:43:29   00:00:18.633
+3         msys                    40M 2006-08-06 12:44:04   00:00:23.514
+</pre></div>
+
+<p>A VM snapshot is made of a VM state info (its size is shown in
+<code>info snapshots</code>) and a snapshot of every writable disk image.
+The VM state info is stored in the first <code>qcow2</code> non removable
+and writable block device. The disk image snapshots are stored in
+every disk image. The size of a snapshot in a disk image is difficult
+to evaluate and is not shown by <code>info snapshots</code> because the
+associated disk sectors are shared among all the snapshots to save
+disk space (otherwise each snapshot would need a full copy of all the
+disk images).
+</p>
+<p>When using the (unrelated) <code>-snapshot</code> option
+(<a href="#disk_005fimages_005fsnapshot_005fmode">disk_images_snapshot_mode</a>), you can always make VM snapshots,
+but they are deleted as soon as you exit QEMU.
+</p>
+<p>VM snapshots currently have the following known limitations:
+</p><ul>
+<li> They cannot cope with removable devices if they are removed or
+inserted after a snapshot is done.
+</li><li> A few device drivers still have incomplete snapshot support so their
+state is not saved or restored properly (in particular USB).
+</li></ul>
+
+<hr>
+<a name="qemu_005fimg_005finvocation"></a>
+<a name="qemu_002dimg-Invocation"></a>
+<h4 class="subsection">3.6.4 <code>qemu-img</code> Invocation</h4>
+
+<div class="example">
+<pre class="example">usage: qemu-img command [command options]
+</pre></div>
+
+<p>qemu-img allows you to create, convert and modify images offline. It can handle
+all image formats supported by QEMU.
+</p>
+<p><b>Warning:</b> Never use qemu-img to modify images in use by a running virtual
+machine or any other process; this may destroy the image. Also, be aware that
+querying an image that is being modified by another process may encounter
+inconsistent state.
+</p>
+
+<p>The following commands are supported:
+</p>
+<dl compact="compact">
+<dt><samp>check [-q] [-f <var>fmt</var>] [--output=<var>ofmt</var>] [-r [leaks | all]] [-T <var>src_cache</var>] <var>filename</var></samp></dt>
+<dt><samp>create [-q] [-f <var>fmt</var>] [-o <var>options</var>] <var>filename</var> [<var>size</var>]</samp></dt>
+<dt><samp>commit [-q] [-f <var>fmt</var>] [-t <var>cache</var>] [-b <var>base</var>] [-d] [-p] <var>filename</var></samp></dt>
+<dt><samp>compare [-f <var>fmt</var>] [-F <var>fmt</var>] [-T <var>src_cache</var>] [-p] [-q] [-s] <var>filename1</var> <var>filename2</var></samp></dt>
+<dt><samp>convert [-c] [-p] [-q] [-n] [-f <var>fmt</var>] [-t <var>cache</var>] [-T <var>src_cache</var>] [-O <var>output_fmt</var>] [-o <var>options</var>] [-s <var>snapshot_id_or_name</var>] [-l <var>snapshot_param</var>] [-S <var>sparse_size</var>] <var>filename</var> [<var>filename2</var> [...]] <var>output_filename</var></samp></dt>
+<dt><samp>info [-f <var>fmt</var>] [--output=<var>ofmt</var>] [--backing-chain] <var>filename</var></samp></dt>
+<dt><samp>map [-f <var>fmt</var>] [--output=<var>ofmt</var>] <var>filename</var></samp></dt>
+<dt><samp>snapshot [-q] [-l | -a <var>snapshot</var> | -c <var>snapshot</var> | -d <var>snapshot</var>] <var>filename</var></samp></dt>
+<dt><samp>rebase [-q] [-f <var>fmt</var>] [-t <var>cache</var>] [-T <var>src_cache</var>] [-p] [-u] -b <var>backing_file</var> [-F <var>backing_fmt</var>] <var>filename</var></samp></dt>
+<dt><samp>resize [-q] <var>filename</var> [+ | -]<var>size</var></samp></dt>
+<dt><samp>amend [-p] [-q] [-f <var>fmt</var>] [-t <var>cache</var>] -o <var>options</var> <var>filename</var></samp></dt>
+</dl>
+
+<p>Command parameters:
+</p><dl compact="compact">
+<dt><var>filename</var></dt>
+<dd><p>is a disk image filename
+</p></dd>
+<dt><var>fmt</var></dt>
+<dd><p>is the disk image format. It is guessed automatically in most cases. See below
+for a description of the supported disk formats.
+</p>
+</dd>
+<dt><var>&ndash;backing-chain</var></dt>
+<dd><p>will enumerate information about backing files in a disk image chain. Refer
+below for further description.
+</p>
+</dd>
+<dt><var>size</var></dt>
+<dd><p>is the disk image size in bytes. Optional suffixes <code>k</code> or <code>K</code>
+(kilobyte, 1024) <code>M</code> (megabyte, 1024k) and <code>G</code> (gigabyte, 1024M)
+and T (terabyte, 1024G) are supported.  <code>b</code> is ignored.
+</p>
+</dd>
+<dt><var>output_filename</var></dt>
+<dd><p>is the destination disk image filename
+</p>
+</dd>
+<dt><var>output_fmt</var></dt>
+<dd><p>is the destination format
+</p></dd>
+<dt><var>options</var></dt>
+<dd><p>is a comma separated list of format specific options in a
+name=value format. Use <code>-o ?</code> for an overview of the options supported
+by the used format or see the format descriptions below for details.
+</p></dd>
+<dt><var>snapshot_param</var></dt>
+<dd><p>is param used for internal snapshot, format is
+&rsquo;snapshot.id=[ID],snapshot.name=[NAME]&rsquo; or &rsquo;[ID_OR_NAME]&rsquo;
+</p></dd>
+<dt><var>snapshot_id_or_name</var></dt>
+<dd><p>is deprecated, use snapshot_param instead
+</p>
+</dd>
+<dt><var>-c</var></dt>
+<dd><p>indicates that target image must be compressed (qcow format only)
+</p></dd>
+<dt><var>-h</var></dt>
+<dd><p>with or without a command shows help and lists the supported formats
+</p></dd>
+<dt><var>-p</var></dt>
+<dd><p>display progress bar (compare, convert and rebase commands only).
+If the <var>-p</var> option is not used for a command that supports it, the
+progress is reported when the process receives a <code>SIGUSR1</code> signal.
+</p></dd>
+<dt><var>-q</var></dt>
+<dd><p>Quiet mode - do not print any output (except errors). There&rsquo;s no progress bar
+in case both <var>-q</var> and <var>-p</var> options are used.
+</p></dd>
+<dt><var>-S <var>size</var></var></dt>
+<dd><p>indicates the consecutive number of bytes that must contain only zeros
+for qemu-img to create a sparse image during conversion. This value is rounded
+down to the nearest 512 bytes. You may use the common size suffixes like
+<code>k</code> for kilobytes.
+</p></dd>
+<dt><var>-t <var>cache</var></var></dt>
+<dd><p>specifies the cache mode that should be used with the (destination) file. See
+the documentation of the emulator&rsquo;s <code>-drive cache=...</code> option for allowed
+values.
+</p></dd>
+<dt><var>-T <var>src_cache</var></var></dt>
+<dd><p>specifies the cache mode that should be used with the source file(s). See
+the documentation of the emulator&rsquo;s <code>-drive cache=...</code> option for allowed
+values.
+</p></dd>
+</dl>
+
+<p>Parameters to snapshot subcommand:
+</p>
+<dl compact="compact">
+<dt><samp>snapshot</samp></dt>
+<dd><p>is the name of the snapshot to create, apply or delete
+</p></dd>
+<dt><samp>-a</samp></dt>
+<dd><p>applies a snapshot (revert disk to saved state)
+</p></dd>
+<dt><samp>-c</samp></dt>
+<dd><p>creates a snapshot
+</p></dd>
+<dt><samp>-d</samp></dt>
+<dd><p>deletes a snapshot
+</p></dd>
+<dt><samp>-l</samp></dt>
+<dd><p>lists all snapshots in the given image
+</p></dd>
+</dl>
+
+<p>Parameters to compare subcommand:
+</p>
+<dl compact="compact">
+<dt><samp>-f</samp></dt>
+<dd><p>First image format
+</p></dd>
+<dt><samp>-F</samp></dt>
+<dd><p>Second image format
+</p></dd>
+<dt><samp>-s</samp></dt>
+<dd><p>Strict mode - fail on on different image size or sector allocation
+</p></dd>
+</dl>
+
+<p>Parameters to convert subcommand:
+</p>
+<dl compact="compact">
+<dt><samp>-n</samp></dt>
+<dd><p>Skip the creation of the target volume
+</p></dd>
+</dl>
+
+<p>Command description:
+</p>
+<dl compact="compact">
+<dt><samp>check [-f <var>fmt</var>] [--output=<var>ofmt</var>] [-r [leaks | all]] [-T <var>src_cache</var>] <var>filename</var></samp></dt>
+<dd>
+<p>Perform a consistency check on the disk image <var>filename</var>. The command can
+output in the format <var>ofmt</var> which is either <code>human</code> or <code>json</code>.
+</p>
+<p>If <code>-r</code> is specified, qemu-img tries to repair any inconsistencies found
+during the check. <code>-r leaks</code> repairs only cluster leaks, whereas
+<code>-r all</code> fixes all kinds of errors, with a higher risk of choosing the
+wrong fix or hiding corruption that has already occurred.
+</p>
+<p>Only the formats <code>qcow2</code>, <code>qed</code> and <code>vdi</code> support
+consistency checks.
+</p>
+<p>In case the image does not have any inconsistencies, check exits with <code>0</code>.
+Other exit codes indicate the kind of inconsistency found or if another error
+occurred. The following table summarizes all exit codes of the check subcommand:
+</p>
+<dl compact="compact">
+<dt><samp>0</samp></dt>
+<dd><p>Check completed, the image is (now) consistent
+</p></dd>
+<dt><samp>1</samp></dt>
+<dd><p>Check not completed because of internal errors
+</p></dd>
+<dt><samp>2</samp></dt>
+<dd><p>Check completed, image is corrupted
+</p></dd>
+<dt><samp>3</samp></dt>
+<dd><p>Check completed, image has leaked clusters, but is not corrupted
+</p></dd>
+<dt><samp>63</samp></dt>
+<dd><p>Checks are not supported by the image format
+</p>
+</dd>
+</dl>
+
+<p>If <code>-r</code> is specified, exit codes representing the image state refer to the
+state after (the attempt at) repairing it. That is, a successful <code>-r all</code>
+will yield the exit code 0, independently of the image state before.
+</p>
+</dd>
+<dt><samp>create [-f <var>fmt</var>] [-o <var>options</var>] <var>filename</var> [<var>size</var>]</samp></dt>
+<dd>
+<p>Create the new disk image <var>filename</var> of size <var>size</var> and format
+<var>fmt</var>. Depending on the file format, you can add one or more <var>options</var>
+that enable additional features of this format.
+</p>
+<p>If the option <var>backing_file</var> is specified, then the image will record
+only the differences from <var>backing_file</var>. No size needs to be specified in
+this case. <var>backing_file</var> will never be modified unless you use the
+<code>commit</code> monitor command (or qemu-img commit).
+</p>
+<p>The size can also be specified using the <var>size</var> option with <code>-o</code>,
+it doesn&rsquo;t need to be specified separately in this case.
+</p>
+</dd>
+<dt><samp>commit [-q] [-f <var>fmt</var>] [-t <var>cache</var>] [-b <var>base</var>] [-d] [-p] <var>filename</var></samp></dt>
+<dd>
+<p>Commit the changes recorded in <var>filename</var> in its base image or backing file.
+If the backing file is smaller than the snapshot, then the backing file will be
+resized to be the same size as the snapshot.  If the snapshot is smaller than
+the backing file, the backing file will not be truncated.  If you want the
+backing file to match the size of the smaller snapshot, you can safely truncate
+it yourself once the commit operation successfully completes.
+</p>
+<p>The image <var>filename</var> is emptied after the operation has succeeded. If you do
+not need <var>filename</var> afterwards and intend to drop it, you may skip emptying
+<var>filename</var> by specifying the <code>-d</code> flag.
+</p>
+<p>If the backing chain of the given image file <var>filename</var> has more than one
+layer, the backing file into which the changes will be committed may be
+specified as <var>base</var> (which has to be part of <var>filename</var>&rsquo;s backing
+chain). If <var>base</var> is not specified, the immediate backing file of the top
+image (which is <var>filename</var>) will be used. For reasons of consistency,
+explicitly specifying <var>base</var> will always imply <code>-d</code> (since emptying an
+image after committing to an indirect backing file would lead to different data
+being read from the image due to content in the intermediate backing chain
+overruling the commit target).
+</p>
+</dd>
+<dt><samp>compare [-f <var>fmt</var>] [-F <var>fmt</var>] [-T <var>src_cache</var>] [-p] [-s] [-q] <var>filename1</var> <var>filename2</var></samp></dt>
+<dd>
+<p>Check if two images have the same content. You can compare images with
+different format or settings.
+</p>
+<p>The format is probed unless you specify it by <var>-f</var> (used for
+<var>filename1</var>) and/or <var>-F</var> (used for <var>filename2</var>) option.
+</p>
+<p>By default, images with different size are considered identical if the larger
+image contains only unallocated and/or zeroed sectors in the area after the end
+of the other image. In addition, if any sector is not allocated in one image
+and contains only zero bytes in the second one, it is evaluated as equal. You
+can use Strict mode by specifying the <var>-s</var> option. When compare runs in
+Strict mode, it fails in case image size differs or a sector is allocated in
+one image and is not allocated in the second one.
+</p>
+<p>By default, compare prints out a result message. This message displays
+information that both images are same or the position of the first different
+byte. In addition, result message can report different image size in case
+Strict mode is used.
+</p>
+<p>Compare exits with <code>0</code> in case the images are equal and with <code>1</code>
+in case the images differ. Other exit codes mean an error occurred during
+execution and standard error output should contain an error message.
+The following table sumarizes all exit codes of the compare subcommand:
+</p>
+<dl compact="compact">
+<dt><samp>0</samp></dt>
+<dd><p>Images are identical
+</p></dd>
+<dt><samp>1</samp></dt>
+<dd><p>Images differ
+</p></dd>
+<dt><samp>2</samp></dt>
+<dd><p>Error on opening an image
+</p></dd>
+<dt><samp>3</samp></dt>
+<dd><p>Error on checking a sector allocation
+</p></dd>
+<dt><samp>4</samp></dt>
+<dd><p>Error on reading data
+</p>
+</dd>
+</dl>
+
+</dd>
+<dt><samp>convert [-c] [-p] [-n] [-f <var>fmt</var>] [-t <var>cache</var>] [-T <var>src_cache</var>] [-O <var>output_fmt</var>] [-o <var>options</var>] [-s <var>snapshot_id_or_name</var>] [-l <var>snapshot_param</var>] [-S <var>sparse_size</var>] <var>filename</var> [<var>filename2</var> [...]] <var>output_filename</var></samp></dt>
+<dd>
+<p>Convert the disk image <var>filename</var> or a snapshot <var>snapshot_param</var>(<var>snapshot_id_or_name</var> is deprecated)
+to disk image <var>output_filename</var> using format <var>output_fmt</var>. It can be optionally compressed (<code>-c</code>
+option) or use any format specific options like encryption (<code>-o</code> option).
+</p>
+<p>Only the formats <code>qcow</code> and <code>qcow2</code> support compression. The
+compression is read-only. It means that if a compressed sector is
+rewritten, then it is rewritten as uncompressed data.
+</p>
+<p>Image conversion is also useful to get smaller image when using a
+growable format such as <code>qcow</code>: the empty sectors are detected and
+suppressed from the destination image.
+</p>
+<p><var>sparse_size</var> indicates the consecutive number of bytes (defaults to 4k)
+that must contain only zeros for qemu-img to create a sparse image during
+conversion. If <var>sparse_size</var> is 0, the source will not be scanned for
+unallocated or zero sectors, and the destination image will always be
+fully allocated.
+</p>
+<p>You can use the <var>backing_file</var> option to force the output image to be
+created as a copy on write image of the specified base image; the
+<var>backing_file</var> should have the same content as the input&rsquo;s base image,
+however the path, image format, etc may differ.
+</p>
+<p>If the <code>-n</code> option is specified, the target volume creation will be
+skipped. This is useful for formats such as <code>rbd</code> if the target
+volume has already been created with site specific options that cannot
+be supplied through qemu-img.
+</p>
+</dd>
+<dt><samp>info [-f <var>fmt</var>] [--output=<var>ofmt</var>] [--backing-chain] <var>filename</var></samp></dt>
+<dd>
+<p>Give information about the disk image <var>filename</var>. Use it in
+particular to know the size reserved on disk which can be different
+from the displayed size. If VM snapshots are stored in the disk image,
+they are displayed too. The command can output in the format <var>ofmt</var>
+which is either <code>human</code> or <code>json</code>.
+</p>
+<p>If a disk image has a backing file chain, information about each disk image in
+the chain can be recursively enumerated by using the option <code>--backing-chain</code>.
+</p>
+<p>For instance, if you have an image chain like:
+</p>
+<div class="example">
+<pre class="example">base.qcow2 &lt;- snap1.qcow2 &lt;- snap2.qcow2
+</pre></div>
+
+<p>To enumerate information about each disk image in the above chain, starting from top to base, do:
+</p>
+<div class="example">
+<pre class="example">qemu-img info --backing-chain snap2.qcow2
+</pre></div>
+
+</dd>
+<dt><samp>map [-f <var>fmt</var>] [--output=<var>ofmt</var>] <var>filename</var></samp></dt>
+<dd>
+<p>Dump the metadata of image <var>filename</var> and its backing file chain.
+In particular, this commands dumps the allocation state of every sector
+of <var>filename</var>, together with the topmost file that allocates it in
+the backing file chain.
+</p>
+<p>Two option formats are possible.  The default format (<code>human</code>)
+only dumps known-nonzero areas of the file.  Known-zero parts of the
+file are omitted altogether, and likewise for parts that are not allocated
+throughout the chain.  <code>qemu-img</code> output will identify a file
+from where the data can be read, and the offset in the file.  Each line
+will include four fields, the first three of which are hexadecimal
+numbers.  For example the first line of:
+</p><div class="example">
+<pre class="example">Offset          Length          Mapped to       File
+0               0x20000         0x50000         /tmp/overlay.qcow2
+0x100000        0x10000         0x95380000      /tmp/backing.qcow2
+</pre></div>
+<p>means that 0x20000 (131072) bytes starting at offset 0 in the image are
+available in /tmp/overlay.qcow2 (opened in <code>raw</code> format) starting
+at offset 0x50000 (327680).  Data that is compressed, encrypted, or
+otherwise not available in raw format will cause an error if <code>human</code>
+format is in use.  Note that file names can include newlines, thus it is
+not safe to parse this output format in scripts.
+</p>
+<p>The alternative format <code>json</code> will return an array of dictionaries
+in JSON format.  It will include similar information in
+the <code>start</code>, <code>length</code>, <code>offset</code> fields;
+it will also include other more specific information:
+</p><ul class="no-bullet">
+<li>- whether the sectors contain actual data or not (boolean field <code>data</code>;
+if false, the sectors are either unallocated or stored as optimized
+all-zero clusters);
+
+</li><li>- whether the data is known to read as zero (boolean field <code>zero</code>);
+
+</li><li>- in order to make the output shorter, the target file is expressed as
+a <code>depth</code>; for example, a depth of 2 refers to the backing file
+of the backing file of <var>filename</var>.
+</li></ul>
+
+<p>In JSON format, the <code>offset</code> field is optional; it is absent in
+cases where <code>human</code> format would omit the entry or exit with an error.
+If <code>data</code> is false and the <code>offset</code> field is present, the
+corresponding sectors in the file are not yet in use, but they are
+preallocated.
+</p>
+<p>For more information, consult <samp>include/block/block.h</samp> in QEMU&rsquo;s
+source code.
+</p>
+</dd>
+<dt><samp>snapshot [-l | -a <var>snapshot</var> | -c <var>snapshot</var> | -d <var>snapshot</var> ] <var>filename</var></samp></dt>
+<dd>
+<p>List, apply, create or delete snapshots in image <var>filename</var>.
+</p>
+</dd>
+<dt><samp>rebase [-f <var>fmt</var>] [-t <var>cache</var>] [-T <var>src_cache</var>] [-p] [-u] -b <var>backing_file</var> [-F <var>backing_fmt</var>] <var>filename</var></samp></dt>
+<dd>
+<p>Changes the backing file of an image. Only the formats <code>qcow2</code> and
+<code>qed</code> support changing the backing file.
+</p>
+<p>The backing file is changed to <var>backing_file</var> and (if the image format of
+<var>filename</var> supports this) the backing file format is changed to
+<var>backing_fmt</var>. If <var>backing_file</var> is specified as &ldquo;&rdquo; (the empty
+string), then the image is rebased onto no backing file (i.e. it will exist
+independently of any backing file).
+</p>
+<p><var>cache</var> specifies the cache mode to be used for <var>filename</var>, whereas
+<var>src_cache</var> specifies the cache mode for reading backing files.
+</p>
+<p>There are two different modes in which <code>rebase</code> can operate:
+</p><dl compact="compact">
+<dt><samp>Safe mode</samp></dt>
+<dd><p>This is the default mode and performs a real rebase operation. The new backing
+file may differ from the old one and qemu-img rebase will take care of keeping
+the guest-visible content of <var>filename</var> unchanged.
+</p>
+<p>In order to achieve this, any clusters that differ between <var>backing_file</var>
+and the old backing file of <var>filename</var> are merged into <var>filename</var>
+before actually changing the backing file.
+</p>
+<p>Note that the safe mode is an expensive operation, comparable to converting
+an image. It only works if the old backing file still exists.
+</p>
+</dd>
+<dt><samp>Unsafe mode</samp></dt>
+<dd><p>qemu-img uses the unsafe mode if <code>-u</code> is specified. In this mode, only the
+backing file name and format of <var>filename</var> is changed without any checks
+on the file contents. The user must take care of specifying the correct new
+backing file, or the guest-visible content of the image will be corrupted.
+</p>
+<p>This mode is useful for renaming or moving the backing file to somewhere else.
+It can be used without an accessible old backing file, i.e. you can use it to
+fix an image whose backing file has already been moved/renamed.
+</p></dd>
+</dl>
+
+<p>You can use <code>rebase</code> to perform a &ldquo;diff&rdquo; operation on two
+disk images.  This can be useful when you have copied or cloned
+a guest, and you want to get back to a thin image on top of a
+template or base image.
+</p>
+<p>Say that <code>base.img</code> has been cloned as <code>modified.img</code> by
+copying it, and that the <code>modified.img</code> guest has run so there
+are now some changes compared to <code>base.img</code>.  To construct a thin
+image called <code>diff.qcow2</code> that contains just the differences, do:
+</p>
+<div class="example">
+<pre class="example">qemu-img create -f qcow2 -b modified.img diff.qcow2
+qemu-img rebase -b base.img diff.qcow2
+</pre></div>
+
+<p>At this point, <code>modified.img</code> can be discarded, since
+<code>base.img + diff.qcow2</code> contains the same information.
+</p>
+</dd>
+<dt><samp>resize <var>filename</var> [+ | -]<var>size</var></samp></dt>
+<dd>
+<p>Change the disk image as if it had been created with <var>size</var>.
+</p>
+<p>Before using this command to shrink a disk image, you MUST use file system and
+partitioning tools inside the VM to reduce allocated file systems and partition
+sizes accordingly.  Failure to do so will result in data loss!
+</p>
+<p>After using this command to grow a disk image, you must use file system and
+partitioning tools inside the VM to actually begin using the new space on the
+device.
+</p>
+</dd>
+<dt><samp>amend [-p] [-f <var>fmt</var>] [-t <var>cache</var>] -o <var>options</var> <var>filename</var></samp></dt>
+<dd>
+<p>Amends the image format specific <var>options</var> for the image file
+<var>filename</var>. Not all file formats support this operation.
+</p></dd>
+</dl>
+
+
+<hr>
+<a name="qemu_005fnbd_005finvocation"></a>
+<a name="qemu_002dnbd-Invocation"></a>
+<h4 class="subsection">3.6.5 <code>qemu-nbd</code> Invocation</h4>
+
+<div class="example">
+<pre class="example">usage: qemu-nbd [OPTION]...  <var>filename</var>
+</pre></div>
+
+
+<p>Export QEMU disk image using NBD protocol.
+</p>
+
+<dl compact="compact">
+<dt><samp><var>filename</var></samp></dt>
+<dd><p>is a disk image filename
+</p></dd>
+<dt><samp>-p, --port=<var>port</var></samp></dt>
+<dd><p>port to listen on (default &lsquo;<samp>10809</samp>&rsquo;)
+</p></dd>
+<dt><samp>-o, --offset=<var>offset</var></samp></dt>
+<dd><p>offset into the image
+</p></dd>
+<dt><samp>-b, --bind=<var>iface</var></samp></dt>
+<dd><p>interface to bind to (default &lsquo;<samp>0.0.0.0</samp>&rsquo;)
+</p></dd>
+<dt><samp>-k, --socket=<var>path</var></samp></dt>
+<dd><p>Use a unix socket with path <var>path</var>
+</p></dd>
+<dt><samp>-f, --format=<var>format</var></samp></dt>
+<dd><p>Set image format as <var>format</var>
+</p></dd>
+<dt><samp>-r, --read-only</samp></dt>
+<dd><p>export read-only
+</p></dd>
+<dt><samp>-P, --partition=<var>num</var></samp></dt>
+<dd><p>only expose partition <var>num</var>
+</p></dd>
+<dt><samp>-s, --snapshot</samp></dt>
+<dd><p>use <var>filename</var> as an external snapshot, create a temporary
+  file with backing_file=<var>filename</var>, redirect the write to
+  the temporary one
+</p></dd>
+<dt><samp>-l, --load-snapshot=<var>snapshot_param</var></samp></dt>
+<dd><p>load an internal snapshot inside <var>filename</var> and export it
+  as an read-only device, <var>snapshot_param</var> format is
+  &rsquo;snapshot.id=[ID],snapshot.name=[NAME]&rsquo; or &rsquo;[ID_OR_NAME]&rsquo;
+</p></dd>
+<dt><samp>-n, --nocache</samp></dt>
+<dt><samp>--cache=<var>cache</var></samp></dt>
+<dd><p>set cache mode to be used with the file.  See the documentation of
+  the emulator&rsquo;s <code>-drive cache=...</code> option for allowed values.
+</p></dd>
+<dt><samp>--aio=<var>aio</var></samp></dt>
+<dd><p>choose asynchronous I/O mode between &lsquo;<samp>threads</samp>&rsquo; (the default)
+  and &lsquo;<samp>native</samp>&rsquo; (Linux only).
+</p></dd>
+<dt><samp>--discard=<var>discard</var></samp></dt>
+<dd><p>toggles whether <em>discard</em> (also known as <em>trim</em> or <em>unmap</em>)
+  requests are ignored or passed to the filesystem.  The default is no
+  (&lsquo;<samp>--discard=ignore</samp>&rsquo;).
+</p></dd>
+<dt><samp>-c, --connect=<var>dev</var></samp></dt>
+<dd><p>connect <var>filename</var> to NBD device <var>dev</var>
+</p></dd>
+<dt><samp>-d, --disconnect</samp></dt>
+<dd><p>disconnect the specified device
+</p></dd>
+<dt><samp>-e, --shared=<var>num</var></samp></dt>
+<dd><p>device can be shared by <var>num</var> clients (default &lsquo;<samp>1</samp>&rsquo;)
+</p></dd>
+<dt><samp>-f, --format=<var>fmt</var></samp></dt>
+<dd><p>force block driver for format <var>fmt</var> instead of auto-detecting
+</p></dd>
+<dt><samp>-t, --persistent</samp></dt>
+<dd><p>don&rsquo;t exit on the last connection
+</p></dd>
+<dt><samp>-v, --verbose</samp></dt>
+<dd><p>display extra debugging information
+</p></dd>
+<dt><samp>-h, --help</samp></dt>
+<dd><p>display this help and exit
+</p></dd>
+<dt><samp>-V, --version</samp></dt>
+<dd><p>output version information and exit
+</p></dd>
+</dl>
+
+
+
+<hr>
+<a name="disk_005fimages_005fformats"></a>
+<a name="Disk-image-file-formats"></a>
+<h4 class="subsection">3.6.6 Disk image file formats</h4>
+
+<p>QEMU supports many image file formats that can be used with VMs as well as with
+any of the tools (like <code>qemu-img</code>). This includes the preferred formats
+raw and qcow2 as well as formats that are supported for compatibility with
+older QEMU versions or other hypervisors.
+</p>
+<p>Depending on the image format, different options can be passed to
+<code>qemu-img create</code> and <code>qemu-img convert</code> using the <code>-o</code> option.
+This section describes each format and the options that are supported for it.
+</p>
+<dl compact="compact">
+<dt><samp>raw</samp></dt>
+<dd>
+<p>Raw disk image format. This format has the advantage of
+being simple and easily exportable to all other emulators. If your
+file system supports <em>holes</em> (for example in ext2 or ext3 on
+Linux or NTFS on Windows), then only the written sectors will reserve
+space. Use <code>qemu-img info</code> to know the real size used by the
+image or <code>ls -ls</code> on Unix/Linux.
+</p>
+<p>Supported options:
+</p><dl compact="compact">
+<dt><code>preallocation</code></dt>
+<dd><p>Preallocation mode (allowed values: <code>off</code>, <code>falloc</code>, <code>full</code>).
+<code>falloc</code> mode preallocates space for image by calling posix_fallocate().
+<code>full</code> mode preallocates space for image by writing zeros to underlying
+storage.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>qcow2</samp></dt>
+<dd><p>QEMU image format, the most versatile format. Use it to have smaller
+images (useful if your filesystem does not supports holes, for example
+on Windows), zlib based compression and support of multiple VM
+snapshots.
+</p>
+<p>Supported options:
+</p><dl compact="compact">
+<dt><code>compat</code></dt>
+<dd><p>Determines the qcow2 version to use. <code>compat=0.10</code> uses the
+traditional image format that can be read by any QEMU since 0.10.
+<code>compat=1.1</code> enables image format extensions that only QEMU 1.1 and
+newer understand (this is the default). Amongst others, this includes
+zero clusters, which allow efficient copy-on-read for sparse images.
+</p>
+</dd>
+<dt><code>backing_file</code></dt>
+<dd><p>File name of a base image (see <samp>create</samp> subcommand)
+</p></dd>
+<dt><code>backing_fmt</code></dt>
+<dd><p>Image format of the base image
+</p></dd>
+<dt><code>encryption</code></dt>
+<dd><p>If this option is set to <code>on</code>, the image is encrypted with 128-bit AES-CBC.
+</p>
+<p>The use of encryption in qcow and qcow2 images is considered to be flawed by
+modern cryptography standards, suffering from a number of design problems:
+</p>
+<ul class="no-bullet">
+<li>- The AES-CBC cipher is used with predictable initialization vectors based
+on the sector number. This makes it vulnerable to chosen plaintext attacks
+which can reveal the existence of encrypted data.
+</li><li>- The user passphrase is directly used as the encryption key. A poorly
+chosen or short passphrase will compromise the security of the encryption.
+</li><li>- In the event of the passphrase being compromised there is no way to
+change the passphrase to protect data in any qcow images. The files must
+be cloned, using a different encryption passphrase in the new file. The
+original file must then be securely erased using a program like shred,
+though even this is ineffective with many modern storage technologies.
+</li></ul>
+
+<p>Use of qcow / qcow2 encryption with QEMU is deprecated, and support for
+it will go away in a future release.  Users are recommended to use an
+alternative encryption technology such as the Linux dm-crypt / LUKS
+system.
+</p>
+</dd>
+<dt><code>cluster_size</code></dt>
+<dd><p>Changes the qcow2 cluster size (must be between 512 and 2M). Smaller cluster
+sizes can improve the image file size whereas larger cluster sizes generally
+provide better performance.
+</p>
+</dd>
+<dt><code>preallocation</code></dt>
+<dd><p>Preallocation mode (allowed values: <code>off</code>, <code>metadata</code>, <code>falloc</code>,
+<code>full</code>). An image with preallocated metadata is initially larger but can
+improve performance when the image needs to grow. <code>falloc</code> and <code>full</code>
+preallocations are like the same options of <code>raw</code> format, but sets up
+metadata also.
+</p>
+</dd>
+<dt><code>lazy_refcounts</code></dt>
+<dd><p>If this option is set to <code>on</code>, reference count updates are postponed with
+the goal of avoiding metadata I/O and improving performance. This is
+particularly interesting with <samp>cache=writethrough</samp> which doesn&rsquo;t batch
+metadata updates. The tradeoff is that after a host crash, the reference count
+tables must be rebuilt, i.e. on the next open an (automatic) <code>qemu-img
+check -r all</code> is required, which may take some time.
+</p>
+<p>This option can only be enabled if <code>compat=1.1</code> is specified.
+</p>
+</dd>
+<dt><code>nocow</code></dt>
+<dd><p>If this option is set to <code>on</code>, it will turn off COW of the file. It&rsquo;s only
+valid on btrfs, no effect on other file systems.
+</p>
+<p>Btrfs has low performance when hosting a VM image file, even more when the guest
+on the VM also using btrfs as file system. Turning off COW is a way to mitigate
+this bad performance. Generally there are two ways to turn off COW on btrfs:
+a) Disable it by mounting with nodatacow, then all newly created files will be
+NOCOW. b) For an empty file, add the NOCOW file attribute. That&rsquo;s what this option
+does.
+</p>
+<p>Note: this option is only valid to new or empty files. If there is an existing
+file which is COW and has data blocks already, it couldn&rsquo;t be changed to NOCOW
+by setting <code>nocow=on</code>. One can issue <code>lsattr filename</code> to check if
+the NOCOW flag is set or not (Capital &rsquo;C&rsquo; is NOCOW flag).
+</p>
+</dd>
+</dl>
+
+</dd>
+<dt><samp>qed</samp></dt>
+<dd><p>Old QEMU image format with support for backing files and compact image files
+(when your filesystem or transport medium does not support holes).
+</p>
+<p>When converting QED images to qcow2, you might want to consider using the
+<code>lazy_refcounts=on</code> option to get a more QED-like behaviour.
+</p>
+<p>Supported options:
+</p><dl compact="compact">
+<dt><code>backing_file</code></dt>
+<dd><p>File name of a base image (see <samp>create</samp> subcommand).
+</p></dd>
+<dt><code>backing_fmt</code></dt>
+<dd><p>Image file format of backing file (optional).  Useful if the format cannot be
+autodetected because it has no header, like some vhd/vpc files.
+</p></dd>
+<dt><code>cluster_size</code></dt>
+<dd><p>Changes the cluster size (must be power-of-2 between 4K and 64K). Smaller
+cluster sizes can improve the image file size whereas larger cluster sizes
+generally provide better performance.
+</p></dd>
+<dt><code>table_size</code></dt>
+<dd><p>Changes the number of clusters per L1/L2 table (must be power-of-2 between 1
+and 16).  There is normally no need to change this value but this option can be
+used for performance benchmarking.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>qcow</samp></dt>
+<dd><p>Old QEMU image format with support for backing files, compact image files,
+encryption and compression.
+</p>
+<p>Supported options:
+</p><dl compact="compact">
+<dt><code>backing_file</code></dt>
+<dd><p>File name of a base image (see <samp>create</samp> subcommand)
+</p></dd>
+<dt><code>encryption</code></dt>
+<dd><p>If this option is set to <code>on</code>, the image is encrypted.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>vdi</samp></dt>
+<dd><p>VirtualBox 1.1 compatible image format.
+Supported options:
+</p><dl compact="compact">
+<dt><code>static</code></dt>
+<dd><p>If this option is set to <code>on</code>, the image is created with metadata
+preallocation.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>vmdk</samp></dt>
+<dd><p>VMware 3 and 4 compatible image format.
+</p>
+<p>Supported options:
+</p><dl compact="compact">
+<dt><code>backing_file</code></dt>
+<dd><p>File name of a base image (see <samp>create</samp> subcommand).
+</p></dd>
+<dt><code>compat6</code></dt>
+<dd><p>Create a VMDK version 6 image (instead of version 4)
+</p></dd>
+<dt><code>subformat</code></dt>
+<dd><p>Specifies which VMDK subformat to use. Valid options are
+<code>monolithicSparse</code> (default),
+<code>monolithicFlat</code>,
+<code>twoGbMaxExtentSparse</code>,
+<code>twoGbMaxExtentFlat</code> and
+<code>streamOptimized</code>.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>vpc</samp></dt>
+<dd><p>VirtualPC compatible image format (VHD).
+Supported options:
+</p><dl compact="compact">
+<dt><code>subformat</code></dt>
+<dd><p>Specifies which VHD subformat to use. Valid options are
+<code>dynamic</code> (default) and <code>fixed</code>.
+</p></dd>
+</dl>
+
+</dd>
+<dt><samp>VHDX</samp></dt>
+<dd><p>Hyper-V compatible image format (VHDX).
+Supported options:
+</p><dl compact="compact">
+<dt><code>subformat</code></dt>
+<dd><p>Specifies which VHDX subformat to use. Valid options are
+<code>dynamic</code> (default) and <code>fixed</code>.
+</p></dd>
+<dt><code>block_state_zero</code></dt>
+<dd><p>Force use of payload blocks of type &rsquo;ZERO&rsquo;.  Can be set to <code>on</code> (default)
+or <code>off</code>.  When set to <code>off</code>, new blocks will be created as
+<code>PAYLOAD_BLOCK_NOT_PRESENT</code>, which means parsers are free to return
+arbitrary data for those blocks.  Do not set to <code>off</code> when using
+<code>qemu-img convert</code> with <code>subformat=dynamic</code>.
+</p></dd>
+<dt><code>block_size</code></dt>
+<dd><p>Block size; min 1 MB, max 256 MB.  0 means auto-calculate based on image size.
+</p></dd>
+<dt><code>log_size</code></dt>
+<dd><p>Log size; min 1 MB.
+</p></dd>
+</dl>
+</dd>
+</dl>
+
+<a name="Read_002donly-formats"></a>
+<h4 class="subsubsection">3.6.6.1 Read-only formats</h4>
+<p>More disk image file formats are supported in a read-only mode.
+</p><dl compact="compact">
+<dt><samp>bochs</samp></dt>
+<dd><p>Bochs images of <code>growing</code> type.
+</p></dd>
+<dt><samp>cloop</samp></dt>
+<dd><p>Linux Compressed Loop image, useful only to reuse directly compressed
+CD-ROM images present for example in the Knoppix CD-ROMs.
+</p></dd>
+<dt><samp>dmg</samp></dt>
+<dd><p>Apple disk image.
+</p></dd>
+<dt><samp>parallels</samp></dt>
+<dd><p>Parallels disk image format.
+</p></dd>
+</dl>
+
+
+<hr>
+<a name="host_005fdrives"></a>
+<a name="Using-host-drives"></a>
+<h4 class="subsection">3.6.7 Using host drives</h4>
+
+<p>In addition to disk image files, QEMU can directly access host
+devices. We describe here the usage for QEMU version &gt;= 0.8.3.
+</p>
+<a name="Linux-1"></a>
+<h4 class="subsubsection">3.6.7.1 Linux</h4>
+
+<p>On Linux, you can directly use the host device filename instead of a
+disk image filename provided you have enough privileges to access
+it. For example, use <samp>/dev/cdrom</samp> to access to the CDROM.
+</p>
+<dl compact="compact">
+<dt><code>CD</code></dt>
+<dd><p>You can specify a CDROM device even if no CDROM is loaded. QEMU has
+specific code to detect CDROM insertion or removal. CDROM ejection by
+the guest OS is supported. Currently only data CDs are supported.
+</p></dd>
+<dt><code>Floppy</code></dt>
+<dd><p>You can specify a floppy device even if no floppy is loaded. Floppy
+removal is currently not detected accurately (if you change floppy
+without doing floppy access while the floppy is not loaded, the guest
+OS will think that the same floppy is loaded).
+Use of the host&rsquo;s floppy device is deprecated, and support for it will
+be removed in a future release.
+</p></dd>
+<dt><code>Hard disks</code></dt>
+<dd><p>Hard disks can be used. Normally you must specify the whole disk
+(<samp>/dev/hdb</samp> instead of <samp>/dev/hdb1</samp>) so that the guest OS can
+see it as a partitioned disk. WARNING: unless you know what you do, it
+is better to only make READ-ONLY accesses to the hard disk otherwise
+you may corrupt your host data (use the <samp>-snapshot</samp> command
+line option or modify the device permissions accordingly).
+</p></dd>
+</dl>
+
+<a name="Windows-2"></a>
+<h4 class="subsubsection">3.6.7.2 Windows</h4>
+
+<dl compact="compact">
+<dt><code>CD</code></dt>
+<dd><p>The preferred syntax is the drive letter (e.g. <samp>d:</samp>). The
+alternate syntax <samp>\\.\d:</samp> is supported. <samp>/dev/cdrom</samp> is
+supported as an alias to the first CDROM drive.
+</p>
+<p>Currently there is no specific code to handle removable media, so it
+is better to use the <code>change</code> or <code>eject</code> monitor commands to
+change or eject media.
+</p></dd>
+<dt><code>Hard disks</code></dt>
+<dd><p>Hard disks can be used with the syntax: <samp>\\.\PhysicalDrive<var>N</var></samp>
+where <var>N</var> is the drive number (0 is the first hard disk).
+</p>
+<p>WARNING: unless you know what you do, it is better to only make
+READ-ONLY accesses to the hard disk otherwise you may corrupt your
+host data (use the <samp>-snapshot</samp> command line so that the
+modifications are written in a temporary file).
+</p></dd>
+</dl>
+
+
+<a name="Mac-OS-X-2"></a>
+<h4 class="subsubsection">3.6.7.3 Mac OS X</h4>
+
+<p><samp>/dev/cdrom</samp> is an alias to the first CDROM.
+</p>
+<p>Currently there is no specific code to handle removable media, so it
+is better to use the <code>change</code> or <code>eject</code> monitor commands to
+change or eject media.
+</p>
+<hr>
+<a name="disk_005fimages_005ffat_005fimages"></a>
+<a name="Virtual-FAT-disk-images"></a>
+<h4 class="subsection">3.6.8 Virtual FAT disk images</h4>
+
+<p>QEMU can automatically create a virtual FAT disk image from a
+directory tree. In order to use it, just type:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img -hdb fat:/my_directory
+</pre></div>
+
+<p>Then you access access to all the files in the <samp>/my_directory</samp>
+directory without having to copy them in a disk image or to export
+them via SAMBA or NFS. The default access is <em>read-only</em>.
+</p>
+<p>Floppies can be emulated with the <code>:floppy:</code> option:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img -fda fat:floppy:/my_directory
+</pre></div>
+
+<p>A read/write support is available for testing (beta stage) with the
+<code>:rw:</code> option:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img -fda fat:floppy:rw:/my_directory
+</pre></div>
+
+<p>What you should <em>never</em> do:
+</p><ul>
+<li> use non-ASCII filenames ;
+</li><li> use &quot;-snapshot&quot; together with &quot;:rw:&quot; ;
+</li><li> expect it to work when loadvm&rsquo;ing ;
+</li><li> write to the FAT directory on the host system while accessing it with the guest system.
+</li></ul>
+
+<hr>
+<a name="disk_005fimages_005fnbd"></a>
+<a name="NBD-access"></a>
+<h4 class="subsection">3.6.9 NBD access</h4>
+
+<p>QEMU can access directly to block device exported using the Network Block Device
+protocol.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img -hdb nbd://my_nbd_server.mydomain.org:1024/
+</pre></div>
+
+<p>If the NBD server is located on the same host, you can use an unix socket instead
+of an inet socket:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 linux.img -hdb nbd+unix://?socket=/tmp/my_socket
+</pre></div>
+
+<p>In this case, the block device must be exported using qemu-nbd:
+</p>
+<div class="example">
+<pre class="example">qemu-nbd --socket=/tmp/my_socket my_disk.qcow2
+</pre></div>
+
+<p>The use of qemu-nbd allows sharing of a disk between several guests:
+</p><div class="example">
+<pre class="example">qemu-nbd --socket=/tmp/my_socket --share=2 my_disk.qcow2
+</pre></div>
+
+<p>and then you can use it with two guests:
+</p><div class="example">
+<pre class="example">qemu-system-i386 linux1.img -hdb nbd+unix://?socket=/tmp/my_socket
+qemu-system-i386 linux2.img -hdb nbd+unix://?socket=/tmp/my_socket
+</pre></div>
+
+<p>If the nbd-server uses named exports (supported since NBD 2.9.18, or with QEMU&rsquo;s
+own embedded NBD server), you must specify an export name in the URI:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -cdrom nbd://localhost/debian-500-ppc-netinst
+qemu-system-i386 -cdrom nbd://localhost/openSUSE-11.1-ppc-netinst
+</pre></div>
+
+<p>The URI syntax for NBD is supported since QEMU 1.3.  An alternative syntax is
+also available.  Here are some example of the older syntax:
+</p><div class="example">
+<pre class="example">qemu-system-i386 linux.img -hdb nbd:my_nbd_server.mydomain.org:1024
+qemu-system-i386 linux2.img -hdb nbd:unix:/tmp/my_socket
+qemu-system-i386 -cdrom nbd:localhost:10809:exportname=debian-500-ppc-netinst
+</pre></div>
+
+<hr>
+<a name="disk_005fimages_005fsheepdog"></a>
+<a name="Sheepdog-disk-images"></a>
+<h4 class="subsection">3.6.10 Sheepdog disk images</h4>
+
+<p>Sheepdog is a distributed storage system for QEMU.  It provides highly
+available block level storage volumes that can be attached to
+QEMU-based virtual machines.
+</p>
+<p>You can create a Sheepdog disk image with the command:
+</p><div class="example">
+<pre class="example">qemu-img create sheepdog:///<var>image</var> <var>size</var>
+</pre></div>
+<p>where <var>image</var> is the Sheepdog image name and <var>size</var> is its
+size.
+</p>
+<p>To import the existing <var>filename</var> to Sheepdog, you can use a
+convert command.
+</p><div class="example">
+<pre class="example">qemu-img convert <var>filename</var> sheepdog:///<var>image</var>
+</pre></div>
+
+<p>You can boot from the Sheepdog disk image with the command:
+</p><div class="example">
+<pre class="example">qemu-system-i386 sheepdog:///<var>image</var>
+</pre></div>
+
+<p>You can also create a snapshot of the Sheepdog image like qcow2.
+</p><div class="example">
+<pre class="example">qemu-img snapshot -c <var>tag</var> sheepdog:///<var>image</var>
+</pre></div>
+<p>where <var>tag</var> is a tag name of the newly created snapshot.
+</p>
+<p>To boot from the Sheepdog snapshot, specify the tag name of the
+snapshot.
+</p><div class="example">
+<pre class="example">qemu-system-i386 sheepdog:///<var>image</var>#<var>tag</var>
+</pre></div>
+
+<p>You can create a cloned image from the existing snapshot.
+</p><div class="example">
+<pre class="example">qemu-img create -b sheepdog:///<var>base</var>#<var>tag</var> sheepdog:///<var>image</var>
+</pre></div>
+<p>where <var>base</var> is a image name of the source snapshot and <var>tag</var>
+is its tag name.
+</p>
+<p>You can use an unix socket instead of an inet socket:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 sheepdog+unix:///<var>image</var>?socket=<var>path</var>
+</pre></div>
+
+<p>If the Sheepdog daemon doesn&rsquo;t run on the local host, you need to
+specify one of the Sheepdog servers to connect to.
+</p><div class="example">
+<pre class="example">qemu-img create sheepdog://<var>hostname</var>:<var>port</var>/<var>image</var> <var>size</var>
+qemu-system-i386 sheepdog://<var>hostname</var>:<var>port</var>/<var>image</var>
+</pre></div>
+
+<hr>
+<a name="disk_005fimages_005fiscsi"></a>
+<a name="iSCSI-LUNs"></a>
+<h4 class="subsection">3.6.11 iSCSI LUNs</h4>
+
+<p>iSCSI is a popular protocol used to access SCSI devices across a computer
+network.
+</p>
+<p>There are two different ways iSCSI devices can be used by QEMU.
+</p>
+<p>The first method is to mount the iSCSI LUN on the host, and make it appear as
+any other ordinary SCSI device on the host and then to access this device as a
+/dev/sd device from QEMU. How to do this differs between host OSes.
+</p>
+<p>The second method involves using the iSCSI initiator that is built into
+QEMU. This provides a mechanism that works the same way regardless of which
+host OS you are running QEMU on. This section will describe this second method
+of using iSCSI together with QEMU.
+</p>
+<p>In QEMU, iSCSI devices are described using special iSCSI URLs
+</p>
+<div class="example">
+<pre class="example">URL syntax:
+iscsi://[&lt;username&gt;[%&lt;password&gt;]@]&lt;host&gt;[:&lt;port&gt;]/&lt;target-iqn-name&gt;/&lt;lun&gt;
+</pre></div>
+
+<p>Username and password are optional and only used if your target is set up
+using CHAP authentication for access control.
+Alternatively the username and password can also be set via environment
+variables to have these not show up in the process list
+</p>
+<div class="example">
+<pre class="example">export LIBISCSI_CHAP_USERNAME=&lt;username&gt;
+export LIBISCSI_CHAP_PASSWORD=&lt;password&gt;
+iscsi://&lt;host&gt;/&lt;target-iqn-name&gt;/&lt;lun&gt;
+</pre></div>
+
+<p>Various session related parameters can be set via special options, either
+in a configuration file provided via &rsquo;-readconfig&rsquo; or directly on the
+command line.
+</p>
+<p>If the initiator-name is not specified qemu will use a default name
+of &rsquo;iqn.2008-11.org.linux-kvm[:&lt;name&gt;&rsquo;] where &lt;name&gt; is the name of the
+virtual machine.
+</p>
+
+<div class="example">
+<pre class="example">Setting a specific initiator name to use when logging in to the target
+-iscsi initiator-name=iqn.qemu.test:my-initiator
+</pre></div>
+
+<div class="example">
+<pre class="example">Controlling which type of header digest to negotiate with the target
+-iscsi header-digest=CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
+</pre></div>
+
+<p>These can also be set via a configuration file
+</p><div class="example">
+<pre class="example">[iscsi]
+  user = &quot;CHAP username&quot;
+  password = &quot;CHAP password&quot;
+  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
+  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
+  header-digest = &quot;CRC32C&quot;
+</pre></div>
+
+
+<p>Setting the target name allows different options for different targets
+</p><div class="example">
+<pre class="example">[iscsi &quot;iqn.target.name&quot;]
+  user = &quot;CHAP username&quot;
+  password = &quot;CHAP password&quot;
+  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
+  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
+  header-digest = &quot;CRC32C&quot;
+</pre></div>
+
+
+<p>Howto use a configuration file to set iSCSI configuration options:
+</p><div class="example">
+<pre class="example">cat &gt;iscsi.conf &lt;&lt;EOF
+[iscsi]
+  user = &quot;me&quot;
+  password = &quot;my password&quot;
+  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
+  header-digest = &quot;CRC32C&quot;
+EOF
+
+qemu-system-i386 -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
+    -readconfig iscsi.conf
+</pre></div>
+
+
+<p>Howto set up a simple iSCSI target on loopback and accessing it via QEMU:
+</p><div class="example">
+<pre class="example">This example shows how to set up an iSCSI target with one CDROM and one DISK
+using the Linux STGT software target. This target is available on Red Hat based
+systems as the package 'scsi-target-utils'.
+
+tgtd --iscsi portal=127.0.0.1:3260
+tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.qemu.test
+tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 \
+    -b /IMAGES/disk.img --device-type=disk
+tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 \
+    -b /IMAGES/cd.iso --device-type=cd
+tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
+
+qemu-system-i386 -iscsi initiator-name=iqn.qemu.test:my-initiator \
+    -boot d -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
+    -cdrom iscsi://127.0.0.1/iqn.qemu.test/2
+</pre></div>
+
+<hr>
+<a name="disk_005fimages_005fgluster"></a>
+<a name="GlusterFS-disk-images"></a>
+<h4 class="subsection">3.6.12 GlusterFS disk images</h4>
+
+<p>GlusterFS is an user space distributed file system.
+</p>
+<p>You can boot from the GlusterFS disk image with the command:
+</p><div class="example">
+<pre class="example">qemu-system-x86_64 -drive file=gluster[+<var>transport</var>]://[<var>server</var>[:<var>port</var>]]/<var>volname</var>/<var>image</var>[?socket=...]
+</pre></div>
+
+<p><var>gluster</var> is the protocol.
+</p>
+<p><var>transport</var> specifies the transport type used to connect to gluster
+management daemon (glusterd). Valid transport types are
+tcp, unix and rdma. If a transport type isn&rsquo;t specified, then tcp
+type is assumed.
+</p>
+<p><var>server</var> specifies the server where the volume file specification for
+the given volume resides. This can be either hostname, ipv4 address
+or ipv6 address. ipv6 address needs to be within square brackets [ ].
+If transport type is unix, then <var>server</var> field should not be specifed.
+Instead <var>socket</var> field needs to be populated with the path to unix domain
+socket.
+</p>
+<p><var>port</var> is the port number on which glusterd is listening. This is optional
+and if not specified, QEMU will send 0 which will make gluster to use the
+default port. If the transport type is unix, then <var>port</var> should not be
+specified.
+</p>
+<p><var>volname</var> is the name of the gluster volume which contains the disk image.
+</p>
+<p><var>image</var> is the path to the actual disk image that resides on gluster volume.
+</p>
+<p>You can create a GlusterFS disk image with the command:
+</p><div class="example">
+<pre class="example">qemu-img create gluster://<var>server</var>/<var>volname</var>/<var>image</var> <var>size</var>
+</pre></div>
+
+<p>Examples
+</p><div class="example">
+<pre class="example">qemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img
+qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4/testvol/a.img
+qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4:24007/testvol/dir/a.img
+qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]/testvol/dir/a.img
+qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]:24007/testvol/dir/a.img
+qemu-system-x86_64 -drive file=gluster+tcp://server.domain.com:24007/testvol/dir/a.img
+qemu-system-x86_64 -drive file=gluster+unix:///testvol/dir/a.img?socket=/tmp/glusterd.socket
+qemu-system-x86_64 -drive file=gluster+rdma://1.2.3.4:24007/testvol/a.img
+</pre></div>
+
+<hr>
+<a name="disk_005fimages_005fssh"></a>
+<a name="Secure-Shell-_0028ssh_0029-disk-images"></a>
+<h4 class="subsection">3.6.13 Secure Shell (ssh) disk images</h4>
+
+<p>You can access disk images located on a remote ssh server
+by using the ssh protocol:
+</p>
+<div class="example">
+<pre class="example">qemu-system-x86_64 -drive file=ssh://[<var>user</var>@]<var>server</var>[:<var>port</var>]/<var>path</var>[?host_key_check=<var>host_key_check</var>]
+</pre></div>
+
+<p>Alternative syntax using properties:
+</p>
+<div class="example">
+<pre class="example">qemu-system-x86_64 -drive file.driver=ssh[,file.user=<var>user</var>],file.host=<var>server</var>[,file.port=<var>port</var>],file.path=<var>path</var>[,file.host_key_check=<var>host_key_check</var>]
+</pre></div>
+
+<p><var>ssh</var> is the protocol.
+</p>
+<p><var>user</var> is the remote user.  If not specified, then the local
+username is tried.
+</p>
+<p><var>server</var> specifies the remote ssh server.  Any ssh server can be
+used, but it must implement the sftp-server protocol.  Most Unix/Linux
+systems should work without requiring any extra configuration.
+</p>
+<p><var>port</var> is the port number on which sshd is listening.  By default
+the standard ssh port (22) is used.
+</p>
+<p><var>path</var> is the path to the disk image.
+</p>
+<p>The optional <var>host_key_check</var> parameter controls how the remote
+host&rsquo;s key is checked.  The default is <code>yes</code> which means to use
+the local <samp>.ssh/known_hosts</samp> file.  Setting this to <code>no</code>
+turns off known-hosts checking.  Or you can check that the host key
+matches a specific fingerprint:
+<code>host_key_check=md5:78:45:8e:14:57:4f:d5:45:83:0a:0e:f3:49:82:c9:c8</code>
+(<code>sha1:</code> can also be used as a prefix, but note that OpenSSH
+tools only use MD5 to print fingerprints).
+</p>
+<p>Currently authentication must be done using ssh-agent.  Other
+authentication methods may be supported in future.
+</p>
+<p>Note: Many ssh servers do not support an <code>fsync</code>-style operation.
+The ssh driver cannot guarantee that disk flush requests are
+obeyed, and this causes a risk of disk corruption if the remote
+server or network goes down during writes.  The driver will
+print a warning when <code>fsync</code> is not supported:
+</p>
+<p>warning: ssh server <code>ssh.example.com:22</code> does not support fsync
+</p>
+<p>With sufficiently new versions of libssh2 and OpenSSH, <code>fsync</code> is
+supported.
+</p>
+<hr>
+<a name="pcsys_005fnetwork"></a>
+<a name="Network-emulation"></a>
+<h3 class="section">3.7 Network emulation</h3>
+
+<p>QEMU can simulate several network cards (PCI or ISA cards on the PC
+target) and can connect them to an arbitrary number of Virtual Local
+Area Networks (VLANs). Host TAP devices can be connected to any QEMU
+VLAN. VLAN can be connected between separate instances of QEMU to
+simulate large networks. For simpler usage, a non privileged user mode
+network stack can replace the TAP device to have a basic network
+connection.
+</p>
+<a name="VLANs"></a>
+<h4 class="subsection">3.7.1 VLANs</h4>
+
+<p>QEMU simulates several VLANs. A VLAN can be symbolised as a virtual
+connection between several network devices. These devices can be for
+example QEMU virtual Ethernet cards or virtual Host ethernet devices
+(TAP devices).
+</p>
+<a name="Using-TAP-network-interfaces"></a>
+<h4 class="subsection">3.7.2 Using TAP network interfaces</h4>
+
+<p>This is the standard way to connect QEMU to a real network. QEMU adds
+a virtual network device on your host (called <code>tapN</code>), and you
+can then configure it as if it was a real ethernet card.
+</p>
+<a name="Linux-host"></a>
+<h4 class="subsubsection">3.7.2.1 Linux host</h4>
+
+<p>As an example, you can download the <samp>linux-test-xxx.tar.gz</samp>
+archive and copy the script <samp>qemu-ifup</samp> in <samp>/etc</samp> and
+configure properly <code>sudo</code> so that the command <code>ifconfig</code>
+contained in <samp>qemu-ifup</samp> can be executed as root. You must verify
+that your host kernel supports the TAP network interfaces: the
+device <samp>/dev/net/tun</samp> must be present.
+</p>
+<p>See <a href="#sec_005finvocation">sec_invocation</a> to have examples of command lines using the
+TAP network interfaces.
+</p>
+<a name="Windows-host"></a>
+<h4 class="subsubsection">3.7.2.2 Windows host</h4>
+
+<p>There is a virtual ethernet driver for Windows 2000/XP systems, called
+TAP-Win32. But it is not included in standard QEMU for Windows,
+so you will need to get it separately. It is part of OpenVPN package,
+so download OpenVPN from : <a href="http://openvpn.net/">http://openvpn.net/</a>.
+</p>
+<a name="Using-the-user-mode-network-stack"></a>
+<h4 class="subsection">3.7.3 Using the user mode network stack</h4>
+
+<p>By using the option <samp>-net user</samp> (default configuration if no
+<samp>-net</samp> option is specified), QEMU uses a completely user mode
+network stack (you don&rsquo;t need root privilege to use the virtual
+network). The virtual network configuration is the following:
+</p>
+<div class="example">
+<pre class="example">
+
+         QEMU VLAN      &lt;------&gt;  Firewall/DHCP server &lt;-----&gt; Internet
+                           |          (10.0.2.2)
+                           |
+                           ----&gt;  DNS server (10.0.2.3)
+                           |
+                           ----&gt;  SMB server (10.0.2.4)
+</pre></div>
+
+<p>The QEMU VM behaves as if it was behind a firewall which blocks all
+incoming connections. You can use a DHCP client to automatically
+configure the network in the QEMU VM. The DHCP server assign addresses
+to the hosts starting from 10.0.2.15.
+</p>
+<p>In order to check that the user mode network is working, you can ping
+the address 10.0.2.2 and verify that you got an address in the range
+10.0.2.x from the QEMU virtual DHCP server.
+</p>
+<p>Note that ICMP traffic in general does not work with user mode networking.
+<code>ping</code>, aka. ICMP echo, to the local router (10.0.2.2) shall work,
+however. If you&rsquo;re using QEMU on Linux &gt;= 3.0, it can use unprivileged ICMP
+ping sockets to allow <code>ping</code> to the Internet. The host admin has to set
+the ping_group_range in order to grant access to those sockets. To allow ping
+for GID 100 (usually users group):
+</p>
+<div class="example">
+<pre class="example">echo 100 100 &gt; /proc/sys/net/ipv4/ping_group_range
+</pre></div>
+
+<p>When using the built-in TFTP server, the router is also the TFTP
+server.
+</p>
+<p>When using the <samp>-redir</samp> option, TCP or UDP connections can be
+redirected from the host to the guest. It allows for example to
+redirect X11, telnet or SSH connections.
+</p>
+<a name="Connecting-VLANs-between-QEMU-instances"></a>
+<h4 class="subsection">3.7.4 Connecting VLANs between QEMU instances</h4>
+
+<p>Using the <samp>-net socket</samp> option, it is possible to make VLANs
+that span several QEMU instances. See <a href="#sec_005finvocation">sec_invocation</a> to have a
+basic example.
+</p>
+<hr>
+<a name="pcsys_005fother_005fdevs"></a>
+<a name="Other-Devices"></a>
+<h3 class="section">3.8 Other Devices</h3>
+
+<a name="Inter_002dVM-Shared-Memory-device"></a>
+<h4 class="subsection">3.8.1 Inter-VM Shared Memory device</h4>
+
+<p>With KVM enabled on a Linux host, a shared memory device is available.  Guests
+map a POSIX shared memory region into the guest as a PCI device that enables
+zero-copy communication to the application level of the guests.  The basic
+syntax is:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 -device ivshmem,size=&lt;size in format accepted by -m&gt;[,shm=&lt;shm name&gt;]
+</pre></div>
+
+<p>If desired, interrupts can be sent between guest VMs accessing the same shared
+memory region.  Interrupt support requires using a shared memory server and
+using a chardev socket to connect to it.  The code for the shared memory server
+is qemu.git/contrib/ivshmem-server.  An example syntax when using the shared
+memory server is:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 -device ivshmem,size=&lt;size in format accepted by -m&gt;[,chardev=&lt;id&gt;]
+                 [,msi=on][,ioeventfd=on][,vectors=n][,role=peer|master]
+qemu-system-i386 -chardev socket,path=&lt;path&gt;,id=&lt;id&gt;
+</pre></div>
+
+<p>When using the server, the guest will be assigned a VM ID (&gt;=0) that allows guests
+using the same server to communicate via interrupts.  Guests can read their
+VM ID from a device register (see example code).  Since receiving the shared
+memory region from the server is asynchronous, there is a (small) chance the
+guest may boot before the shared memory is attached.  To allow an application
+to ensure shared memory is attached, the VM ID register will return -1 (an
+invalid VM ID) until the memory is attached.  Once the shared memory is
+attached, the VM ID will return the guest&rsquo;s valid VM ID.  With these semantics,
+the guest application can check to ensure the shared memory is attached to the
+guest before proceeding.
+</p>
+<p>The <samp>role</samp> argument can be set to either master or peer and will affect
+how the shared memory is migrated.  With <samp>role=master</samp>, the guest will
+copy the shared memory on migration to the destination host.  With
+<samp>role=peer</samp>, the guest will not be able to migrate with the device attached.
+With the <samp>peer</samp> case, the device should be detached and then reattached
+after migration using the PCI hotplug support.
+</p>
+<hr>
+<a name="direct_005flinux_005fboot"></a>
+<a name="Direct-Linux-Boot"></a>
+<h3 class="section">3.9 Direct Linux Boot</h3>
+
+<p>This section explains how to launch a Linux kernel inside QEMU without
+having to make a full bootable image. It is very useful for fast Linux
+kernel testing.
+</p>
+<p>The syntax is:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -kernel arch/i386/boot/bzImage -hda root-2.4.20.img -append &quot;root=/dev/hda&quot;
+</pre></div>
+
+<p>Use <samp>-kernel</samp> to provide the Linux kernel image and
+<samp>-append</samp> to give the kernel command line arguments. The
+<samp>-initrd</samp> option can be used to provide an INITRD image.
+</p>
+<p>When using the direct Linux boot, a disk image for the first hard disk
+<samp>hda</samp> is required because its boot sector is used to launch the
+Linux kernel.
+</p>
+<p>If you do not need graphical output, you can disable it and redirect
+the virtual serial port and the QEMU monitor to the console with the
+<samp>-nographic</samp> option. The typical command line is:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \
+                 -append &quot;root=/dev/hda console=ttyS0&quot; -nographic
+</pre></div>
+
+<p>Use <tt class="key">Ctrl-a c</tt> to switch between the serial console and the
+monitor (see <a href="#pcsys_005fkeys">pcsys_keys</a>).
+</p>
+<hr>
+<a name="pcsys_005fusb"></a>
+<a name="USB-emulation"></a>
+<h3 class="section">3.10 USB emulation</h3>
+
+<p>QEMU emulates a PCI UHCI USB controller. You can virtually plug
+virtual USB devices or real host USB devices (experimental, works only
+on Linux hosts).  QEMU will automatically create and connect virtual USB hubs
+as necessary to connect multiple USB devices.
+</p>
+<hr>
+<a name="usb_005fdevices"></a>
+<a name="Connecting-USB-devices"></a>
+<h4 class="subsection">3.10.1 Connecting USB devices</h4>
+
+<p>USB devices can be connected with the <samp>-usbdevice</samp> commandline option
+or the <code>usb_add</code> monitor command.  Available devices are:
+</p>
+<dl compact="compact">
+<dt><code>mouse</code></dt>
+<dd><p>Virtual Mouse.  This will override the PS/2 mouse emulation when activated.
+</p></dd>
+<dt><code>tablet</code></dt>
+<dd><p>Pointer device that uses absolute coordinates (like a touchscreen).
+This means QEMU is able to report the mouse position without having
+to grab the mouse.  Also overrides the PS/2 mouse emulation when activated.
+</p></dd>
+<dt><code>disk:<var>file</var></code></dt>
+<dd><p>Mass storage device based on <var>file</var> (see <a href="#disk_005fimages">disk_images</a>)
+</p></dd>
+<dt><code>host:<var>bus.addr</var></code></dt>
+<dd><p>Pass through the host device identified by <var>bus.addr</var>
+(Linux only)
+</p></dd>
+<dt><code>host:<var>vendor_id:product_id</var></code></dt>
+<dd><p>Pass through the host device identified by <var>vendor_id:product_id</var>
+(Linux only)
+</p></dd>
+<dt><code>wacom-tablet</code></dt>
+<dd><p>Virtual Wacom PenPartner tablet.  This device is similar to the <code>tablet</code>
+above but it can be used with the tslib library because in addition to touch
+coordinates it reports touch pressure.
+</p></dd>
+<dt><code>keyboard</code></dt>
+<dd><p>Standard USB keyboard.  Will override the PS/2 keyboard (if present).
+</p></dd>
+<dt><code>serial:[vendorid=<var>vendor_id</var>][,product_id=<var>product_id</var>]:<var>dev</var></code></dt>
+<dd><p>Serial converter. This emulates an FTDI FT232BM chip connected to host character
+device <var>dev</var>. The available character devices are the same as for the
+<code>-serial</code> option. The <code>vendorid</code> and <code>productid</code> options can be
+used to override the default 0403:6001. For instance,
+</p><div class="example">
+<pre class="example">usb_add serial:productid=FA00:tcp:192.168.0.2:4444
+</pre></div>
+<p>will connect to tcp port 4444 of ip 192.168.0.2, and plug that to the virtual
+serial converter, faking a Matrix Orbital LCD Display (USB ID 0403:FA00).
+</p></dd>
+<dt><code>braille</code></dt>
+<dd><p>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+</p></dd>
+<dt><code>net:<var>options</var></code></dt>
+<dd><p>Network adapter that supports CDC ethernet and RNDIS protocols.  <var>options</var>
+specifies NIC options as with <code>-net nic,</code><var>options</var> (see description).
+For instance, user-mode networking can be used with
+</p><div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -net user,vlan=0 -usbdevice net:vlan=0
+</pre></div>
+<p>Currently this cannot be used in machines that support PCI NICs.
+</p></dd>
+<dt><code>bt[:<var>hci-type</var>]</code></dt>
+<dd><p>Bluetooth dongle whose type is specified in the same format as with
+the <samp>-bt hci</samp> option, see <a href="#bt_002dhcis">allowed HCI types</a>.  If
+no type is given, the HCI logic corresponds to <code>-bt hci,vlan=0</code>.
+This USB device implements the USB Transport Layer of HCI.  Example
+usage:
+</p><div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -usbdevice bt:hci,vlan=3 -bt device:keyboard,vlan=3
+</pre></div>
+</dd>
+</dl>
+
+<hr>
+<a name="host_005fusb_005fdevices"></a>
+<a name="Using-host-USB-devices-on-a-Linux-host"></a>
+<h4 class="subsection">3.10.2 Using host USB devices on a Linux host</h4>
+
+<p>WARNING: this is an experimental feature. QEMU will slow down when
+using it. USB devices requiring real time streaming (i.e. USB Video
+Cameras) are not supported yet.
+</p>
+<ol>
+<li> If you use an early Linux 2.4 kernel, verify that no Linux driver
+is actually using the USB device. A simple way to do that is simply to
+disable the corresponding kernel module by renaming it from <samp>mydriver.o</samp>
+to <samp>mydriver.o.disabled</samp>.
+
+</li><li> Verify that <samp>/proc/bus/usb</samp> is working (most Linux distributions should enable it by default). You should see something like that:
+<div class="example">
+<pre class="example">ls /proc/bus/usb
+001  devices  drivers
+</pre></div>
+
+</li><li> Since only root can access to the USB devices directly, you can either launch QEMU as root or change the permissions of the USB devices you want to use. For testing, the following suffices:
+<div class="example">
+<pre class="example">chown -R myuid /proc/bus/usb
+</pre></div>
+
+</li><li> Launch QEMU and do in the monitor:
+<div class="example">
+<pre class="example">info usbhost
+  Device 1.2, speed 480 Mb/s
+    Class 00: USB device 1234:5678, USB DISK
+</pre></div>
+<p>You should see the list of the devices you can use (Never try to use
+hubs, it won&rsquo;t work).
+</p>
+</li><li> Add the device in QEMU by using:
+<div class="example">
+<pre class="example">usb_add host:1234:5678
+</pre></div>
+
+<p>Normally the guest OS should report that a new USB device is
+plugged. You can use the option <samp>-usbdevice</samp> to do the same.
+</p>
+</li><li> Now you can try to use the host USB device in QEMU.
+
+</li></ol>
+
+<p>When relaunching QEMU, you may have to unplug and plug again the USB
+device to make it work again (this is a bug).
+</p>
+<hr>
+<a name="vnc_005fsecurity"></a>
+<a name="VNC-security"></a>
+<h3 class="section">3.11 VNC security</h3>
+
+<p>The VNC server capability provides access to the graphical console
+of the guest VM across the network. This has a number of security
+considerations depending on the deployment scenarios.
+</p>
+<hr>
+<a name="vnc_005fsec_005fnone"></a>
+<a name="Without-passwords"></a>
+<h4 class="subsection">3.11.1 Without passwords</h4>
+
+<p>The simplest VNC server setup does not include any form of authentication.
+For this setup it is recommended to restrict it to listen on a UNIX domain
+socket only. For example
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc unix:/home/joebloggs/.qemu-myvm-vnc
+</pre></div>
+
+<p>This ensures that only users on local box with read/write access to that
+path can access the VNC server. To securely access the VNC server from a
+remote machine, a combination of netcat+ssh can be used to provide a secure
+tunnel.
+</p>
+<hr>
+<a name="vnc_005fsec_005fpassword"></a>
+<a name="With-passwords"></a>
+<h4 class="subsection">3.11.2 With passwords</h4>
+
+<p>The VNC protocol has limited support for password based authentication. Since
+the protocol limits passwords to 8 characters it should not be considered
+to provide high security. The password can be fairly easily brute-forced by
+a client making repeat connections. For this reason, a VNC server using password
+authentication should be restricted to only listen on the loopback interface
+or UNIX domain sockets. Password authentication is not supported when operating
+in FIPS 140-2 compliance mode as it requires the use of the DES cipher. Password
+authentication is requested with the <code>password</code> option, and then once QEMU
+is running the password is set with the monitor. Until the monitor is used to
+set the password all clients will be rejected.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,password -monitor stdio
+(qemu) change vnc password
+Password: ********
+(qemu)
+</pre></div>
+
+<hr>
+<a name="vnc_005fsec_005fcertificate"></a>
+<a name="With-x509-certificates"></a>
+<h4 class="subsection">3.11.3 With x509 certificates</h4>
+
+<p>The QEMU VNC server also implements the VeNCrypt extension allowing use of
+TLS for encryption of the session, and x509 certificates for authentication.
+The use of x509 certificates is strongly recommended, because TLS on its
+own is susceptible to man-in-the-middle attacks. Basic x509 certificate
+support provides a secure session, but no authentication. This allows any
+client to connect, and provides an encrypted session.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509=/etc/pki/qemu -monitor stdio
+</pre></div>
+
+<p>In the above example <code>/etc/pki/qemu</code> should contain at least three files,
+<code>ca-cert.pem</code>, <code>server-cert.pem</code> and <code>server-key.pem</code>. Unprivileged
+users will want to use a private directory, for example <code>$HOME/.pki/qemu</code>.
+NB the <code>server-key.pem</code> file should be protected with file mode 0600 to
+only be readable by the user owning it.
+</p>
+<hr>
+<a name="vnc_005fsec_005fcertificate_005fverify"></a>
+<a name="With-x509-certificates-and-client-verification"></a>
+<h4 class="subsection">3.11.4 With x509 certificates and client verification</h4>
+
+<p>Certificates can also provide a means to authenticate the client connecting.
+The server will request that the client provide a certificate, which it will
+then validate against the CA certificate. This is a good choice if deploying
+in an environment with a private internal certificate authority.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509verify=/etc/pki/qemu -monitor stdio
+</pre></div>
+
+
+<hr>
+<a name="vnc_005fsec_005fcertificate_005fpw"></a>
+<a name="With-x509-certificates_002c-client-verification-and-passwords"></a>
+<h4 class="subsection">3.11.5 With x509 certificates, client verification and passwords</h4>
+
+<p>Finally, the previous method can be combined with VNC password authentication
+to provide two layers of authentication for clients.
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,password,tls,x509verify=/etc/pki/qemu -monitor stdio
+(qemu) change vnc password
+Password: ********
+(qemu)
+</pre></div>
+
+
+<hr>
+<a name="vnc_005fsec_005fsasl"></a>
+<a name="With-SASL-authentication"></a>
+<h4 class="subsection">3.11.6 With SASL authentication</h4>
+
+<p>The SASL authentication method is a VNC extension, that provides an
+easily extendable, pluggable authentication method. This allows for
+integration with a wide range of authentication mechanisms, such as
+PAM, GSSAPI/Kerberos, LDAP, SQL databases, one-time keys and more.
+The strength of the authentication depends on the exact mechanism
+configured. If the chosen mechanism also provides a SSF layer, then
+it will encrypt the datastream as well.
+</p>
+<p>Refer to the later docs on how to choose the exact SASL mechanism
+used for authentication, but assuming use of one supporting SSF,
+then QEMU can be launched with:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,sasl -monitor stdio
+</pre></div>
+
+<hr>
+<a name="vnc_005fsec_005fcertificate_005fsasl"></a>
+<a name="With-x509-certificates-and-SASL-authentication"></a>
+<h4 class="subsection">3.11.7 With x509 certificates and SASL authentication</h4>
+
+<p>If the desired SASL authentication mechanism does not supported
+SSF layers, then it is strongly advised to run it in combination
+with TLS and x509 certificates. This provides securely encrypted
+data stream, avoiding risk of compromising of the security
+credentials. This can be enabled, by combining the &rsquo;sasl&rsquo; option
+with the aforementioned TLS + x509 options:
+</p>
+<div class="example">
+<pre class="example">qemu-system-i386 [...OPTIONS...] -vnc :1,tls,x509,sasl -monitor stdio
+</pre></div>
+
+
+<hr>
+<a name="vnc_005fgenerate_005fcert"></a>
+<a name="Generating-certificates-for-VNC"></a>
+<h4 class="subsection">3.11.8 Generating certificates for VNC</h4>
+
+<p>The GNU TLS packages provides a command called <code>certtool</code> which can
+be used to generate certificates and keys in PEM format. At a minimum it
+is necessary to setup a certificate authority, and issue certificates to
+each server. If using certificates for authentication, then each client
+will also need to be issued a certificate. The recommendation is for the
+server to keep its certificates in either <code>/etc/pki/qemu</code> or for
+unprivileged users in <code>$HOME/.pki/qemu</code>.
+</p>
+<hr>
+<a name="vnc_005fgenerate_005fca"></a>
+<a name="Setup-the-Certificate-Authority"></a>
+<h4 class="subsubsection">3.11.8.1 Setup the Certificate Authority</h4>
+
+<p>This step only needs to be performed once per organization / organizational
+unit. First the CA needs a private key. This key must be kept VERY secret
+and secure. If this key is compromised the entire trust chain of the certificates
+issued with it is lost.
+</p>
+<div class="example">
+<pre class="example"># certtool --generate-privkey &gt; ca-key.pem
+</pre></div>
+
+<p>A CA needs to have a public certificate. For simplicity it can be a self-signed
+certificate, or one issue by a commercial certificate issuing authority. To
+generate a self-signed certificate requires one core piece of information, the
+name of the organization.
+</p>
+<div class="example">
+<pre class="example"># cat &gt; ca.info &lt;&lt;EOF
+cn = Name of your organization
+ca
+cert_signing_key
+EOF
+# certtool --generate-self-signed \
+           --load-privkey ca-key.pem
+           --template ca.info \
+           --outfile ca-cert.pem
+</pre></div>
+
+<p>The <code>ca-cert.pem</code> file should be copied to all servers and clients wishing to utilize
+TLS support in the VNC server. The <code>ca-key.pem</code> must not be disclosed/copied at all.
+</p>
+<hr>
+<a name="vnc_005fgenerate_005fserver"></a>
+<a name="Issuing-server-certificates"></a>
+<h4 class="subsubsection">3.11.8.2 Issuing server certificates</h4>
+
+<p>Each server (or host) needs to be issued with a key and certificate. When connecting
+the certificate is sent to the client which validates it against the CA certificate.
+The core piece of information for a server certificate is the hostname. This should
+be the fully qualified hostname that the client will connect with, since the client
+will typically also verify the hostname in the certificate. On the host holding the
+secure CA private key:
+</p>
+<div class="example">
+<pre class="example"># cat &gt; server.info &lt;&lt;EOF
+organization = Name  of your organization
+cn = server.foo.example.com
+tls_www_server
+encryption_key
+signing_key
+EOF
+# certtool --generate-privkey &gt; server-key.pem
+# certtool --generate-certificate \
+           --load-ca-certificate ca-cert.pem \
+           --load-ca-privkey ca-key.pem \
+           --load-privkey server-key.pem \
+           --template server.info \
+           --outfile server-cert.pem
+</pre></div>
+
+<p>The <code>server-key.pem</code> and <code>server-cert.pem</code> files should now be securely copied
+to the server for which they were generated. The <code>server-key.pem</code> is security
+sensitive and should be kept protected with file mode 0600 to prevent disclosure.
+</p>
+<hr>
+<a name="vnc_005fgenerate_005fclient"></a>
+<a name="Issuing-client-certificates"></a>
+<h4 class="subsubsection">3.11.8.3 Issuing client certificates</h4>
+
+<p>If the QEMU VNC server is to use the <code>x509verify</code> option to validate client
+certificates as its authentication mechanism, each client also needs to be issued
+a certificate. The client certificate contains enough metadata to uniquely identify
+the client, typically organization, state, city, building, etc. On the host holding
+the secure CA private key:
+</p>
+<div class="example">
+<pre class="example"># cat &gt; client.info &lt;&lt;EOF
+country = GB
+state = London
+locality = London
+organization = Name of your organization
+cn = client.foo.example.com
+tls_www_client
+encryption_key
+signing_key
+EOF
+# certtool --generate-privkey &gt; client-key.pem
+# certtool --generate-certificate \
+           --load-ca-certificate ca-cert.pem \
+           --load-ca-privkey ca-key.pem \
+           --load-privkey client-key.pem \
+           --template client.info \
+           --outfile client-cert.pem
+</pre></div>
+
+<p>The <code>client-key.pem</code> and <code>client-cert.pem</code> files should now be securely
+copied to the client for which they were generated.
+</p>
+
+<hr>
+<a name="vnc_005fsetup_005fsasl"></a>
+
+<a name="Configuring-SASL-mechanisms"></a>
+<h4 class="subsection">3.11.9 Configuring SASL mechanisms</h4>
+
+<p>The following documentation assumes use of the Cyrus SASL implementation on a
+Linux host, but the principals should apply to any other SASL impl. When SASL
+is enabled, the mechanism configuration will be loaded from system default
+SASL service config /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config.
+</p>
+<p>The default configuration might contain
+</p>
+<div class="example">
+<pre class="example">mech_list: digest-md5
+sasldb_path: /etc/qemu/passwd.db
+</pre></div>
+
+<p>This says to use the &rsquo;Digest MD5&rsquo; mechanism, which is similar to the HTTP
+Digest-MD5 mechanism. The list of valid usernames &amp; passwords is maintained
+in the /etc/qemu/passwd.db file, and can be updated using the saslpasswd2
+command. While this mechanism is easy to configure and use, it is not
+considered secure by modern standards, so only suitable for developers /
+ad-hoc testing.
+</p>
+<p>A more serious deployment might use Kerberos, which is done with the &rsquo;gssapi&rsquo;
+mechanism
+</p>
+<div class="example">
+<pre class="example">mech_list: gssapi
+keytab: /etc/qemu/krb5.tab
+</pre></div>
+
+<p>For this to work the administrator of your KDC must generate a Kerberos
+principal for the server, with a name of  &rsquo;qemu/somehost.example.com@EXAMPLE.COM&rsquo;
+replacing &rsquo;somehost.example.com&rsquo; with the fully qualified host name of the
+machine running QEMU, and &rsquo;EXAMPLE.COM&rsquo; with the Kerberos Realm.
+</p>
+<p>Other configurations will be left as an exercise for the reader. It should
+be noted that only Digest-MD5 and GSSAPI provides a SSF layer for data
+encryption. For all other mechanisms, VNC should always be configured to
+use TLS and x509 certificates to protect security credentials from snooping.
+</p>
+<hr>
+<a name="gdb_005fusage"></a>
+<a name="GDB-usage"></a>
+<h3 class="section">3.12 GDB usage</h3>
+
+<p>QEMU has a primitive support to work with gdb, so that you can do
+&rsquo;Ctrl-C&rsquo; while the virtual machine is running and inspect its state.
+</p>
+<p>In order to use gdb, launch QEMU with the &rsquo;-s&rsquo; option. It will wait for a
+gdb connection:
+</p><div class="example">
+<pre class="example">qemu-system-i386 -s -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \
+                    -append &quot;root=/dev/hda&quot;
+Connected to host network interface: tun0
+Waiting gdb connection on port 1234
+</pre></div>
+
+<p>Then launch gdb on the &rsquo;vmlinux&rsquo; executable:
+</p><div class="example">
+<pre class="example">&gt; gdb vmlinux
+</pre></div>
+
+<p>In gdb, connect to QEMU:
+</p><div class="example">
+<pre class="example">(gdb) target remote localhost:1234
+</pre></div>
+
+<p>Then you can use gdb normally. For example, type &rsquo;c&rsquo; to launch the kernel:
+</p><div class="example">
+<pre class="example">(gdb) c
+</pre></div>
+
+<p>Here are some useful tips in order to use gdb on system code:
+</p>
+<ol>
+<li> Use <code>info reg</code> to display all the CPU registers.
+</li><li> Use <code>x/10i $eip</code> to display the code at the PC position.
+</li><li> Use <code>set architecture i8086</code> to dump 16 bit code. Then use
+<code>x/10i $cs*16+$eip</code> to dump the code at the PC position.
+</li></ol>
+
+<p>Advanced debugging options:
+</p>
+<p>The default single stepping behavior is step with the IRQs and timer service routines off.  It is set this way because when gdb executes a single step it expects to advance beyond the current instruction.  With the IRQs and and timer service routines on, a single step might jump into the one of the interrupt or exception vectors instead of executing the current instruction. This means you may hit the same breakpoint a number of times before executing the instruction gdb wants to have executed.  Because there are rare circumstances where you want to single step into an interrupt vector the behavior can be controlled from GDB.  There are three commands you can query and set the single step behavior:
+</p><dl compact="compact">
+<dt><code>maintenance packet qqemu.sstepbits</code></dt>
+<dd>
+<p>This will display the MASK bits used to control the single stepping IE:
+</p><div class="example">
+<pre class="example">(gdb) maintenance packet qqemu.sstepbits
+sending: &quot;qqemu.sstepbits&quot;
+received: &quot;ENABLE=1,NOIRQ=2,NOTIMER=4&quot;
+</pre></div>
+</dd>
+<dt><code>maintenance packet qqemu.sstep</code></dt>
+<dd>
+<p>This will display the current value of the mask used when single stepping IE:
+</p><div class="example">
+<pre class="example">(gdb) maintenance packet qqemu.sstep
+sending: &quot;qqemu.sstep&quot;
+received: &quot;0x7&quot;
+</pre></div>
+</dd>
+<dt><code>maintenance packet Qqemu.sstep=HEX_VALUE</code></dt>
+<dd>
+<p>This will change the single step mask, so if wanted to enable IRQs on the single step, but not timers, you would use:
+</p><div class="example">
+<pre class="example">(gdb) maintenance packet Qqemu.sstep=0x5
+sending: &quot;qemu.sstep=0x5&quot;
+received: &quot;OK&quot;
+</pre></div>
+</dd>
+</dl>
+
+<hr>
+<a name="pcsys_005fos_005fspecific"></a>
+<a name="Target-OS-specific-information"></a>
+<h3 class="section">3.13 Target OS specific information</h3>
+
+<a name="Linux-2"></a>
+<h4 class="subsection">3.13.1 Linux</h4>
+
+<p>To have access to SVGA graphic modes under X11, use the <code>vesa</code> or
+the <code>cirrus</code> X11 driver. For optimal performances, use 16 bit
+color depth in the guest and the host OS.
+</p>
+<p>When using a 2.6 guest Linux kernel, you should add the option
+<code>clock=pit</code> on the kernel command line because the 2.6 Linux
+kernels make very strict real time clock checks by default that QEMU
+cannot simulate exactly.
+</p>
+<p>When using a 2.6 guest Linux kernel, verify that the 4G/4G patch is
+not activated because QEMU is slower with this patch. The QEMU
+Accelerator Module is also much slower in this case. Earlier Fedora
+Core 3 Linux kernel (&lt; 2.6.9-1.724_FC3) were known to incorporate this
+patch by default. Newer kernels don&rsquo;t have it.
+</p>
+<a name="Windows-3"></a>
+<h4 class="subsection">3.13.2 Windows</h4>
+
+<p>If you have a slow host, using Windows 95 is better as it gives the
+best speed. Windows 2000 is also a good choice.
+</p>
+<a name="SVGA-graphic-modes-support"></a>
+<h4 class="subsubsection">3.13.2.1 SVGA graphic modes support</h4>
+
+<p>QEMU emulates a Cirrus Logic GD5446 Video
+card. All Windows versions starting from Windows 95 should recognize
+and use this graphic card. For optimal performances, use 16 bit color
+depth in the guest and the host OS.
+</p>
+<p>If you are using Windows XP as guest OS and if you want to use high
+resolution modes which the Cirrus Logic BIOS does not support (i.e. &gt;=
+1280x1024x16), then you should use the VESA VBE virtual graphic card
+(option <samp>-std-vga</samp>).
+</p>
+<a name="CPU-usage-reduction"></a>
+<h4 class="subsubsection">3.13.2.2 CPU usage reduction</h4>
+
+<p>Windows 9x does not correctly use the CPU HLT
+instruction. The result is that it takes host CPU cycles even when
+idle. You can install the utility from
+<a href="http://www.user.cityline.ru/~maxamn/amnhltm.zip">http://www.user.cityline.ru/~maxamn/amnhltm.zip</a> to solve this
+problem. Note that no such tool is needed for NT, 2000 or XP.
+</p>
+<a name="Windows-2000-disk-full-problem"></a>
+<h4 class="subsubsection">3.13.2.3 Windows 2000 disk full problem</h4>
+
+<p>Windows 2000 has a bug which gives a disk full problem during its
+installation. When installing it, use the <samp>-win2k-hack</samp> QEMU
+option to enable a specific workaround. After Windows 2000 is
+installed, you no longer need this option (this option slows down the
+IDE transfers).
+</p>
+<a name="Windows-2000-shutdown"></a>
+<h4 class="subsubsection">3.13.2.4 Windows 2000 shutdown</h4>
+
+<p>Windows 2000 cannot automatically shutdown in QEMU although Windows 98
+can. It comes from the fact that Windows 2000 does not automatically
+use the APM driver provided by the BIOS.
+</p>
+<p>In order to correct that, do the following (thanks to Struan
+Bartlett): go to the Control Panel =&gt; Add/Remove Hardware &amp; Next =&gt;
+Add/Troubleshoot a device =&gt; Add a new device &amp; Next =&gt; No, select the
+hardware from a list &amp; Next =&gt; NT Apm/Legacy Support &amp; Next =&gt; Next
+(again) a few times. Now the driver is installed and Windows 2000 now
+correctly instructs QEMU to shutdown at the appropriate moment.
+</p>
+<a name="Share-a-directory-between-Unix-and-Windows"></a>
+<h4 class="subsubsection">3.13.2.5 Share a directory between Unix and Windows</h4>
+
+<p>See <a href="#sec_005finvocation">sec_invocation</a> about the help of the option <samp>-smb</samp>.
+</p>
+<a name="Windows-XP-security-problem"></a>
+<h4 class="subsubsection">3.13.2.6 Windows XP security problem</h4>
+
+<p>Some releases of Windows XP install correctly but give a security
+error when booting:
+</p><div class="example">
+<pre class="example">A problem is preventing Windows from accurately checking the
+license for this computer. Error code: 0x800703e6.
+</pre></div>
+
+<p>The workaround is to install a service pack for XP after a boot in safe
+mode. Then reboot, and the problem should go away. Since there is no
+network while in safe mode, its recommended to download the full
+installation of SP1 or SP2 and transfer that via an ISO or using the
+vvfat block device (&quot;-hdb fat:directory_which_holds_the_SP&quot;).
+</p>
+<a name="MS_002dDOS-and-FreeDOS"></a>
+<h4 class="subsection">3.13.3 MS-DOS and FreeDOS</h4>
+
+<a name="CPU-usage-reduction-1"></a>
+<h4 class="subsubsection">3.13.3.1 CPU usage reduction</h4>
+
+<p>DOS does not correctly use the CPU HLT instruction. The result is that
+it takes host CPU cycles even when idle. You can install the utility
+from <a href="http://www.vmware.com/software/dosidle210.zip">http://www.vmware.com/software/dosidle210.zip</a> to solve this
+problem.
+</p>
+<hr>
+<a name="QEMU-System-emulator-for-non-PC-targets"></a>
+<a name="QEMU-System-emulator-for-non-PC-targets-1"></a>
+<h2 class="chapter">4 QEMU System emulator for non PC targets</h2>
+
+<p>QEMU is a generic emulator and it emulates many non PC
+machines. Most of the options are similar to the PC emulator. The
+differences are mentioned in the following sections.
+</p>
+
+<hr>
+<a name="PowerPC-System-emulator"></a>
+<a name="PowerPC-System-emulator-1"></a>
+<h3 class="section">4.1 PowerPC System emulator</h3>
+<a name="index-system-emulation-_0028PowerPC_0029"></a>
+
+<p>Use the executable <samp>qemu-system-ppc</samp> to simulate a complete PREP
+or PowerMac PowerPC system.
+</p>
+<p>QEMU emulates the following PowerMac peripherals:
+</p>
+<ul class="no-bullet">
+<li>- UniNorth or Grackle PCI Bridge
+</li><li>- PCI VGA compatible card with VESA Bochs Extensions
+</li><li>- 2 PMAC IDE interfaces with hard disk and CD-ROM support
+</li><li>- NE2000 PCI adapters
+</li><li>- Non Volatile RAM
+</li><li>- VIA-CUDA with ADB keyboard and mouse.
+</li></ul>
+
+<p>QEMU emulates the following PREP peripherals:
+</p>
+<ul class="no-bullet">
+<li>- PCI Bridge
+</li><li>- PCI VGA compatible card with VESA Bochs Extensions
+</li><li>- 2 IDE interfaces with hard disk and CD-ROM support
+</li><li>- Floppy disk
+</li><li>- NE2000 network adapters
+</li><li>- Serial port
+</li><li>- PREP Non Volatile RAM
+</li><li>- PC compatible keyboard and mouse.
+</li></ul>
+
+<p>QEMU uses the Open Hack&rsquo;Ware Open Firmware Compatible BIOS available at
+<a href="http://perso.magic.fr/l_indien/OpenHackWare/index.htm">http://perso.magic.fr/l_indien/OpenHackWare/index.htm</a>.
+</p>
+<p>Since version 0.9.1, QEMU uses OpenBIOS <a href="http://www.openbios.org/">http://www.openbios.org/</a>
+for the g3beige and mac99 PowerMac machines. OpenBIOS is a free (GPL
+v2) portable firmware implementation. The goal is to implement a 100%
+IEEE 1275-1994 (referred to as Open Firmware) compliant firmware.
+</p>
+
+<p>The following options are specific to the PowerPC emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-g <var>W</var>x<var>H</var>[x<var>DEPTH</var>]</samp></dt>
+<dd>
+<p>Set the initial VGA graphic mode. The default is 800x600x32.
+</p>
+</dd>
+<dt><samp>-prom-env <var>string</var></samp></dt>
+<dd>
+<p>Set OpenBIOS variables in NVRAM, for example:
+</p>
+<div class="example">
+<pre class="example">qemu-system-ppc -prom-env 'auto-boot?=false' \
+ -prom-env 'boot-device=hd:2,\yaboot' \
+ -prom-env 'boot-args=conf=hd:2,\yaboot.conf'
+</pre></div>
+
+<p>These variables are not used by Open Hack&rsquo;Ware.
+</p>
+</dd>
+</dl>
+
+
+
+<p>More information is available at
+<a href="http://perso.magic.fr/l_indien/qemu-ppc/">http://perso.magic.fr/l_indien/qemu-ppc/</a>.
+</p>
+<hr>
+<a name="Sparc32-System-emulator"></a>
+<a name="Sparc32-System-emulator-1"></a>
+<h3 class="section">4.2 Sparc32 System emulator</h3>
+<a name="index-system-emulation-_0028Sparc32_0029"></a>
+
+<p>Use the executable <samp>qemu-system-sparc</samp> to simulate the following
+Sun4m architecture machines:
+</p><ul class="no-bullet">
+<li>- SPARCstation 4
+</li><li>- SPARCstation 5
+</li><li>- SPARCstation 10
+</li><li>- SPARCstation 20
+</li><li>- SPARCserver 600MP
+</li><li>- SPARCstation LX
+</li><li>- SPARCstation Voyager
+</li><li>- SPARCclassic
+</li><li>- SPARCbook
+</li></ul>
+
+<p>The emulation is somewhat complete. SMP up to 16 CPUs is supported,
+but Linux limits the number of usable CPUs to 4.
+</p>
+<p>QEMU emulates the following sun4m peripherals:
+</p>
+<ul class="no-bullet">
+<li>- IOMMU
+</li><li>- TCX or cgthree Frame buffer
+</li><li>- Lance (Am7990) Ethernet
+</li><li>- Non Volatile RAM M48T02/M48T08
+</li><li>- Slave I/O: timers, interrupt controllers, Zilog serial ports, keyboard
+and power/reset logic
+</li><li>- ESP SCSI controller with hard disk and CD-ROM support
+</li><li>- Floppy drive (not on SS-600MP)
+</li><li>- CS4231 sound device (only on SS-5, not working yet)
+</li></ul>
+
+<p>The number of peripherals is fixed in the architecture.  Maximum
+memory size depends on the machine type, for SS-5 it is 256MB and for
+others 2047MB.
+</p>
+<p>Since version 0.8.2, QEMU uses OpenBIOS
+<a href="http://www.openbios.org/">http://www.openbios.org/</a>. OpenBIOS is a free (GPL v2) portable
+firmware implementation. The goal is to implement a 100% IEEE
+1275-1994 (referred to as Open Firmware) compliant firmware.
+</p>
+<p>A sample Linux 2.6 series kernel and ram disk image are available on
+the QEMU web site. There are still issues with NetBSD and OpenBSD, but
+most kernel versions work. Please note that currently older Solaris kernels
+don&rsquo;t work probably due to interface issues between OpenBIOS and
+Solaris.
+</p>
+
+<p>The following options are specific to the Sparc32 emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-g <var>W</var>x<var>H</var>x[x<var>DEPTH</var>]</samp></dt>
+<dd>
+<p>Set the initial graphics mode. For TCX, the default is 1024x768x8 with the
+option of 1024x768x24. For cgthree, the default is 1024x768x8 with the option
+of 1152x900x8 for people who wish to use OBP.
+</p>
+</dd>
+<dt><samp>-prom-env <var>string</var></samp></dt>
+<dd>
+<p>Set OpenBIOS variables in NVRAM, for example:
+</p>
+<div class="example">
+<pre class="example">qemu-system-sparc -prom-env 'auto-boot?=false' \
+ -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'
+</pre></div>
+
+</dd>
+<dt><samp>-M [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic] [|SPARCbook]</samp></dt>
+<dd>
+<p>Set the emulated machine type. Default is SS-5.
+</p>
+</dd>
+</dl>
+
+
+<hr>
+<a name="Sparc64-System-emulator"></a>
+<a name="Sparc64-System-emulator-1"></a>
+<h3 class="section">4.3 Sparc64 System emulator</h3>
+<a name="index-system-emulation-_0028Sparc64_0029"></a>
+
+<p>Use the executable <samp>qemu-system-sparc64</samp> to simulate a Sun4u
+(UltraSPARC PC-like machine), Sun4v (T1 PC-like machine), or generic
+Niagara (T1) machine. The Sun4u emulator is mostly complete, being
+able to run Linux, NetBSD and OpenBSD in headless (-nographic) mode. The
+Sun4v and Niagara emulators are still a work in progress.
+</p>
+<p>QEMU emulates the following peripherals:
+</p>
+<ul class="no-bullet">
+<li>- UltraSparc IIi APB PCI Bridge
+</li><li>- PCI VGA compatible card with VESA Bochs Extensions
+</li><li>- PS/2 mouse and keyboard
+</li><li>- Non Volatile RAM M48T59
+</li><li>- PC-compatible serial ports
+</li><li>- 2 PCI IDE interfaces with hard disk and CD-ROM support
+</li><li>- Floppy disk
+</li></ul>
+
+
+<p>The following options are specific to the Sparc64 emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-prom-env <var>string</var></samp></dt>
+<dd>
+<p>Set OpenBIOS variables in NVRAM, for example:
+</p>
+<div class="example">
+<pre class="example">qemu-system-sparc64 -prom-env 'auto-boot?=false'
+</pre></div>
+
+</dd>
+<dt><samp>-M [sun4u|sun4v|Niagara]</samp></dt>
+<dd>
+<p>Set the emulated machine type. The default is sun4u.
+</p>
+</dd>
+</dl>
+
+
+<hr>
+<a name="MIPS-System-emulator"></a>
+<a name="MIPS-System-emulator-1"></a>
+<h3 class="section">4.4 MIPS System emulator</h3>
+<a name="index-system-emulation-_0028MIPS_0029"></a>
+
+<p>Four executables cover simulation of 32 and 64-bit MIPS systems in
+both endian options, <samp>qemu-system-mips</samp>, <samp>qemu-system-mipsel</samp>
+<samp>qemu-system-mips64</samp> and <samp>qemu-system-mips64el</samp>.
+Five different machine types are emulated:
+</p>
+<ul class="no-bullet">
+<li>- A generic ISA PC-like machine &quot;mips&quot;
+</li><li>- The MIPS Malta prototype board &quot;malta&quot;
+</li><li>- An ACER Pica &quot;pica61&quot;. This machine needs the 64-bit emulator.
+</li><li>- MIPS emulator pseudo board &quot;mipssim&quot;
+</li><li>- A MIPS Magnum R4000 machine &quot;magnum&quot;. This machine needs the 64-bit emulator.
+</li></ul>
+
+<p>The generic emulation is supported by Debian &rsquo;Etch&rsquo; and is able to
+install Debian into a virtual disk image. The following devices are
+emulated:
+</p>
+<ul class="no-bullet">
+<li>- A range of MIPS CPUs, default is the 24Kf
+</li><li>- PC style serial port
+</li><li>- PC style IDE disk
+</li><li>- NE2000 network card
+</li></ul>
+
+<p>The Malta emulation supports the following devices:
+</p>
+<ul class="no-bullet">
+<li>- Core board with MIPS 24Kf CPU and Galileo system controller
+</li><li>- PIIX4 PCI/USB/SMbus controller
+</li><li>- The Multi-I/O chip&rsquo;s serial device
+</li><li>- PCI network cards (PCnet32 and others)
+</li><li>- Malta FPGA serial device
+</li><li>- Cirrus (default) or any other PCI VGA graphics card
+</li></ul>
+
+<p>The ACER Pica emulation supports:
+</p>
+<ul class="no-bullet">
+<li>- MIPS R4000 CPU
+</li><li>- PC-style IRQ and DMA controllers
+</li><li>- PC Keyboard
+</li><li>- IDE controller
+</li></ul>
+
+<p>The mipssim pseudo board emulation provides an environment similar
+to what the proprietary MIPS emulator uses for running Linux.
+It supports:
+</p>
+<ul class="no-bullet">
+<li>- A range of MIPS CPUs, default is the 24Kf
+</li><li>- PC style serial port
+</li><li>- MIPSnet network emulation
+</li></ul>
+
+<p>The MIPS Magnum R4000 emulation supports:
+</p>
+<ul class="no-bullet">
+<li>- MIPS R4000 CPU
+</li><li>- PC-style IRQ controller
+</li><li>- PC Keyboard
+</li><li>- SCSI controller
+</li><li>- G364 framebuffer
+</li></ul>
+
+
+<hr>
+<a name="ARM-System-emulator"></a>
+<a name="ARM-System-emulator-1"></a>
+<h3 class="section">4.5 ARM System emulator</h3>
+<a name="index-system-emulation-_0028ARM_0029"></a>
+
+<p>Use the executable <samp>qemu-system-arm</samp> to simulate a ARM
+machine. The ARM Integrator/CP board is emulated with the following
+devices:
+</p>
+<ul class="no-bullet">
+<li>- ARM926E, ARM1026E, ARM946E, ARM1136 or Cortex-A8 CPU
+</li><li>- Two PL011 UARTs
+</li><li>- SMC 91c111 Ethernet adapter
+</li><li>- PL110 LCD controller
+</li><li>- PL050 KMI with PS/2 keyboard and mouse.
+</li><li>- PL181 MultiMedia Card Interface with SD card.
+</li></ul>
+
+<p>The ARM Versatile baseboard is emulated with the following devices:
+</p>
+<ul class="no-bullet">
+<li>- ARM926E, ARM1136 or Cortex-A8 CPU
+</li><li>- PL190 Vectored Interrupt Controller
+</li><li>- Four PL011 UARTs
+</li><li>- SMC 91c111 Ethernet adapter
+</li><li>- PL110 LCD controller
+</li><li>- PL050 KMI with PS/2 keyboard and mouse.
+</li><li>- PCI host bridge.  Note the emulated PCI bridge only provides access to
+PCI memory space.  It does not provide access to PCI IO space.
+This means some devices (eg. ne2k_pci NIC) are not usable, and others
+(eg. rtl8139 NIC) are only usable when the guest drivers use the memory
+mapped control registers.
+</li><li>- PCI OHCI USB controller.
+</li><li>- LSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices.
+</li><li>- PL181 MultiMedia Card Interface with SD card.
+</li></ul>
+
+<p>Several variants of the ARM RealView baseboard are emulated,
+including the EB, PB-A8 and PBX-A9.  Due to interactions with the
+bootloader, only certain Linux kernel configurations work out
+of the box on these boards.
+</p>
+<p>Kernels for the PB-A8 board should have CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+enabled in the kernel, and expect 512M RAM.  Kernels for The PBX-A9 board
+should have CONFIG_SPARSEMEM enabled, CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+disabled and expect 1024M RAM.
+</p>
+<p>The following devices are emulated:
+</p>
+<ul class="no-bullet">
+<li>- ARM926E, ARM1136, ARM11MPCore, Cortex-A8 or Cortex-A9 MPCore CPU
+</li><li>- ARM AMBA Generic/Distributed Interrupt Controller
+</li><li>- Four PL011 UARTs
+</li><li>- SMC 91c111 or SMSC LAN9118 Ethernet adapter
+</li><li>- PL110 LCD controller
+</li><li>- PL050 KMI with PS/2 keyboard and mouse
+</li><li>- PCI host bridge
+</li><li>- PCI OHCI USB controller
+</li><li>- LSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices
+</li><li>- PL181 MultiMedia Card Interface with SD card.
+</li></ul>
+
+<p>The XScale-based clamshell PDA models (&quot;Spitz&quot;, &quot;Akita&quot;, &quot;Borzoi&quot;
+and &quot;Terrier&quot;) emulation includes the following peripherals:
+</p>
+<ul class="no-bullet">
+<li>- Intel PXA270 System-on-chip (ARM V5TE core)
+</li><li>- NAND Flash memory
+</li><li>- IBM/Hitachi DSCM microdrive in a PXA PCMCIA slot - not in &quot;Akita&quot;
+</li><li>- On-chip OHCI USB controller
+</li><li>- On-chip LCD controller
+</li><li>- On-chip Real Time Clock
+</li><li>- TI ADS7846 touchscreen controller on SSP bus
+</li><li>- Maxim MAX1111 analog-digital converter on I<em>^2</em>C bus
+</li><li>- GPIO-connected keyboard controller and LEDs
+</li><li>- Secure Digital card connected to PXA MMC/SD host
+</li><li>- Three on-chip UARTs
+</li><li>- WM8750 audio CODEC on I<em>^2</em>C and I<em>^2</em>S busses
+</li></ul>
+
+<p>The Palm Tungsten|E PDA (codename &quot;Cheetah&quot;) emulation includes the
+following elements:
+</p>
+<ul class="no-bullet">
+<li>- Texas Instruments OMAP310 System-on-chip (ARM 925T core)
+</li><li>- ROM and RAM memories (ROM firmware image can be loaded with -option-rom)
+</li><li>- On-chip LCD controller
+</li><li>- On-chip Real Time Clock
+</li><li>- TI TSC2102i touchscreen controller / analog-digital converter / Audio
+CODEC, connected through MicroWire and I<em>^2</em>S busses
+</li><li>- GPIO-connected matrix keypad
+</li><li>- Secure Digital card connected to OMAP MMC/SD host
+</li><li>- Three on-chip UARTs
+</li></ul>
+
+<p>Nokia N800 and N810 internet tablets (known also as RX-34 and RX-44 / 48)
+emulation supports the following elements:
+</p>
+<ul class="no-bullet">
+<li>- Texas Instruments OMAP2420 System-on-chip (ARM 1136 core)
+</li><li>- RAM and non-volatile OneNAND Flash memories
+</li><li>- Display connected to EPSON remote framebuffer chip and OMAP on-chip
+display controller and a LS041y3 MIPI DBI-C controller
+</li><li>- TI TSC2301 (in N800) and TI TSC2005 (in N810) touchscreen controllers
+driven through SPI bus
+</li><li>- National Semiconductor LM8323-controlled qwerty keyboard driven
+through I<em>^2</em>C bus
+</li><li>- Secure Digital card connected to OMAP MMC/SD host
+</li><li>- Three OMAP on-chip UARTs and on-chip STI debugging console
+</li><li>- A Bluetooth(R) transceiver and HCI connected to an UART
+</li><li>- Mentor Graphics &quot;Inventra&quot; dual-role USB controller embedded in a TI
+TUSB6010 chip - only USB host mode is supported
+</li><li>- TI TMP105 temperature sensor driven through I<em>^2</em>C bus
+</li><li>- TI TWL92230C power management companion with an RTC on I<em>^2</em>C bus
+</li><li>- Nokia RETU and TAHVO multi-purpose chips with an RTC, connected
+through CBUS
+</li></ul>
+
+<p>The Luminary Micro Stellaris LM3S811EVB emulation includes the following
+devices:
+</p>
+<ul class="no-bullet">
+<li>- Cortex-M3 CPU core.
+</li><li>- 64k Flash and 8k SRAM.
+</li><li>- Timers, UARTs, ADC and I<em>^2</em>C interface.
+</li><li>- OSRAM Pictiva 96x16 OLED with SSD0303 controller on I<em>^2</em>C bus.
+</li></ul>
+
+<p>The Luminary Micro Stellaris LM3S6965EVB emulation includes the following
+devices:
+</p>
+<ul class="no-bullet">
+<li>- Cortex-M3 CPU core.
+</li><li>- 256k Flash and 64k SRAM.
+</li><li>- Timers, UARTs, ADC, I<em>^2</em>C and SSI interfaces.
+</li><li>- OSRAM Pictiva 128x64 OLED with SSD0323 controller connected via SSI.
+</li></ul>
+
+<p>The Freecom MusicPal internet radio emulation includes the following
+elements:
+</p>
+<ul class="no-bullet">
+<li>- Marvell MV88W8618 ARM core.
+</li><li>- 32 MB RAM, 256 KB SRAM, 8 MB flash.
+</li><li>- Up to 2 16550 UARTs
+</li><li>- MV88W8xx8 Ethernet controller
+</li><li>- MV88W8618 audio controller, WM8750 CODEC and mixer
+</li><li>- 128×64 display with brightness control
+</li><li>- 2 buttons, 2 navigation wheels with button function
+</li></ul>
+
+<p>The Siemens SX1 models v1 and v2 (default) basic emulation.
+The emulation includes the following elements:
+</p>
+<ul class="no-bullet">
+<li>- Texas Instruments OMAP310 System-on-chip (ARM 925T core)
+</li><li>- ROM and RAM memories (ROM firmware image can be loaded with -pflash)
+V1
+1 Flash of 16MB and 1 Flash of 8MB
+V2
+1 Flash of 32MB
+</li><li>- On-chip LCD controller
+</li><li>- On-chip Real Time Clock
+</li><li>- Secure Digital card connected to OMAP MMC/SD host
+</li><li>- Three on-chip UARTs
+</li></ul>
+
+<p>A Linux 2.6 test image is available on the QEMU web site. More
+information is available in the QEMU mailing-list archive.
+</p>
+
+<p>The following options are specific to the ARM emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-semihosting</samp></dt>
+<dd><p>Enable semihosting syscall emulation.
+</p>
+<p>On ARM this implements the &quot;Angel&quot; interface.
+</p>
+<p>Note that this allows guest direct access to the host filesystem,
+so should only be used with trusted guest OS.
+</p>
+</dd>
+</dl>
+
+<hr>
+<a name="ColdFire-System-emulator"></a>
+<a name="ColdFire-System-emulator-1"></a>
+<h3 class="section">4.6 ColdFire System emulator</h3>
+<a name="index-system-emulation-_0028ColdFire_0029"></a>
+<a name="index-system-emulation-_0028M68K_0029"></a>
+
+<p>Use the executable <samp>qemu-system-m68k</samp> to simulate a ColdFire machine.
+The emulator is able to boot a uClinux kernel.
+</p>
+<p>The M5208EVB emulation includes the following devices:
+</p>
+<ul class="no-bullet">
+<li>- MCF5208 ColdFire V2 Microprocessor (ISA A+ with EMAC).
+</li><li>- Three Two on-chip UARTs.
+</li><li>- Fast Ethernet Controller (FEC)
+</li></ul>
+
+<p>The AN5206 emulation includes the following devices:
+</p>
+<ul class="no-bullet">
+<li>- MCF5206 ColdFire V2 Microprocessor.
+</li><li>- Two on-chip UARTs.
+</li></ul>
+
+
+<p>The following options are specific to the ColdFire emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-semihosting</samp></dt>
+<dd><p>Enable semihosting syscall emulation.
+</p>
+<p>On M68K this implements the &quot;ColdFire GDB&quot; interface used by libgloss.
+</p>
+<p>Note that this allows guest direct access to the host filesystem,
+so should only be used with trusted guest OS.
+</p>
+</dd>
+</dl>
+
+<hr>
+<a name="Cris-System-emulator"></a>
+<a name="Cris-System-emulator-1"></a>
+<h3 class="section">4.7 Cris System emulator</h3>
+<a name="index-system-emulation-_0028Cris_0029"></a>
+
+<p>TODO
+</p>
+<hr>
+<a name="Microblaze-System-emulator"></a>
+<a name="Microblaze-System-emulator-1"></a>
+<h3 class="section">4.8 Microblaze System emulator</h3>
+<a name="index-system-emulation-_0028Microblaze_0029"></a>
+
+<p>TODO
+</p>
+<hr>
+<a name="SH4-System-emulator"></a>
+<a name="SH4-System-emulator-1"></a>
+<h3 class="section">4.9 SH4 System emulator</h3>
+<a name="index-system-emulation-_0028SH4_0029"></a>
+
+<p>TODO
+</p>
+<hr>
+<a name="Xtensa-System-emulator"></a>
+<a name="Xtensa-System-emulator-1"></a>
+<h3 class="section">4.10 Xtensa System emulator</h3>
+<a name="index-system-emulation-_0028Xtensa_0029"></a>
+
+<p>Two executables cover simulation of both Xtensa endian options,
+<samp>qemu-system-xtensa</samp> and <samp>qemu-system-xtensaeb</samp>.
+Two different machine types are emulated:
+</p>
+<ul class="no-bullet">
+<li>- Xtensa emulator pseudo board &quot;sim&quot;
+</li><li>- Avnet LX60/LX110/LX200 board
+</li></ul>
+
+<p>The sim pseudo board emulation provides an environment similar
+to one provided by the proprietary Tensilica ISS.
+It supports:
+</p>
+<ul class="no-bullet">
+<li>- A range of Xtensa CPUs, default is the DC232B
+</li><li>- Console and filesystem access via semihosting calls
+</li></ul>
+
+<p>The Avnet LX60/LX110/LX200 emulation supports:
+</p>
+<ul class="no-bullet">
+<li>- A range of Xtensa CPUs, default is the DC232B
+</li><li>- 16550 UART
+</li><li>- OpenCores 10/100 Mbps Ethernet MAC
+</li></ul>
+
+
+<p>The following options are specific to the Xtensa emulation:
+</p>
+<dl compact="compact">
+<dt><samp>-semihosting</samp></dt>
+<dd><p>Enable semihosting syscall emulation.
+</p>
+<p>Xtensa semihosting provides basic file IO calls, such as open/read/write/seek/select.
+Tensilica baremetal libc for ISS and linux platform &quot;sim&quot; use this interface.
+</p>
+<p>Note that this allows guest direct access to the host filesystem,
+so should only be used with trusted guest OS.
+</p>
+</dd>
+</dl>
+<hr>
+<a name="QEMU-User-space-emulator"></a>
+<a name="QEMU-User-space-emulator-1"></a>
+<h2 class="chapter">5 QEMU User space emulator</h2>
+
+
+<hr>
+<a name="Supported-Operating-Systems"></a>
+<a name="Supported-Operating-Systems-1"></a>
+<h3 class="section">5.1 Supported Operating Systems</h3>
+
+<p>The following OS are supported in user space emulation:
+</p>
+<ul class="no-bullet">
+<li>- Linux (referred as qemu-linux-user)
+</li><li>- BSD (referred as qemu-bsd-user)
+</li></ul>
+
+<hr>
+<a name="Linux-User-space-emulator"></a>
+<a name="Linux-User-space-emulator-1"></a>
+<h3 class="section">5.2 Linux User space emulator</h3>
+
+
+<hr>
+<a name="Quick-Start"></a>
+<a name="Quick-Start-2"></a>
+<h4 class="subsection">5.2.1 Quick Start</h4>
+
+<p>In order to launch a Linux process, QEMU needs the process executable
+itself and all the target (x86) dynamic libraries used by it.
+</p>
+<ul>
+<li> On x86, you can just try to launch any process by using the native
+libraries:
+
+<div class="example">
+<pre class="example">qemu-i386 -L / /bin/ls
+</pre></div>
+
+<p><code>-L /</code> tells that the x86 dynamic linker must be searched with a
+<samp>/</samp> prefix.
+</p>
+</li><li> Since QEMU is also a linux process, you can launch QEMU with
+QEMU (NOTE: you can only do that if you compiled QEMU from the sources):
+
+<div class="example">
+<pre class="example">qemu-i386 -L / qemu-i386 -L / /bin/ls
+</pre></div>
+
+</li><li> On non x86 CPUs, you need first to download at least an x86 glibc
+(<samp>qemu-runtime-i386-XXX-.tar.gz</samp> on the QEMU web page). Ensure that
+<code>LD_LIBRARY_PATH</code> is not set:
+
+<div class="example">
+<pre class="example">unset LD_LIBRARY_PATH
+</pre></div>
+
+<p>Then you can launch the precompiled <samp>ls</samp> x86 executable:
+</p>
+<div class="example">
+<pre class="example">qemu-i386 tests/i386/ls
+</pre></div>
+<p>You can look at <samp>scripts/qemu-binfmt-conf.sh</samp> so that
+QEMU is automatically launched by the Linux kernel when you try to
+launch x86 executables. It requires the <code>binfmt_misc</code> module in the
+Linux kernel.
+</p>
+</li><li> The x86 version of QEMU is also included. You can try weird things such as:
+<div class="example">
+<pre class="example">qemu-i386 /usr/local/qemu-i386/bin/qemu-i386 \
+          /usr/local/qemu-i386/bin/ls-i386
+</pre></div>
+
+</li></ul>
+
+<hr>
+<a name="Wine-launch"></a>
+<a name="Wine-launch-1"></a>
+<h4 class="subsection">5.2.2 Wine launch</h4>
+
+<ul>
+<li> Ensure that you have a working QEMU with the x86 glibc
+distribution (see previous section). In order to verify it, you must be
+able to do:
+
+<div class="example">
+<pre class="example">qemu-i386 /usr/local/qemu-i386/bin/ls-i386
+</pre></div>
+
+</li><li> Download the binary x86 Wine install
+(<samp>qemu-XXX-i386-wine.tar.gz</samp> on the QEMU web page).
+
+</li><li> Configure Wine on your account. Look at the provided script
+<samp>/usr/local/qemu-i386/bin/wine-conf.sh</samp>. Your previous
+<code>${HOME}/.wine</code> directory is saved to <code>${HOME}/.wine.org</code>.
+
+</li><li> Then you can try the example <samp>putty.exe</samp>:
+
+<div class="example">
+<pre class="example">qemu-i386 /usr/local/qemu-i386/wine/bin/wine \
+          /usr/local/qemu-i386/wine/c/Program\ Files/putty.exe
+</pre></div>
+
+</li></ul>
+
+<hr>
+<a name="Command-line-options"></a>
+<a name="Command-line-options-1"></a>
+<h4 class="subsection">5.2.3 Command line options</h4>
+
+<div class="example">
+<pre class="example">usage: qemu-i386 [-h] [-d] [-L path] [-s size] [-cpu model] [-g port] [-B offset] [-R size] program [arguments...]
+</pre></div>
+
+<dl compact="compact">
+<dt><samp>-h</samp></dt>
+<dd><p>Print the help
+</p></dd>
+<dt><samp>-L path</samp></dt>
+<dd><p>Set the x86 elf interpreter prefix (default=/usr/local/qemu-i386)
+</p></dd>
+<dt><samp>-s size</samp></dt>
+<dd><p>Set the x86 stack size in bytes (default=524288)
+</p></dd>
+<dt><samp>-cpu model</samp></dt>
+<dd><p>Select CPU model (-cpu help for list and additional feature selection)
+</p></dd>
+<dt><samp>-E <var>var</var>=<var>value</var></samp></dt>
+<dd><p>Set environment <var>var</var> to <var>value</var>.
+</p></dd>
+<dt><samp>-U <var>var</var></samp></dt>
+<dd><p>Remove <var>var</var> from the environment.
+</p></dd>
+<dt><samp>-B offset</samp></dt>
+<dd><p>Offset guest address by the specified number of bytes.  This is useful when
+the address region required by guest applications is reserved on the host.
+This option is currently only supported on some hosts.
+</p></dd>
+<dt><samp>-R size</samp></dt>
+<dd><p>Pre-allocate a guest virtual address space of the given size (in bytes).
+&quot;G&quot;, &quot;M&quot;, and &quot;k&quot; suffixes may be used when specifying the size.
+</p></dd>
+</dl>
+
+<p>Debug options:
+</p>
+<dl compact="compact">
+<dt><samp>-d item1,...</samp></dt>
+<dd><p>Activate logging of the specified items (use &rsquo;-d help&rsquo; for a list of log items)
+</p></dd>
+<dt><samp>-p pagesize</samp></dt>
+<dd><p>Act as if the host page size was &rsquo;pagesize&rsquo; bytes
+</p></dd>
+<dt><samp>-g port</samp></dt>
+<dd><p>Wait gdb connection to port
+</p></dd>
+<dt><samp>-singlestep</samp></dt>
+<dd><p>Run the emulation in single step mode.
+</p></dd>
+</dl>
+
+<p>Environment variables:
+</p>
+<dl compact="compact">
+<dt><code>QEMU_STRACE</code></dt>
+<dd><p>Print system calls and arguments similar to the &rsquo;strace&rsquo; program
+(NOTE: the actual &rsquo;strace&rsquo; program will not work because the user
+space emulator hasn&rsquo;t implemented ptrace).  At the moment this is
+incomplete.  All system calls that don&rsquo;t have a specific argument
+format are printed with information for six arguments.  Many
+flag-style arguments don&rsquo;t have decoders and will show up as numbers.
+</p></dd>
+</dl>
+
+<hr>
+<a name="Other-binaries"></a>
+<a name="Other-binaries-1"></a>
+<h4 class="subsection">5.2.4 Other binaries</h4>
+
+<a name="index-user-mode-_0028Alpha_0029"></a>
+<p><code>qemu-alpha</code> TODO.
+</p>
+<a name="index-user-mode-_0028ARM_0029"></a>
+<p><code>qemu-armeb</code> TODO.
+</p>
+<a name="index-user-mode-_0028ARM_0029-1"></a>
+<p><code>qemu-arm</code> is also capable of running ARM &quot;Angel&quot; semihosted ELF
+binaries (as implemented by the arm-elf and arm-eabi Newlib/GDB
+configurations), and arm-uclinux bFLT format binaries.
+</p>
+<a name="index-user-mode-_0028ColdFire_0029"></a>
+<a name="index-user-mode-_0028M68K_0029"></a>
+<p><code>qemu-m68k</code> is capable of running semihosted binaries using the BDM
+(m5xxx-ram-hosted.ld) or m68k-sim (sim.ld) syscall interfaces, and
+coldfire uClinux bFLT format binaries.
+</p>
+<p>The binary format is detected automatically.
+</p>
+<a name="index-user-mode-_0028Cris_0029"></a>
+<p><code>qemu-cris</code> TODO.
+</p>
+<a name="index-user-mode-_0028i386_0029"></a>
+<p><code>qemu-i386</code> TODO.
+<code>qemu-x86_64</code> TODO.
+</p>
+<a name="index-user-mode-_0028Microblaze_0029"></a>
+<p><code>qemu-microblaze</code> TODO.
+</p>
+<a name="index-user-mode-_0028MIPS_0029"></a>
+<p><code>qemu-mips</code> TODO.
+<code>qemu-mipsel</code> TODO.
+</p>
+<a name="index-user-mode-_0028PowerPC_0029"></a>
+<p><code>qemu-ppc64abi32</code> TODO.
+<code>qemu-ppc64</code> TODO.
+<code>qemu-ppc</code> TODO.
+</p>
+<a name="index-user-mode-_0028SH4_0029"></a>
+<p><code>qemu-sh4eb</code> TODO.
+<code>qemu-sh4</code> TODO.
+</p>
+<a name="index-user-mode-_0028SPARC_0029"></a>
+<p><code>qemu-sparc</code> can execute Sparc32 binaries (Sparc32 CPU, 32 bit ABI).
+</p>
+<p><code>qemu-sparc32plus</code> can execute Sparc32 and SPARC32PLUS binaries
+(Sparc64 CPU, 32 bit ABI).
+</p>
+<p><code>qemu-sparc64</code> can execute some Sparc64 (Sparc64 CPU, 64 bit ABI) and
+SPARC32PLUS binaries (Sparc64 CPU, 32 bit ABI).
+</p>
+<hr>
+<a name="BSD-User-space-emulator"></a>
+<a name="BSD-User-space-emulator-1"></a>
+<h3 class="section">5.3 BSD User space emulator</h3>
+
+
+<hr>
+<a name="BSD-Status"></a>
+<a name="BSD-Status-1"></a>
+<h4 class="subsection">5.3.1 BSD Status</h4>
+
+<ul class="no-bullet">
+<li>- target Sparc64 on Sparc64: Some trivial programs work.
+</li></ul>
+
+<hr>
+<a name="BSD-Quick-Start"></a>
+<a name="Quick-Start-3"></a>
+<h4 class="subsection">5.3.2 Quick Start</h4>
+
+<p>In order to launch a BSD process, QEMU needs the process executable
+itself and all the target dynamic libraries used by it.
+</p>
+<ul>
+<li> On Sparc64, you can just try to launch any process by using the native
+libraries:
+
+<div class="example">
+<pre class="example">qemu-sparc64 /bin/ls
+</pre></div>
+
+</li></ul>
+
+<hr>
+<a name="BSD-Command-line-options"></a>
+<a name="Command-line-options-2"></a>
+<h4 class="subsection">5.3.3 Command line options</h4>
+
+<div class="example">
+<pre class="example">usage: qemu-sparc64 [-h] [-d] [-L path] [-s size] [-bsd type] program [arguments...]
+</pre></div>
+
+<dl compact="compact">
+<dt><samp>-h</samp></dt>
+<dd><p>Print the help
+</p></dd>
+<dt><samp>-L path</samp></dt>
+<dd><p>Set the library root path (default=/)
+</p></dd>
+<dt><samp>-s size</samp></dt>
+<dd><p>Set the stack size in bytes (default=524288)
+</p></dd>
+<dt><samp>-ignore-environment</samp></dt>
+<dd><p>Start with an empty environment. Without this option,
+the initial environment is a copy of the caller&rsquo;s environment.
+</p></dd>
+<dt><samp>-E <var>var</var>=<var>value</var></samp></dt>
+<dd><p>Set environment <var>var</var> to <var>value</var>.
+</p></dd>
+<dt><samp>-U <var>var</var></samp></dt>
+<dd><p>Remove <var>var</var> from the environment.
+</p></dd>
+<dt><samp>-bsd type</samp></dt>
+<dd><p>Set the type of the emulated BSD Operating system. Valid values are
+FreeBSD, NetBSD and OpenBSD (default).
+</p></dd>
+</dl>
+
+<p>Debug options:
+</p>
+<dl compact="compact">
+<dt><samp>-d item1,...</samp></dt>
+<dd><p>Activate logging of the specified items (use &rsquo;-d help&rsquo; for a list of log items)
+</p></dd>
+<dt><samp>-p pagesize</samp></dt>
+<dd><p>Act as if the host page size was &rsquo;pagesize&rsquo; bytes
+</p></dd>
+<dt><samp>-singlestep</samp></dt>
+<dd><p>Run the emulation in single step mode.
+</p></dd>
+</dl>
+
+<hr>
+<a name="compilation"></a>
+<a name="Compilation-from-the-sources"></a>
+<h2 class="chapter">6 Compilation from the sources</h2>
+
+
+<hr>
+<a name="Linux_002fUnix"></a>
+<a name="Linux_002fUnix-1"></a>
+<h3 class="section">6.1 Linux/Unix</h3>
+
+<a name="Compilation"></a>
+<h4 class="subsection">6.1.1 Compilation</h4>
+
+<p>First you must decompress the sources:
+</p><div class="example">
+<pre class="example">cd /tmp
+tar zxvf qemu-x.y.z.tar.gz
+cd qemu-x.y.z
+</pre></div>
+
+<p>Then you configure QEMU and build it (usually no options are needed):
+</p><div class="example">
+<pre class="example">./configure
+make
+</pre></div>
+
+<p>Then type as root user:
+</p><div class="example">
+<pre class="example">make install
+</pre></div>
+<p>to install QEMU in <samp>/usr/local</samp>.
+</p>
+<hr>
+<a name="Windows"></a>
+<a name="Windows-4"></a>
+<h3 class="section">6.2 Windows</h3>
+
+<ul>
+<li> Install the current versions of MSYS and MinGW from
+<a href="http://www.mingw.org/">http://www.mingw.org/</a>. You can find detailed installation
+instructions in the download section and the FAQ.
+
+</li><li> Download
+the MinGW development library of SDL 1.2.x
+(<samp>SDL-devel-1.2.x-mingw32.tar.gz</samp>) from
+<a href="http://www.libsdl.org">http://www.libsdl.org</a>. Unpack it in a temporary place and
+edit the <samp>sdl-config</samp> script so that it gives the
+correct SDL directory when invoked.
+
+</li><li> Install the MinGW version of zlib and make sure
+<samp>zlib.h</samp> and <samp>libz.dll.a</samp> are in
+MinGW&rsquo;s default header and linker search paths.
+
+</li><li> Extract the current version of QEMU.
+
+</li><li> Start the MSYS shell (file <samp>msys.bat</samp>).
+
+</li><li> Change to the QEMU directory. Launch <samp>./configure</samp> and
+<samp>make</samp>.  If you have problems using SDL, verify that
+<samp>sdl-config</samp> can be launched from the MSYS command line.
+
+</li><li> You can install QEMU in <samp>Program Files/QEMU</samp> by typing
+<samp>make install</samp>. Don&rsquo;t forget to copy <samp>SDL.dll</samp> in
+<samp>Program Files/QEMU</samp>.
+
+</li></ul>
+
+<hr>
+<a name="Cross-compilation-for-Windows-with-Linux"></a>
+<a name="Cross-compilation-for-Windows-with-Linux-1"></a>
+<h3 class="section">6.3 Cross compilation for Windows with Linux</h3>
+
+<ul>
+<li> Install the MinGW cross compilation tools available at
+<a href="http://www.mingw.org/">http://www.mingw.org/</a>.
+
+</li><li> Download
+the MinGW development library of SDL 1.2.x
+(<samp>SDL-devel-1.2.x-mingw32.tar.gz</samp>) from
+<a href="http://www.libsdl.org">http://www.libsdl.org</a>. Unpack it in a temporary place and
+edit the <samp>sdl-config</samp> script so that it gives the
+correct SDL directory when invoked.  Set up the <code>PATH</code> environment
+variable so that <samp>sdl-config</samp> can be launched by
+the QEMU configuration script.
+
+</li><li> Install the MinGW version of zlib and make sure
+<samp>zlib.h</samp> and <samp>libz.dll.a</samp> are in
+MinGW&rsquo;s default header and linker search paths.
+
+</li><li> Configure QEMU for Windows cross compilation:
+<div class="example">
+<pre class="example">PATH=/usr/i686-pc-mingw32/sys-root/mingw/bin:$PATH ./configure --cross-prefix='i686-pc-mingw32-'
+</pre></div>
+<p>The example assumes <samp>sdl-config</samp> is installed under <samp>/usr/i686-pc-mingw32/sys-root/mingw/bin</samp> and
+MinGW cross compilation tools have names like <samp>i686-pc-mingw32-gcc</samp> and <samp>i686-pc-mingw32-strip</samp>.
+We set the <code>PATH</code> environment variable to ensure the MinGW version of <samp>sdl-config</samp> is used and
+use &ndash;cross-prefix to specify the name of the cross compiler.
+You can also use &ndash;prefix to set the Win32 install path which defaults to <samp>c:/Program Files/QEMU</samp>.
+</p>
+<p>Under Fedora Linux, you can run:
+</p><div class="example">
+<pre class="example">yum -y install mingw32-gcc mingw32-SDL mingw32-zlib
+</pre></div>
+<p>to get a suitable cross compilation environment.
+</p>
+</li><li> You can install QEMU in the installation directory by typing
+<code>make install</code>. Don&rsquo;t forget to copy <samp>SDL.dll</samp> and <samp>zlib1.dll</samp> into the
+installation directory.
+
+</li></ul>
+
+<p>Wine can be used to launch the resulting qemu-system-i386.exe
+and all other qemu-system-<var>target</var>.exe compiled for Win32.
+</p>
+<hr>
+<a name="Mac-OS-X"></a>
+<a name="Mac-OS-X-3"></a>
+<h3 class="section">6.4 Mac OS X</h3>
+
+<p>The Mac OS X patches are not fully merged in QEMU, so you should look
+at the QEMU mailing list archive to have all the necessary
+information.
+</p>
+<hr>
+<a name="Make-targets"></a>
+<a name="Make-targets-1"></a>
+<h3 class="section">6.5 Make targets</h3>
+
+<dl compact="compact">
+<dt><code>make</code></dt>
+<dt><code>make all</code></dt>
+<dd><p>Make everything which is typically needed.
+</p>
+</dd>
+<dt><code>install</code></dt>
+<dd><p>TODO
+</p>
+</dd>
+<dt><code>install-doc</code></dt>
+<dd><p>TODO
+</p>
+</dd>
+<dt><code>make clean</code></dt>
+<dd><p>Remove most files which were built during make.
+</p>
+</dd>
+<dt><code>make distclean</code></dt>
+<dd><p>Remove everything which was built during make.
+</p>
+</dd>
+<dt><code>make dvi</code></dt>
+<dt><code>make html</code></dt>
+<dt><code>make info</code></dt>
+<dt><code>make pdf</code></dt>
+<dd><p>Create documentation in dvi, html, info or pdf format.
+</p>
+</dd>
+<dt><code>make cscope</code></dt>
+<dd><p>TODO
+</p>
+</dd>
+<dt><code>make defconfig</code></dt>
+<dd><p>(Re-)create some build configuration files.
+User made changes will be overwritten.
+</p>
+</dd>
+<dt><code>tar</code></dt>
+<dt><code>tarbin</code></dt>
+<dd><p>TODO
+</p>
+</dd>
+</dl>
+
+<hr>
+<a name="License"></a>
+<a name="License-1"></a>
+<h2 class="appendix">Appendix A License</h2>
+
+<p>QEMU is a trademark of Fabrice Bellard.
+</p>
+<p>QEMU is released under the GNU General Public License (TODO: add link).
+Parts of QEMU have specific licenses, see file LICENSE.
+</p>
+<p>TODO (refer to file LICENSE, include it, include the GPL?)
+</p>
+<hr>
+<a name="Index"></a>
+<a name="Index-1"></a>
+<h2 class="appendix">Appendix B Index</h2>
+
+<hr>
+<a name="Concept-Index"></a>
+<a name="Concept-Index-1"></a>
+<h3 class="section">B.1 Concept Index</h3>
+<p>This is the main index. Should we combine all keywords in one index? TODO
+</p><table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
+ &nbsp; 
+</td></tr></table>
+<table class="index-cp" border="0">
+<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-E">E</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-emulated-target-systems">emulated target systems</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-I">I</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-installation-_0028Linux_0029">installation (Linux)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#install_005flinux">install_linux</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-installation-_0028Windows_0029">installation (Windows)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#install_005fwindows">install_windows</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-O">O</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-operating-modes">operating modes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-Q">Q</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-QEMU-monitor">QEMU monitor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-quick-start">quick start</a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fquickstart">pcsys_quickstart</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-S">S</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-supported-target-systems">supported target systems</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-supported-user-mode-targets">supported user mode targets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation">system emulation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028ARM_0029">system emulation (ARM)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#ARM-System-emulator">ARM System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028ColdFire_0029">system emulation (ColdFire)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#ColdFire-System-emulator">ColdFire System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028Cris_0029">system emulation (Cris)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cris-System-emulator">Cris System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028M68K_0029">system emulation (M68K)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#ColdFire-System-emulator">ColdFire System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028Microblaze_0029">system emulation (Microblaze)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Microblaze-System-emulator">Microblaze System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028MIPS_0029">system emulation (MIPS)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MIPS-System-emulator">MIPS System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028PC_0029">system emulation (PC)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#QEMU-PC-System-emulator">QEMU PC System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028PowerPC_0029">system emulation (PowerPC)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#PowerPC-System-emulator">PowerPC System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028SH4_0029">system emulation (SH4)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#SH4-System-emulator">SH4 System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028Sparc32_0029">system emulation (Sparc32)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sparc32-System-emulator">Sparc32 System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028Sparc64_0029">system emulation (Sparc64)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sparc64-System-emulator">Sparc64 System emulator</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system-emulation-_0028Xtensa_0029">system emulation (Xtensa)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Xtensa-System-emulator">Xtensa System emulator</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Concept-Index_cp_letter-U">U</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028Alpha_0029">user mode (Alpha)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028ARM_0029">user mode (ARM)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028ARM_0029-1">user mode (ARM)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028ColdFire_0029">user mode (ColdFire)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028Cris_0029">user mode (Cris)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028i386_0029">user mode (i386)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028M68K_0029">user mode (M68K)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028Microblaze_0029">user mode (Microblaze)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028MIPS_0029">user mode (MIPS)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028PowerPC_0029">user mode (PowerPC)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028SH4_0029">user mode (SH4)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-_0028SPARC_0029">user mode (SPARC)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-binaries">Other binaries</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-user-mode-emulation">user mode emulation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#intro_005ffeatures">intro_features</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+</table>
+<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
+ &nbsp; 
+</td></tr></table>
+
+<hr>
+<a name="Function-Index"></a>
+<a name="Function-Index-1"></a>
+<h3 class="section">B.2 Function Index</h3>
+<p>This index could be used for command line options and monitor functions.
+</p><table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_symbol-1"><b>-</b></a>
+ &nbsp; 
+<br>
+<a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-H"><b>H</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-I"><b>I</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-L"><b>L</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-N"><b>N</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-O"><b>O</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-R"><b>R</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-W"><b>W</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-X"><b>X</b></a>
+ &nbsp; 
+</td></tr></table>
+<table class="index-fn" border="0">
+<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_symbol-1">-</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dacpitable"><code>-acpitable</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dadd_002dfd"><code>-add-fd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dalt_002dgrab"><code>-alt-grab</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dappend"><code>-append</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002daudio_002dhelp"><code>-audio-help</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dballoon"><code>-balloon</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dbios"><code>-bios</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dboot"><code>-boot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dbt"><code>-bt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dcdrom"><code>-cdrom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dchardev"><code>-chardev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dchroot"><code>-chroot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dcpu"><code>-cpu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dctrl_002dgrab"><code>-ctrl-grab</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dcurses"><code>-curses</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dd"><code>-d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dD"><code>-D</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddaemonize"><code>-daemonize</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddebugcon"><code>-debugcon</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddevice"><code>-device</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddisplay"><code>-display</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddrive"><code>-drive</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddtb"><code>-dtb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ddump_002dvmstate"><code>-dump-vmstate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dechr"><code>-echr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002denable_002dfips"><code>-enable-fips</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002denable_002dkvm"><code>-enable-kvm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dfda"><code>-fda</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dfdb"><code>-fdb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dfsdev"><code>-fsdev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dfull_002dscreen"><code>-full-screen</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dg"><code>-g</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dgdb"><code>-gdb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dglobal"><code>-global</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dh"><code>-h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dhda"><code>-hda</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dhdachs"><code>-hdachs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dhdb"><code>-hdb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dhdc"><code>-hdc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dhdd"><code>-hdd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dicount"><code>-icount</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dincoming"><code>-incoming</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dinitrd"><code>-initrd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dk"><code>-k</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dkernel"><code>-kernel</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dL"><code>-L</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dloadvm"><code>-loadvm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dm"><code>-m</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmachine"><code>-machine</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmem_002dpath"><code>-mem-path</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmem_002dprealloc"><code>-mem-prealloc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmon"><code>-mon</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmonitor"><code>-monitor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmsg"><code>-msg</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dmtdblock"><code>-mtdblock</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dname"><code>-name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnet"><code>-net</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnetdev"><code>-netdev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dacpi"><code>-no-acpi</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dfd_002dbootchk"><code>-no-fd-bootchk</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dframe"><code>-no-frame</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dhpet"><code>-no-hpet</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dquit"><code>-no-quit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dreboot"><code>-no-reboot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002dshutdown"><code>-no-shutdown</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dno_002duser_002dconfig"><code>-no-user-config</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnodefaults"><code>-nodefaults</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnodefconfig"><code>-nodefconfig</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnographic"><code>-nographic</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dnuma"><code>-numa</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dobject"><code>-object</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dold_002dparam-_0028ARM_0029"><code>-old-param (ARM)</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002doption_002drom"><code>-option-rom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dparallel"><code>-parallel</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dpflash"><code>-pflash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dpidfile"><code>-pidfile</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dportrait"><code>-portrait</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dprom_002denv"><code>-prom-env</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dqmp"><code>-qmp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dqmp_002dpretty"><code>-qmp-pretty</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dreadconfig"><code>-readconfig</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002drealtime"><code>-realtime</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002drotate"><code>-rotate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002drtc"><code>-rtc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002drunas"><code>-runas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dS"><code>-S</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002ds"><code>-s</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsandbox"><code>-sandbox</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsd"><code>-sd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsdl"><code>-sdl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsemihosting"><code>-semihosting</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsemihosting_002dconfig"><code>-semihosting-config</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dserial"><code>-serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dset"><code>-set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dshow_002dcursor"><code>-show-cursor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsinglestep"><code>-singlestep</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsmbios"><code>-smbios</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsmp"><code>-smp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsnapshot"><code>-snapshot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dsoundhw"><code>-soundhw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dspice"><code>-spice</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dtb_002dsize"><code>-tb-size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dtpmdev"><code>-tpmdev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dtrace"><code>-trace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dusb"><code>-usb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dusbdevice"><code>-usbdevice</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002duuid"><code>-uuid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dversion"><code>-version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dvga"><code>-vga</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dvirtfs"><code>-virtfs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dvirtfs_005fsynth"><code>-virtfs_synth</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dvirtioconsole"><code>-virtioconsole</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dvnc"><code>-vnc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dwatchdog"><code>-watchdog</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dwatchdog_002daction"><code>-watchdog-action</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dwin2k_002dhack"><code>-win2k-hack</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dwriteconfig"><code>-writeconfig</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dxen_002dattach"><code>-xen-attach</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dxen_002dcreate"><code>-xen-create</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-_002dxen_002ddomid"><code>-xen-domid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#sec_005finvocation">sec_invocation</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-A">A</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-acl_005fadd"><code>acl_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-acl_005fpolicy"><code>acl_policy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-acl_005fremove"><code>acl_remove</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-acl_005freset"><code>acl_reset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-acl_005fshow"><code>acl_show</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-B">B</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-balloon"><code>balloon</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fjob_005fcancel"><code>block_job_cancel</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fjob_005fcomplete"><code>block_job_complete</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fjob_005fpause"><code>block_job_pause</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fjob_005fresume"><code>block_job_resume</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fjob_005fset_005fspeed"><code>block_job_set_speed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fpasswd"><code>block_passwd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fresize"><code>block_resize</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fset_005fio_005fthrottle"><code>block_set_io_throttle</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-block_005fstream"><code>block_stream</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-boot_005fset"><code>boot_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-C">C</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-change"><code>change</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-chardev_002dadd"><code>chardev-add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-chardev_002dremove"><code>chardev-remove</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-client_005fmigrate_005finfo"><code>client_migrate_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-closefd"><code>closefd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-commit"><code>commit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-cont"><code>cont</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-cpu"><code>cpu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-cpu_002dadd"><code>cpu-add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-D">D</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-delvm"><code>delvm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-device_005fadd"><code>device_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-device_005fdel"><code>device_del</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-drive_005fadd"><code>drive_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-drive_005fbackup"><code>drive_backup</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-drive_005fdel"><code>drive_del</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-drive_005fmirror"><code>drive_mirror</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-dump_002dguest_002dmemory"><code>dump-guest-memory</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-E">E</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-eject"><code>eject</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-expire_005fpassword"><code>expire_password</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-G">G</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-gdbserver"><code>gdbserver</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-getfd"><code>getfd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-H">H</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-help"><code>help</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-hostfwd_005fadd"><code>hostfwd_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-hostfwd_005fremove"><code>hostfwd_remove</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-host_005fnet_005fadd"><code>host_net_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-host_005fnet_005fremove"><code>host_net_remove</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-I">I</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-i"><code>i</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-info"><code>info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-L">L</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-loadvm"><code>loadvm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-log"><code>log</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-logfile"><code>logfile</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-M">M</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-mce-_0028x86_0029"><code>mce (x86)</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-memsave"><code>memsave</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate"><code>migrate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fcancel"><code>migrate_cancel</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fincoming"><code>migrate_incoming</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fset_005fcache_005fsize"><code>migrate_set_cache_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fset_005fcapability"><code>migrate_set_capability</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fset_005fdowntime"><code>migrate_set_downtime</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-migrate_005fset_005fspeed"><code>migrate_set_speed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-mouse_005fbutton"><code>mouse_button</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-mouse_005fmove"><code>mouse_move</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-mouse_005fset"><code>mouse_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-N">N</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-nbd_005fserver_005fadd"><code>nbd_server_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-nbd_005fserver_005fstart"><code>nbd_server_start</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-nbd_005fserver_005fstop"><code>nbd_server_stop</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-netdev_005fadd"><code>netdev_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-netdev_005fdel"><code>netdev_del</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-nmi"><code>nmi</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-O">O</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-o"><code>o</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-object_005fadd"><code>object_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-object_005fdel"><code>object_del</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-P">P</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-pcie_005faer_005finject_005ferror"><code>pcie_aer_inject_error</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-pmemsave"><code>pmemsave</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-print"><code>print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-Q">Q</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-qemu_002dio"><code>qemu-io</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-quit"><code>quit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-R">R</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-ringbuf_005fread"><code>ringbuf_read</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-ringbuf_005fwrite"><code>ringbuf_write</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-S">S</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-savevm"><code>savevm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-screendump"><code>screendump</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-sendkey"><code>sendkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-set_005flink"><code>set_link</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-set_005fpassword"><code>set_password</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-singlestep"><code>singlestep</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-snapshot_005fblkdev"><code>snapshot_blkdev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-snapshot_005fblkdev_005finternal"><code>snapshot_blkdev_internal</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-snapshot_005fdelete_005fblkdev_005finternal"><code>snapshot_delete_blkdev_internal</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-stop"><code>stop</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-stopcapture"><code>stopcapture</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-sum"><code>sum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system_005fpowerdown"><code>system_powerdown</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system_005freset"><code>system_reset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-system_005fwakeup"><code>system_wakeup</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-T">T</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-trace_002devent"><code>trace-event</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-trace_002dfile"><code>trace-file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-U">U</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-usb_005fadd"><code>usb_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-usb_005fdel"><code>usb_del</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-W">W</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-watchdog_005faction"><code>watchdog_action</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-wavcapture"><code>wavcapture</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Function-Index_fn_letter-X">X</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-x"><code>x</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-xp"><code>xp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fmonitor">pcsys_monitor</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+</table>
+<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_symbol-1"><b>-</b></a>
+ &nbsp; 
+<br>
+<a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-H"><b>H</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-I"><b>I</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-L"><b>L</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-N"><b>N</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-O"><b>O</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-R"><b>R</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-W"><b>W</b></a>
+ &nbsp; 
+<a class="summary-letter" href="#Function-Index_fn_letter-X"><b>X</b></a>
+ &nbsp; 
+</td></tr></table>
+
+<hr>
+<a name="Keystroke-Index"></a>
+<a name="Keystroke-Index-1"></a>
+<h3 class="section">B.3 Keystroke Index</h3>
+
+<p>This is a list of all keystrokes which have a special function
+in system emulation.
+</p>
+<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Keystroke-Index_ky_letter-C"><b>C</b></a>
+ &nbsp; 
+</td></tr></table>
+<table class="index-ky" border="0">
+<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th><a name="Keystroke-Index_ky_letter-C">C</a></th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-_003f"><code>Ctrl-a ?</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-a"><code>Ctrl-a a</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-b"><code>Ctrl-a b</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-c"><code>Ctrl-a c</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-h"><code>Ctrl-a h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-h-1"><code>Ctrl-a h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-s"><code>Ctrl-a s</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-t"><code>Ctrl-a t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002da-x"><code>Ctrl-a x</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt"><code>Ctrl-Alt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt_002d_002b"><code>Ctrl-Alt-+</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt_002d_002d"><code>Ctrl-Alt--</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt_002df"><code>Ctrl-Alt-f</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt_002dn"><code>Ctrl-Alt-n</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dAlt_002du"><code>Ctrl-Alt-u</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dDown"><code>Ctrl-Down</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dPageDown"><code>Ctrl-PageDown</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dPageUp"><code>Ctrl-PageUp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-Ctrl_002dUp"><code>Ctrl-Up</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pcsys_005fkeys">pcsys_keys</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+</table>
+<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Keystroke-Index_ky_letter-C"><b>C</b></a>
+ &nbsp; 
+</td></tr></table>
+
+<hr>
+<a name="Program-Index"></a>
+<a name="Program-Index-1"></a>
+<h3 class="section">B.4 Program Index</h3>
+
+<hr>
+<a name="Data-Type-Index"></a>
+<a name="Data-Type-Index-1"></a>
+<h3 class="section">B.5 Data Type Index</h3>
+
+<p>This index could be used for qdev device names and options.
+</p>
+
+<hr>
+<a name="Variable-Index"></a>
+<a name="Variable-Index-1"></a>
+<h3 class="section">B.6 Variable Index</h3>
+
+<hr>
+
+
+
+</body>
+</html>
diff --git a/qemu/share/doc/qemu/qemu-tech.html b/qemu/share/doc/qemu/qemu-tech.html
new file mode 100644
index 0000000..65b6f2c
--- /dev/null
+++ b/qemu/share/doc/qemu/qemu-tech.html
@@ -0,0 +1,802 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
+<head>
+<title>QEMU Internals</title>
+
+<meta name="description" content="QEMU Internals">
+<meta name="keywords" content="QEMU Internals">
+<meta name="resource-type" content="document">
+<meta name="distribution" content="global">
+<meta name="Generator" content="makeinfo">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<link href="#Top" rel="start" title="Top">
+<link href="#Index" rel="index" title="Index">
+<link href="#SEC_Contents" rel="contents" title="Table of Contents">
+<link href="dir.html#Top" rel="up" title="(dir)">
+<style type="text/css">
+<!--
+a.summary-letter {text-decoration: none}
+blockquote.indentedblock {margin-right: 0em}
+blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
+blockquote.smallquotation {font-size: smaller}
+div.display {margin-left: 3.2em}
+div.example {margin-left: 3.2em}
+div.lisp {margin-left: 3.2em}
+div.smalldisplay {margin-left: 3.2em}
+div.smallexample {margin-left: 3.2em}
+div.smalllisp {margin-left: 3.2em}
+kbd {font-style: oblique}
+pre.display {font-family: inherit}
+pre.format {font-family: inherit}
+pre.menu-comment {font-family: serif}
+pre.menu-preformatted {font-family: serif}
+pre.smalldisplay {font-family: inherit; font-size: smaller}
+pre.smallexample {font-size: smaller}
+pre.smallformat {font-family: inherit; font-size: smaller}
+pre.smalllisp {font-size: smaller}
+span.nolinebreak {white-space: nowrap}
+span.roman {font-family: initial; font-weight: normal}
+span.sansserif {font-family: sans-serif; font-weight: normal}
+ul.no-bullet {list-style: none}
+-->
+</style>
+
+
+</head>
+
+<body lang="en">
+<h1 class="settitle" align="center">QEMU Internals</h1>
+
+
+
+
+
+<a name="Top"></a>
+<a name="SEC_Top"></a>
+
+
+<a name="SEC_Contents"></a>
+<h2 class="contents-heading">Table of Contents</h2>
+
+<div class="contents">
+
+<ul class="no-bullet">
+  <li><a name="toc-Introduction-1" href="#Introduction">1 Introduction</a>
+  <ul class="no-bullet">
+    <li><a name="toc-Features" href="#intro_005ffeatures">1.1 Features</a></li>
+    <li><a name="toc-x86-and-x86_002d64-emulation" href="#intro_005fx86_005femulation">1.2 x86 and x86-64 emulation</a></li>
+    <li><a name="toc-ARM-emulation" href="#intro_005farm_005femulation">1.3 ARM emulation</a></li>
+    <li><a name="toc-MIPS-emulation" href="#intro_005fmips_005femulation">1.4 MIPS emulation</a></li>
+    <li><a name="toc-PowerPC-emulation" href="#intro_005fppc_005femulation">1.5 PowerPC emulation</a></li>
+    <li><a name="toc-Sparc32-and-Sparc64-emulation" href="#intro_005fsparc_005femulation">1.6 Sparc32 and Sparc64 emulation</a></li>
+    <li><a name="toc-Xtensa-emulation" href="#intro_005fxtensa_005femulation">1.7 Xtensa emulation</a></li>
+    <li><a name="toc-Other-CPU-emulation" href="#intro_005fother_005femulation">1.8 Other CPU emulation</a></li>
+  </ul></li>
+  <li><a name="toc-QEMU-Internals-1" href="#QEMU-Internals">2 QEMU Internals</a>
+  <ul class="no-bullet">
+    <li><a name="toc-QEMU-compared-to-other-emulators-1" href="#QEMU-compared-to-other-emulators">2.1 QEMU compared to other emulators</a></li>
+    <li><a name="toc-Portable-dynamic-translation-1" href="#Portable-dynamic-translation">2.2 Portable dynamic translation</a></li>
+    <li><a name="toc-Condition-code-optimisations-1" href="#Condition-code-optimisations">2.3 Condition code optimisations</a></li>
+    <li><a name="toc-CPU-state-optimisations-1" href="#CPU-state-optimisations">2.4 CPU state optimisations</a></li>
+    <li><a name="toc-Translation-cache-1" href="#Translation-cache">2.5 Translation cache</a></li>
+    <li><a name="toc-Direct-block-chaining-1" href="#Direct-block-chaining">2.6 Direct block chaining</a></li>
+    <li><a name="toc-Self_002dmodifying-code-and-translated-code-invalidation-1" href="#Self_002dmodifying-code-and-translated-code-invalidation">2.7 Self-modifying code and translated code invalidation</a></li>
+    <li><a name="toc-Exception-support-1" href="#Exception-support">2.8 Exception support</a></li>
+    <li><a name="toc-MMU-emulation-1" href="#MMU-emulation">2.9 MMU emulation</a></li>
+    <li><a name="toc-Device-emulation-1" href="#Device-emulation">2.10 Device emulation</a></li>
+    <li><a name="toc-Hardware-interrupts-1" href="#Hardware-interrupts">2.11 Hardware interrupts</a></li>
+    <li><a name="toc-User-emulation-specific-details-1" href="#User-emulation-specific-details">2.12 User emulation specific details</a>
+    <ul class="no-bullet">
+      <li><a name="toc-Linux-system-call-translation" href="#Linux-system-call-translation">2.12.1 Linux system call translation</a></li>
+      <li><a name="toc-Linux-signals" href="#Linux-signals">2.12.2 Linux signals</a></li>
+      <li><a name="toc-clone_0028_0029-system-call-and-threads" href="#clone_0028_0029-system-call-and-threads">2.12.3 clone() system call and threads</a></li>
+      <li><a name="toc-Self_002dvirtualization" href="#Self_002dvirtualization">2.12.4 Self-virtualization</a></li>
+    </ul></li>
+    <li><a name="toc-Bibliography-1" href="#Bibliography">2.13 Bibliography</a></li>
+  </ul></li>
+  <li><a name="toc-Regression-Tests-1" href="#Regression-Tests">3 Regression Tests</a>
+  <ul class="no-bullet">
+    <li><a name="toc-test_002di386-1" href="#test_002di386">3.1 <samp>test-i386</samp></a></li>
+    <li><a name="toc-linux_002dtest-1" href="#linux_002dtest">3.2 <samp>linux-test</samp></a></li>
+  </ul></li>
+  <li><a name="toc-Index-1" href="#Index">4 Index</a></li>
+</ul>
+</div>
+
+
+<hr>
+<a name="Introduction"></a>
+<a name="Introduction-1"></a>
+<h2 class="chapter">1 Introduction</h2>
+
+
+<hr>
+<a name="intro_005ffeatures"></a>
+<a name="Features"></a>
+<h3 class="section">1.1 Features</h3>
+
+<p>QEMU is a FAST! processor emulator using a portable dynamic
+translator.
+</p>
+<p>QEMU has two operating modes:
+</p>
+<ul class="no-bullet">
+<li>- Full system emulation. In this mode (full platform virtualization),
+QEMU emulates a full system (usually a PC), including a processor and
+various peripherals. It can be used to launch several different
+Operating Systems at once without rebooting the host machine or to
+debug system code.
+
+</li><li>- User mode emulation. In this mode (application level virtualization),
+QEMU can launch processes compiled for one CPU on another CPU, however
+the Operating Systems must match. This can be used for example to ease
+cross-compilation and cross-debugging.
+</li></ul>
+
+<p>As QEMU requires no host kernel driver to run, it is very safe and
+easy to use.
+</p>
+<p>QEMU generic features:
+</p>
+<ul>
+<li> User space only or full system emulation.
+
+</li><li> Using dynamic translation to native code for reasonable speed.
+
+</li><li> Working on x86, x86_64 and PowerPC32/64 hosts. Being tested on ARM,
+HPPA, Sparc32 and Sparc64. Previous versions had some support for
+Alpha and S390 hosts, but TCG (see below) doesn&rsquo;t support those yet.
+
+</li><li> Self-modifying code support.
+
+</li><li> Precise exceptions support.
+
+</li><li> Floating point library supporting both full software emulation and
+native host FPU instructions.
+
+</li></ul>
+
+<p>QEMU user mode emulation features:
+</p><ul>
+<li> Generic Linux system call converter, including most ioctls.
+
+</li><li> clone() emulation using native CPU clone() to use Linux scheduler for threads.
+
+</li><li> Accurate signal handling by remapping host signals to target signals.
+</li></ul>
+
+<p>Linux user emulator (Linux host only) can be used to launch the Wine
+Windows API emulator (<a href="http://www.winehq.org">http://www.winehq.org</a>). A BSD user emulator for BSD
+hosts is under development. It would also be possible to develop a
+similar user emulator for Solaris.
+</p>
+<p>QEMU full system emulation features:
+</p><ul>
+<li> QEMU uses a full software MMU for maximum portability.
+
+</li><li> QEMU can optionally use an in-kernel accelerator, like kvm. The accelerators 
+execute some of the guest code natively, while
+continuing to emulate the rest of the machine.
+
+</li><li> Various hardware devices can be emulated and in some cases, host
+devices (e.g. serial and parallel ports, USB, drives) can be used
+transparently by the guest Operating System. Host device passthrough
+can be used for talking to external physical peripherals (e.g. a
+webcam, modem or tape drive).
+
+</li><li> Symmetric multiprocessing (SMP) even on a host with a single CPU. On a
+SMP host system, QEMU can use only one CPU fully due to difficulty in
+implementing atomic memory accesses efficiently.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fx86_005femulation"></a>
+<a name="x86-and-x86_002d64-emulation"></a>
+<h3 class="section">1.2 x86 and x86-64 emulation</h3>
+
+<p>QEMU x86 target features:
+</p>
+<ul>
+<li> The virtual x86 CPU supports 16 bit and 32 bit addressing with segmentation.
+LDT/GDT and IDT are emulated. VM86 mode is also supported to run
+DOSEMU. There is some support for MMX/3DNow!, SSE, SSE2, SSE3, SSSE3,
+and SSE4 as well as x86-64 SVM.
+
+</li><li> Support of host page sizes bigger than 4KB in user mode emulation.
+
+</li><li> QEMU can emulate itself on x86.
+
+</li><li> An extensive Linux x86 CPU test program is included <samp>tests/test-i386</samp>.
+It can be used to test other x86 virtual CPUs.
+
+</li></ul>
+
+<p>Current QEMU limitations:
+</p>
+<ul>
+<li> Limited x86-64 support.
+
+</li><li> IPC syscalls are missing.
+
+</li><li> The x86 segment limits and access rights are not tested at every
+memory access (yet). Hopefully, very few OSes seem to rely on that for
+normal use.
+
+</li></ul>
+
+<hr>
+<a name="intro_005farm_005femulation"></a>
+<a name="ARM-emulation"></a>
+<h3 class="section">1.3 ARM emulation</h3>
+
+<ul>
+<li> Full ARM 7 user emulation.
+
+</li><li> NWFPE FPU support included in user Linux emulation.
+
+</li><li> Can run most ARM Linux binaries.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fmips_005femulation"></a>
+<a name="MIPS-emulation"></a>
+<h3 class="section">1.4 MIPS emulation</h3>
+
+<ul>
+<li> The system emulation allows full MIPS32/MIPS64 Release 2 emulation,
+including privileged instructions, FPU and MMU, in both little and big
+endian modes.
+
+</li><li> The Linux userland emulation can run many 32 bit MIPS Linux binaries.
+
+</li></ul>
+
+<p>Current QEMU limitations:
+</p>
+<ul>
+<li> Self-modifying code is not always handled correctly.
+
+</li><li> 64 bit userland emulation is not implemented.
+
+</li><li> The system emulation is not complete enough to run real firmware.
+
+</li><li> The watchpoint debug facility is not implemented.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fppc_005femulation"></a>
+<a name="PowerPC-emulation"></a>
+<h3 class="section">1.5 PowerPC emulation</h3>
+
+<ul>
+<li> Full PowerPC 32 bit emulation, including privileged instructions,
+FPU and MMU.
+
+</li><li> Can run most PowerPC Linux binaries.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fsparc_005femulation"></a>
+<a name="Sparc32-and-Sparc64-emulation"></a>
+<h3 class="section">1.6 Sparc32 and Sparc64 emulation</h3>
+
+<ul>
+<li> Full SPARC V8 emulation, including privileged
+instructions, FPU and MMU. SPARC V9 emulation includes most privileged
+and VIS instructions, FPU and I/D MMU. Alignment is fully enforced.
+
+</li><li> Can run most 32-bit SPARC Linux binaries, SPARC32PLUS Linux binaries and
+some 64-bit SPARC Linux binaries.
+
+</li></ul>
+
+<p>Current QEMU limitations:
+</p>
+<ul>
+<li> IPC syscalls are missing.
+
+</li><li> Floating point exception support is buggy.
+
+</li><li> Atomic instructions are not correctly implemented.
+
+</li><li> There are still some problems with Sparc64 emulators.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fxtensa_005femulation"></a>
+<a name="Xtensa-emulation"></a>
+<h3 class="section">1.7 Xtensa emulation</h3>
+
+<ul>
+<li> Core Xtensa ISA emulation, including most options: code density,
+loop, extended L32R, 16- and 32-bit multiplication, 32-bit division,
+MAC16, miscellaneous operations, boolean, FP coprocessor, coprocessor
+context, debug, multiprocessor synchronization,
+conditional store, exceptions, relocatable vectors, unaligned exception,
+interrupts (including high priority and timer), hardware alignment,
+region protection, region translation, MMU, windowed registers, thread
+pointer, processor ID.
+
+</li><li> Not implemented options: data/instruction cache (including cache
+prefetch and locking), XLMI, processor interface. Also options not
+covered by the core ISA (e.g. FLIX, wide branches) are not implemented.
+
+</li><li> Can run most Xtensa Linux binaries.
+
+</li><li> New core configuration that requires no additional instructions
+may be created from overlay with minimal amount of hand-written code.
+
+</li></ul>
+
+<hr>
+<a name="intro_005fother_005femulation"></a>
+<a name="Other-CPU-emulation"></a>
+<h3 class="section">1.8 Other CPU emulation</h3>
+
+<p>In addition to the above, QEMU supports emulation of other CPUs with
+varying levels of success. These are:
+</p>
+<ul>
+<li> Alpha
+</li><li> CRIS
+</li><li> M68k
+</li><li> SH4
+</li></ul>
+
+<hr>
+<a name="QEMU-Internals"></a>
+<a name="QEMU-Internals-1"></a>
+<h2 class="chapter">2 QEMU Internals</h2>
+
+
+<hr>
+<a name="QEMU-compared-to-other-emulators"></a>
+<a name="QEMU-compared-to-other-emulators-1"></a>
+<h3 class="section">2.1 QEMU compared to other emulators</h3>
+
+<p>Like bochs [3], QEMU emulates an x86 CPU. But QEMU is much faster than
+bochs as it uses dynamic compilation. Bochs is closely tied to x86 PC
+emulation while QEMU can emulate several processors.
+</p>
+<p>Like Valgrind [2], QEMU does user space emulation and dynamic
+translation. Valgrind is mainly a memory debugger while QEMU has no
+support for it (QEMU could be used to detect out of bound memory
+accesses as Valgrind, but it has no support to track uninitialised data
+as Valgrind does). The Valgrind dynamic translator generates better code
+than QEMU (in particular it does register allocation) but it is closely
+tied to an x86 host and target and has no support for precise exceptions
+and system emulation.
+</p>
+<p>EM86 [4] is the closest project to user space QEMU (and QEMU still uses
+some of its code, in particular the ELF file loader). EM86 was limited
+to an alpha host and used a proprietary and slow interpreter (the
+interpreter part of the FX!32 Digital Win32 code translator [5]).
+</p>
+<p>TWIN [6] is a Windows API emulator like Wine. It is less accurate than
+Wine but includes a protected mode x86 interpreter to launch x86 Windows
+executables. Such an approach has greater potential because most of the
+Windows API is executed natively but it is far more difficult to develop
+because all the data structures and function parameters exchanged
+between the API and the x86 code must be converted.
+</p>
+<p>User mode Linux [7] was the only solution before QEMU to launch a
+Linux kernel as a process while not needing any host kernel
+patches. However, user mode Linux requires heavy kernel patches while
+QEMU accepts unpatched Linux kernels. The price to pay is that QEMU is
+slower.
+</p>
+<p>The Plex86 [8] PC virtualizer is done in the same spirit as the now
+obsolete qemu-fast system emulator. It requires a patched Linux kernel
+to work (you cannot launch the same kernel on your PC), but the
+patches are really small. As it is a PC virtualizer (no emulation is
+done except for some privileged instructions), it has the potential of
+being faster than QEMU. The downside is that a complicated (and
+potentially unsafe) host kernel patch is needed.
+</p>
+<p>The commercial PC Virtualizers (VMWare [9], VirtualPC [10], TwoOStwo
+[11]) are faster than QEMU, but they all need specific, proprietary
+and potentially unsafe host drivers. Moreover, they are unable to
+provide cycle exact simulation as an emulator can.
+</p>
+<p>VirtualBox [12], Xen [13] and KVM [14] are based on QEMU. QEMU-SystemC
+[15] uses QEMU to simulate a system where some hardware devices are
+developed in SystemC.
+</p>
+<hr>
+<a name="Portable-dynamic-translation"></a>
+<a name="Portable-dynamic-translation-1"></a>
+<h3 class="section">2.2 Portable dynamic translation</h3>
+
+<p>QEMU is a dynamic translator. When it first encounters a piece of code,
+it converts it to the host instruction set. Usually dynamic translators
+are very complicated and highly CPU dependent. QEMU uses some tricks
+which make it relatively easily portable and simple while achieving good
+performances.
+</p>
+<p>After the release of version 0.9.1, QEMU switched to a new method of
+generating code, Tiny Code Generator or TCG. TCG relaxes the
+dependency on the exact version of the compiler used. The basic idea
+is to split every target instruction into a couple of RISC-like TCG
+ops (see <code>target-i386/translate.c</code>). Some optimizations can be
+performed at this stage, including liveness analysis and trivial
+constant expression evaluation. TCG ops are then implemented in the
+host CPU back end, also known as TCG target (see
+<code>tcg/i386/tcg-target.c</code>). For more information, please take a
+look at <code>tcg/README</code>.
+</p>
+<hr>
+<a name="Condition-code-optimisations"></a>
+<a name="Condition-code-optimisations-1"></a>
+<h3 class="section">2.3 Condition code optimisations</h3>
+
+<p>Lazy evaluation of CPU condition codes (<code>EFLAGS</code> register on x86)
+is important for CPUs where every instruction sets the condition
+codes. It tends to be less important on conventional RISC systems
+where condition codes are only updated when explicitly requested. On
+Sparc64, costly update of both 32 and 64 bit condition codes can be
+avoided with lazy evaluation.
+</p>
+<p>Instead of computing the condition codes after each x86 instruction,
+QEMU just stores one operand (called <code>CC_SRC</code>), the result
+(called <code>CC_DST</code>) and the type of operation (called
+<code>CC_OP</code>). When the condition codes are needed, the condition
+codes can be calculated using this information. In addition, an
+optimized calculation can be performed for some instruction types like
+conditional branches.
+</p>
+<p><code>CC_OP</code> is almost never explicitly set in the generated code
+because it is known at translation time.
+</p>
+<p>The lazy condition code evaluation is used on x86, m68k, cris and
+Sparc. ARM uses a simplified variant for the N and Z flags.
+</p>
+<hr>
+<a name="CPU-state-optimisations"></a>
+<a name="CPU-state-optimisations-1"></a>
+<h3 class="section">2.4 CPU state optimisations</h3>
+
+<p>The target CPUs have many internal states which change the way it
+evaluates instructions. In order to achieve a good speed, the
+translation phase considers that some state information of the virtual
+CPU cannot change in it. The state is recorded in the Translation
+Block (TB). If the state changes (e.g. privilege level), a new TB will
+be generated and the previous TB won&rsquo;t be used anymore until the state
+matches the state recorded in the previous TB. For example, if the SS,
+DS and ES segments have a zero base, then the translator does not even
+generate an addition for the segment base.
+</p>
+<p>[The FPU stack pointer register is not handled that way yet].
+</p>
+<hr>
+<a name="Translation-cache"></a>
+<a name="Translation-cache-1"></a>
+<h3 class="section">2.5 Translation cache</h3>
+
+<p>A 32 MByte cache holds the most recently used translations. For
+simplicity, it is completely flushed when it is full. A translation unit
+contains just a single basic block (a block of x86 instructions
+terminated by a jump or by a virtual CPU state change which the
+translator cannot deduce statically).
+</p>
+<hr>
+<a name="Direct-block-chaining"></a>
+<a name="Direct-block-chaining-1"></a>
+<h3 class="section">2.6 Direct block chaining</h3>
+
+<p>After each translated basic block is executed, QEMU uses the simulated
+Program Counter (PC) and other cpu state informations (such as the CS
+segment base value) to find the next basic block.
+</p>
+<p>In order to accelerate the most common cases where the new simulated PC
+is known, QEMU can patch a basic block so that it jumps directly to the
+next one.
+</p>
+<p>The most portable code uses an indirect jump. An indirect jump makes
+it easier to make the jump target modification atomic. On some host
+architectures (such as x86 or PowerPC), the <code>JUMP</code> opcode is
+directly patched so that the block chaining has no overhead.
+</p>
+<hr>
+<a name="Self_002dmodifying-code-and-translated-code-invalidation"></a>
+<a name="Self_002dmodifying-code-and-translated-code-invalidation-1"></a>
+<h3 class="section">2.7 Self-modifying code and translated code invalidation</h3>
+
+<p>Self-modifying code is a special challenge in x86 emulation because no
+instruction cache invalidation is signaled by the application when code
+is modified.
+</p>
+<p>When translated code is generated for a basic block, the corresponding
+host page is write protected if it is not already read-only. Then, if
+a write access is done to the page, Linux raises a SEGV signal. QEMU
+then invalidates all the translated code in the page and enables write
+accesses to the page.
+</p>
+<p>Correct translated code invalidation is done efficiently by maintaining
+a linked list of every translated block contained in a given page. Other
+linked lists are also maintained to undo direct block chaining.
+</p>
+<p>On RISC targets, correctly written software uses memory barriers and
+cache flushes, so some of the protection above would not be
+necessary. However, QEMU still requires that the generated code always
+matches the target instructions in memory in order to handle
+exceptions correctly.
+</p>
+<hr>
+<a name="Exception-support"></a>
+<a name="Exception-support-1"></a>
+<h3 class="section">2.8 Exception support</h3>
+
+<p>longjmp() is used when an exception such as division by zero is
+encountered.
+</p>
+<p>The host SIGSEGV and SIGBUS signal handlers are used to get invalid
+memory accesses. The simulated program counter is found by
+retranslating the corresponding basic block and by looking where the
+host program counter was at the exception point.
+</p>
+<p>The virtual CPU cannot retrieve the exact <code>EFLAGS</code> register because
+in some cases it is not computed because of condition code
+optimisations. It is not a big concern because the emulated code can
+still be restarted in any cases.
+</p>
+<hr>
+<a name="MMU-emulation"></a>
+<a name="MMU-emulation-1"></a>
+<h3 class="section">2.9 MMU emulation</h3>
+
+<p>For system emulation QEMU supports a soft MMU. In that mode, the MMU
+virtual to physical address translation is done at every memory
+access. QEMU uses an address translation cache to speed up the
+translation.
+</p>
+<p>In order to avoid flushing the translated code each time the MMU
+mappings change, QEMU uses a physically indexed translation cache. It
+means that each basic block is indexed with its physical address.
+</p>
+<p>When MMU mappings change, only the chaining of the basic blocks is
+reset (i.e. a basic block can no longer jump directly to another one).
+</p>
+<hr>
+<a name="Device-emulation"></a>
+<a name="Device-emulation-1"></a>
+<h3 class="section">2.10 Device emulation</h3>
+
+<p>Systems emulated by QEMU are organized by boards. At initialization
+phase, each board instantiates a number of CPUs, devices, RAM and
+ROM. Each device in turn can assign I/O ports or memory areas (for
+MMIO) to its handlers. When the emulation starts, an access to the
+ports or MMIO memory areas assigned to the device causes the
+corresponding handler to be called.
+</p>
+<p>RAM and ROM are handled more optimally, only the offset to the host
+memory needs to be added to the guest address.
+</p>
+<p>The video RAM of VGA and other display cards is special: it can be
+read or written directly like RAM, but write accesses cause the memory
+to be marked with VGA_DIRTY flag as well.
+</p>
+<p>QEMU supports some device classes like serial and parallel ports, USB,
+drives and network devices, by providing APIs for easier connection to
+the generic, higher level implementations. The API hides the
+implementation details from the devices, like native device use or
+advanced block device formats like QCOW.
+</p>
+<p>Usually the devices implement a reset method and register support for
+saving and loading of the device state. The devices can also use
+timers, especially together with the use of bottom halves (BHs).
+</p>
+<hr>
+<a name="Hardware-interrupts"></a>
+<a name="Hardware-interrupts-1"></a>
+<h3 class="section">2.11 Hardware interrupts</h3>
+
+<p>In order to be faster, QEMU does not check at every basic block if a
+hardware interrupt is pending. Instead, the user must asynchronously
+call a specific function to tell that an interrupt is pending. This
+function resets the chaining of the currently executing basic
+block. It ensures that the execution will return soon in the main loop
+of the CPU emulator. Then the main loop can test if the interrupt is
+pending and handle it.
+</p>
+<hr>
+<a name="User-emulation-specific-details"></a>
+<a name="User-emulation-specific-details-1"></a>
+<h3 class="section">2.12 User emulation specific details</h3>
+
+<a name="Linux-system-call-translation"></a>
+<h4 class="subsection">2.12.1 Linux system call translation</h4>
+
+<p>QEMU includes a generic system call translator for Linux. It means that
+the parameters of the system calls can be converted to fix the
+endianness and 32/64 bit issues. The IOCTLs are converted with a generic
+type description system (see <samp>ioctls.h</samp> and <samp>thunk.c</samp>).
+</p>
+<p>QEMU supports host CPUs which have pages bigger than 4KB. It records all
+the mappings the process does and try to emulated the <code>mmap()</code>
+system calls in cases where the host <code>mmap()</code> call would fail
+because of bad page alignment.
+</p>
+<a name="Linux-signals"></a>
+<h4 class="subsection">2.12.2 Linux signals</h4>
+
+<p>Normal and real-time signals are queued along with their information
+(<code>siginfo_t</code>) as it is done in the Linux kernel. Then an interrupt
+request is done to the virtual CPU. When it is interrupted, one queued
+signal is handled by generating a stack frame in the virtual CPU as the
+Linux kernel does. The <code>sigreturn()</code> system call is emulated to return
+from the virtual signal handler.
+</p>
+<p>Some signals (such as SIGALRM) directly come from the host. Other
+signals are synthesized from the virtual CPU exceptions such as SIGFPE
+when a division by zero is done (see <code>main.c:cpu_loop()</code>).
+</p>
+<p>The blocked signal mask is still handled by the host Linux kernel so
+that most signal system calls can be redirected directly to the host
+Linux kernel. Only the <code>sigaction()</code> and <code>sigreturn()</code> system
+calls need to be fully emulated (see <samp>signal.c</samp>).
+</p>
+<a name="clone_0028_0029-system-call-and-threads"></a>
+<h4 class="subsection">2.12.3 clone() system call and threads</h4>
+
+<p>The Linux clone() system call is usually used to create a thread. QEMU
+uses the host clone() system call so that real host threads are created
+for each emulated thread. One virtual CPU instance is created for each
+thread.
+</p>
+<p>The virtual x86 CPU atomic operations are emulated with a global lock so
+that their semantic is preserved.
+</p>
+<p>Note that currently there are still some locking issues in QEMU. In
+particular, the translated cache flush is not protected yet against
+reentrancy.
+</p>
+<a name="Self_002dvirtualization"></a>
+<h4 class="subsection">2.12.4 Self-virtualization</h4>
+
+<p>QEMU was conceived so that ultimately it can emulate itself. Although
+it is not very useful, it is an important test to show the power of the
+emulator.
+</p>
+<p>Achieving self-virtualization is not easy because there may be address
+space conflicts. QEMU user emulators solve this problem by being an
+executable ELF shared object as the ld-linux.so ELF interpreter. That
+way, it can be relocated at load time.
+</p>
+<hr>
+<a name="Bibliography"></a>
+<a name="Bibliography-1"></a>
+<h3 class="section">2.13 Bibliography</h3>
+
+<dl compact="compact">
+<dt>[1]</dt>
+<dd><p><a href="http://citeseer.nj.nec.com/piumarta98optimizing.html">http://citeseer.nj.nec.com/piumarta98optimizing.html</a>, Optimizing
+direct threaded code by selective inlining (1998) by Ian Piumarta, Fabio
+Riccardi.
+</p>
+</dd>
+<dt>[2]</dt>
+<dd><p><a href="http://developer.kde.org/~sewardj/">http://developer.kde.org/~sewardj/</a>, Valgrind, an open-source
+memory debugger for x86-GNU/Linux, by Julian Seward.
+</p>
+</dd>
+<dt>[3]</dt>
+<dd><p><a href="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a>, the Bochs IA-32 Emulator Project,
+by Kevin Lawton et al.
+</p>
+</dd>
+<dt>[4]</dt>
+<dd><p><a href="http://www.cs.rose-hulman.edu/~donaldlf/em86/index.html">http://www.cs.rose-hulman.edu/~donaldlf/em86/index.html</a>, the EM86
+x86 emulator on Alpha-Linux.
+</p>
+</dd>
+<dt>[5]</dt>
+<dd><p><a href="http://www.usenix.org/publications/library/proceedings/usenix-nt97/full_papers/chernoff/chernoff.pdf">http://www.usenix.org/publications/library/proceedings/usenix-nt97/full_papers/chernoff/chernoff.pdf</a>,
+DIGITAL FX!32: Running 32-Bit x86 Applications on Alpha NT, by Anton
+Chernoff and Ray Hookway.
+</p>
+</dd>
+<dt>[6]</dt>
+<dd><p><a href="http://www.willows.com/">http://www.willows.com/</a>, Windows API library emulation from
+Willows Software.
+</p>
+</dd>
+<dt>[7]</dt>
+<dd><p><a href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a>,
+The User-mode Linux Kernel.
+</p>
+</dd>
+<dt>[8]</dt>
+<dd><p><a href="http://www.plex86.org/">http://www.plex86.org/</a>,
+The new Plex86 project.
+</p>
+</dd>
+<dt>[9]</dt>
+<dd><p><a href="http://www.vmware.com/">http://www.vmware.com/</a>,
+The VMWare PC virtualizer.
+</p>
+</dd>
+<dt>[10]</dt>
+<dd><p><a href="http://www.microsoft.com/windowsxp/virtualpc/">http://www.microsoft.com/windowsxp/virtualpc/</a>,
+The VirtualPC PC virtualizer.
+</p>
+</dd>
+<dt>[11]</dt>
+<dd><p><a href="http://www.twoostwo.org/">http://www.twoostwo.org/</a>,
+The TwoOStwo PC virtualizer.
+</p>
+</dd>
+<dt>[12]</dt>
+<dd><p><a href="http://virtualbox.org/">http://virtualbox.org/</a>,
+The VirtualBox PC virtualizer.
+</p>
+</dd>
+<dt>[13]</dt>
+<dd><p><a href="http://www.xen.org/">http://www.xen.org/</a>,
+The Xen hypervisor.
+</p>
+</dd>
+<dt>[14]</dt>
+<dd><p><a href="http://kvm.qumranet.com/kvmwiki/Front_Page">http://kvm.qumranet.com/kvmwiki/Front_Page</a>,
+Kernel Based Virtual Machine (KVM).
+</p>
+</dd>
+<dt>[15]</dt>
+<dd><p><a href="http://www.greensocs.com/projects/QEMUSystemC">http://www.greensocs.com/projects/QEMUSystemC</a>,
+QEMU-SystemC, a hardware co-simulator.
+</p>
+</dd>
+</dl>
+
+<hr>
+<a name="Regression-Tests"></a>
+<a name="Regression-Tests-1"></a>
+<h2 class="chapter">3 Regression Tests</h2>
+
+<p>In the directory <samp>tests/</samp>, various interesting testing programs
+are available. They are used for regression testing.
+</p>
+
+<hr>
+<a name="test_002di386"></a>
+<a name="test_002di386-1"></a>
+<h3 class="section">3.1 <samp>test-i386</samp></h3>
+
+<p>This program executes most of the 16 bit and 32 bit x86 instructions and
+generates a text output. It can be compared with the output obtained with
+a real CPU or another emulator. The target <code>make test</code> runs this
+program and a <code>diff</code> on the generated output.
+</p>
+<p>The Linux system call <code>modify_ldt()</code> is used to create x86 selectors
+to test some 16 bit addressing and 32 bit with segmentation cases.
+</p>
+<p>The Linux system call <code>vm86()</code> is used to test vm86 emulation.
+</p>
+<p>Various exceptions are raised to test most of the x86 user space
+exception reporting.
+</p>
+<hr>
+<a name="linux_002dtest"></a>
+<a name="linux_002dtest-1"></a>
+<h3 class="section">3.2 <samp>linux-test</samp></h3>
+
+<p>This program tests various Linux system calls. It is used to verify
+that the system call parameters are correctly converted between target
+and host CPUs.
+</p>
+<hr>
+<a name="Index"></a>
+<a name="Index-1"></a>
+<h2 class="chapter">4 Index</h2>
+
+<hr>
+
+
+
+</body>
+</html>
diff --git a/qemu/share/doc/qemu/qmp-commands.txt b/qemu/share/doc/qemu/qmp-commands.txt
new file mode 100644
index 0000000..88cb0e6
--- /dev/null
+++ b/qemu/share/doc/qemu/qmp-commands.txt
@@ -0,0 +1,2965 @@
+                        QMP Supported Commands
+                        ----------------------
+
+This document describes all commands currently supported by QMP.
+
+Most of the time their usage is exactly the same as in the user Monitor, this
+means that any other document which also describe commands (the manpage,
+QEMU's manual, etc) can and should be consulted.
+
+QMP has two types of commands: regular and query commands. Regular commands
+usually change the Virtual Machine's state someway, while query commands just
+return information. The sections below are divided accordingly.
+
+It's important to observe that all communication examples are formatted in
+a reader-friendly way, so that they're easier to understand. However, in real
+protocol usage, they're emitted as a single line.
+
+Also, the following notation is used to denote data flow:
+
+-> data issued by the Client
+<- Server data response
+
+Please, refer to the QMP specification (QMP/qmp-spec.txt) for detailed
+information on the Server command and response formats.
+
+NOTE: This document is temporary and will be replaced soon.
+
+1. Stability Considerations
+===========================
+
+The current QMP command set (described in this file) may be useful for a
+number of use cases, however it's limited and several commands have bad
+defined semantics, specially with regard to command completion.
+
+These problems are going to be solved incrementally in the next QEMU releases
+and we're going to establish a deprecation policy for badly defined commands.
+
+If you're planning to adopt QMP, please observe the following:
+
+    1. The deprecation policy will take effect and be documented soon, please
+       check the documentation of each used command as soon as a new release of
+       QEMU is available
+
+    2. DO NOT rely on anything which is not explicit documented
+
+    3. Errors, in special, are not documented. Applications should NOT check
+       for specific errors classes or data (it's strongly recommended to only
+       check for the "error" key)
+
+2. Regular Commands
+===================
+
+Server's responses in the examples below are always a success response, please
+refer to the QMP specification for more details on error responses.
+
+quit
+----
+
+Quit the emulator.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "quit" }
+<- { "return": {} }
+
+eject
+-----
+
+Eject a removable medium.
+
+Arguments: 
+
+- force: force ejection (json-bool, optional)
+- device: device name (json-string)
+
+Example:
+
+-> { "execute": "eject", "arguments": { "device": "ide1-cd0" } }
+<- { "return": {} }
+
+Note: The "force" argument defaults to false.
+
+change
+------
+
+Change a removable medium or VNC configuration.
+
+Arguments:
+
+- "device": device name (json-string)
+- "target": filename or item (json-string)
+- "arg": additional argument (json-string, optional)
+
+Examples:
+
+1. Change a removable medium
+
+-> { "execute": "change",
+             "arguments": { "device": "ide1-cd0",
+                            "target": "/srv/images/Fedora-12-x86_64-DVD.iso" } }
+<- { "return": {} }
+
+2. Change VNC password
+
+-> { "execute": "change",
+             "arguments": { "device": "vnc", "target": "password",
+                            "arg": "foobar1" } }
+<- { "return": {} }
+
+screendump
+----------
+
+Save screen into PPM image.
+
+Arguments:
+
+- "filename": file path (json-string)
+
+Example:
+
+-> { "execute": "screendump", "arguments": { "filename": "/tmp/image" } }
+<- { "return": {} }
+
+stop
+----
+
+Stop the emulator.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "stop" }
+<- { "return": {} }
+
+cont
+----
+
+Resume emulation.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "cont" }
+<- { "return": {} }
+
+system_wakeup
+-------------
+
+Wakeup guest from suspend.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "system_wakeup" }
+<- { "return": {} }
+
+system_reset
+------------
+
+Reset the system.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "system_reset" }
+<- { "return": {} }
+
+system_powerdown
+----------------
+
+Send system power down event.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "system_powerdown" }
+<- { "return": {} }
+
+device_add
+----------
+
+Add a device.
+
+Arguments:
+
+- "driver": the name of the new device's driver (json-string)
+- "bus": the device's parent bus (device tree path, json-string, optional)
+- "id": the device's ID, must be unique (json-string)
+- device properties
+
+Example:
+
+-> { "execute": "device_add", "arguments": { "driver": "e1000", "id": "net1" } }
+<- { "return": {} }
+
+Notes:
+
+(1) For detailed information about this command, please refer to the
+    'docs/qdev-device-use.txt' file.
+
+(2) It's possible to list device properties by running QEMU with the
+    "-device DEVICE,\?" command-line argument, where DEVICE is the device's name
+
+device_del
+----------
+
+Remove a device.
+
+Arguments:
+
+- "id": the device's ID (json-string)
+
+Example:
+
+-> { "execute": "device_del", "arguments": { "id": "net1" } }
+<- { "return": {} }
+
+send-key
+----------
+
+Send keys to VM.
+
+Arguments:
+
+keys array:
+    - "key": key sequence (a json-array of key union values,
+             union can be number or qcode enum)
+
+- hold-time: time to delay key up events, milliseconds. Defaults to 100
+             (json-int, optional)
+
+Example:
+
+-> { "execute": "send-key",
+     "arguments": { "keys": [ { "type": "qcode", "data": "ctrl" },
+                              { "type": "qcode", "data": "alt" },
+                              { "type": "qcode", "data": "delete" } ] } }
+<- { "return": {} }
+
+cpu
+---
+
+Set the default CPU.
+
+Arguments:
+
+- "index": the CPU's index (json-int)
+
+Example:
+
+-> { "execute": "cpu", "arguments": { "index": 0 } }
+<- { "return": {} }
+
+Note: CPUs' indexes are obtained with the 'query-cpus' command.
+
+cpu-add
+-------
+
+Adds virtual cpu
+
+Arguments:
+
+- "id": cpu id (json-int)
+
+Example:
+
+-> { "execute": "cpu-add", "arguments": { "id": 2 } }
+<- { "return": {} }
+
+memsave
+-------
+
+Save to disk virtual memory dump starting at 'val' of size 'size'.
+
+Arguments:
+
+- "val": the starting address (json-int)
+- "size": the memory size, in bytes (json-int)
+- "filename": file path (json-string)
+- "cpu": virtual CPU index (json-int, optional)
+
+Example:
+
+-> { "execute": "memsave",
+             "arguments": { "val": 10,
+                            "size": 100,
+                            "filename": "/tmp/virtual-mem-dump" } }
+<- { "return": {} }
+
+pmemsave
+--------
+
+Save to disk physical memory dump starting at 'val' of size 'size'.
+
+Arguments:
+
+- "val": the starting address (json-int)
+- "size": the memory size, in bytes (json-int)
+- "filename": file path (json-string)
+
+Example:
+
+-> { "execute": "pmemsave",
+             "arguments": { "val": 10,
+                            "size": 100,
+                            "filename": "/tmp/physical-mem-dump" } }
+<- { "return": {} }
+
+inject-nmi
+----------
+
+Inject an NMI on the default CPU (x86/s390) or all CPUs (ppc64).
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "inject-nmi" }
+<- { "return": {} }
+
+Note: inject-nmi fails when the guest doesn't support injecting.
+
+ringbuf-write
+-------------
+
+Write to a ring buffer character device.
+
+Arguments:
+
+- "device": ring buffer character device name (json-string)
+- "data": data to write (json-string)
+- "format": data format (json-string, optional)
+          - Possible values: "utf8" (default), "base64"
+            Bug: invalid base64 is currently not rejected.
+            Whitespace *is* invalid.
+
+Example:
+
+-> { "execute": "ringbuf-write",
+                "arguments": { "device": "foo",
+                               "data": "abcdefgh",
+                               "format": "utf8" } }
+<- { "return": {} }
+
+ringbuf-read
+-------------
+
+Read from a ring buffer character device.
+
+Arguments:
+
+- "device": ring buffer character device name (json-string)
+- "size": how many bytes to read at most (json-int)
+          - Number of data bytes, not number of characters in encoded data
+- "format": data format (json-string, optional)
+          - Possible values: "utf8" (default), "base64"
+          - Naturally, format "utf8" works only when the ring buffer
+            contains valid UTF-8 text.  Invalid UTF-8 sequences get
+            replaced.  Bug: replacement doesn't work.  Bug: can screw
+            up on encountering NUL characters, after the ring buffer
+            lost data, and when reading stops because the size limit
+            is reached.
+
+Example:
+
+-> { "execute": "ringbuf-read",
+                "arguments": { "device": "foo",
+                               "size": 1000,
+                               "format": "utf8" } }
+<- {"return": "abcdefgh"}
+
+xen-save-devices-state
+-------
+
+Save the state of all devices to file. The RAM and the block devices
+of the VM are not saved by this command.
+
+Arguments:
+
+- "filename": the file to save the state of the devices to as binary
+data. See xen-save-devices-state.txt for a description of the binary
+format.
+
+Example:
+
+-> { "execute": "xen-save-devices-state",
+     "arguments": { "filename": "/tmp/save" } }
+<- { "return": {} }
+
+xen-set-global-dirty-log
+-------
+
+Enable or disable the global dirty log mode.
+
+Arguments:
+
+- "enable": Enable it or disable it.
+
+Example:
+
+-> { "execute": "xen-set-global-dirty-log",
+     "arguments": { "enable": true } }
+<- { "return": {} }
+
+migrate
+-------
+
+Migrate to URI.
+
+Arguments:
+
+- "blk": block migration, full disk copy (json-bool, optional)
+- "inc": incremental disk copy (json-bool, optional)
+- "uri": Destination URI (json-string)
+
+Example:
+
+-> { "execute": "migrate", "arguments": { "uri": "tcp:0:4446" } }
+<- { "return": {} }
+
+Notes:
+
+(1) The 'query-migrate' command should be used to check migration's progress
+    and final result (this information is provided by the 'status' member)
+(2) All boolean arguments default to false
+(3) The user Monitor's "detach" argument is invalid in QMP and should not
+    be used
+
+migrate_cancel
+--------------
+
+Cancel the current migration.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "migrate_cancel" }
+<- { "return": {} }
+
+migrate-incoming
+----------------
+
+Continue an incoming migration
+
+Arguments:
+
+- "uri": Source/listening URI (json-string)
+
+Example:
+
+-> { "execute": "migrate-incoming", "arguments": { "uri": "tcp::4446" } }
+<- { "return": {} }
+
+Notes:
+
+(1) QEMU must be started with -incoming defer to allow migrate-incoming to
+    be used
+(2) The uri format is the same as to -incoming
+
+migrate-set-cache-size
+----------------------
+
+Set cache size to be used by XBZRLE migration, the cache size will be rounded
+down to the nearest power of 2
+
+Arguments:
+
+- "value": cache size in bytes (json-int)
+
+Example:
+
+-> { "execute": "migrate-set-cache-size", "arguments": { "value": 536870912 } }
+<- { "return": {} }
+
+query-migrate-cache-size
+------------------------
+
+Show cache size to be used by XBZRLE migration
+
+returns a json-object with the following information:
+- "size" : json-int
+
+Example:
+
+-> { "execute": "query-migrate-cache-size" }
+<- { "return": 67108864 }
+
+migrate_set_speed
+-----------------
+
+Set maximum speed for migrations.
+
+Arguments:
+
+- "value": maximum speed, in bytes per second (json-int)
+
+Example:
+
+-> { "execute": "migrate_set_speed", "arguments": { "value": 1024 } }
+<- { "return": {} }
+
+migrate_set_downtime
+--------------------
+
+Set maximum tolerated downtime (in seconds) for migrations.
+
+Arguments:
+
+- "value": maximum downtime (json-number)
+
+Example:
+
+-> { "execute": "migrate_set_downtime", "arguments": { "value": 0.1 } }
+<- { "return": {} }
+
+client_migrate_info
+------------------
+
+Set the spice/vnc connection info for the migration target.  The spice/vnc
+server will ask the spice/vnc client to automatically reconnect using the
+new parameters (if specified) once the vm migration finished successfully.
+
+Arguments:
+
+- "protocol":     protocol: "spice" or "vnc" (json-string)
+- "hostname":     migration target hostname (json-string)
+- "port":         spice/vnc tcp port for plaintext channels (json-int, optional)
+- "tls-port":     spice tcp port for tls-secured channels (json-int, optional)
+- "cert-subject": server certificate subject (json-string, optional)
+
+Example:
+
+-> { "execute": "client_migrate_info",
+     "arguments": { "protocol": "spice",
+                    "hostname": "virt42.lab.kraxel.org",
+                    "port": 1234 } }
+<- { "return": {} }
+
+dump
+
+
+Dump guest memory to file. The file can be processed with crash or gdb.
+
+Arguments:
+
+- "paging": do paging to get guest's memory mapping (json-bool)
+- "protocol": destination file(started with "file:") or destination file
+              descriptor (started with "fd:") (json-string)
+- "begin": the starting physical address. It's optional, and should be specified
+           with length together (json-int)
+- "length": the memory size, in bytes. It's optional, and should be specified
+            with begin together (json-int)
+- "format": the format of guest memory dump. It's optional, and can be
+            elf|kdump-zlib|kdump-lzo|kdump-snappy, but non-elf formats will
+            conflict with paging and filter, ie. begin and length (json-string)
+
+Example:
+
+-> { "execute": "dump-guest-memory", "arguments": { "protocol": "fd:dump" } }
+<- { "return": {} }
+
+Notes:
+
+(1) All boolean arguments default to false
+
+query-dump-guest-memory-capability
+----------
+
+Show available formats for 'dump-guest-memory'
+
+Example:
+
+-> { "execute": "query-dump-guest-memory-capability" }
+<- { "return": { "formats":
+                    ["elf", "kdump-zlib", "kdump-lzo", "kdump-snappy"] }
+
+netdev_add
+----------
+
+Add host network device.
+
+Arguments:
+
+- "type": the device type, "tap", "user", ... (json-string)
+- "id": the device's ID, must be unique (json-string)
+- device options
+
+Example:
+
+-> { "execute": "netdev_add", "arguments": { "type": "user", "id": "netdev1" } }
+<- { "return": {} }
+
+Note: The supported device options are the same ones supported by the '-netdev'
+      command-line argument, which are listed in the '-help' output or QEMU's
+      manual
+
+netdev_del
+----------
+
+Remove host network device.
+
+Arguments:
+
+- "id": the device's ID, must be unique (json-string)
+
+Example:
+
+-> { "execute": "netdev_del", "arguments": { "id": "netdev1" } }
+<- { "return": {} }
+
+
+object-add
+----------
+
+Create QOM object.
+
+Arguments:
+
+- "qom-type": the object's QOM type, i.e. the class name (json-string)
+- "id": the object's ID, must be unique (json-string)
+- "props": a dictionary of object property values (optional, json-dict)
+
+Example:
+
+-> { "execute": "object-add", "arguments": { "qom-type": "rng-random", "id": "rng1",
+     "props": { "filename": "/dev/hwrng" } } }
+<- { "return": {} }
+
+object-del
+----------
+
+Remove QOM object.
+
+Arguments:
+
+- "id": the object's ID (json-string)
+
+Example:
+
+-> { "execute": "object-del", "arguments": { "id": "rng1" } }
+<- { "return": {} }
+
+
+block_resize
+------------
+
+Resize a block image while a guest is running.
+
+Arguments:
+
+- "device": the device's ID, must be unique (json-string)
+- "node-name": the node name in the block driver state graph (json-string)
+- "size": new size
+
+Example:
+
+-> { "execute": "block_resize", "arguments": { "device": "scratch", "size": 1073741824 } }
+<- { "return": {} }
+
+block-commit
+------------
+
+Live commit of data from overlay image nodes into backing nodes - i.e., writes
+data between 'top' and 'base' into 'base'.
+
+Arguments:
+
+- "device": The device's ID, must be unique (json-string)
+- "base": The file name of the backing image to write data into.
+          If not specified, this is the deepest backing image
+          (json-string, optional)
+- "top":  The file name of the backing image within the image chain,
+          which contains the topmost data to be committed down. If
+          not specified, this is the active layer. (json-string, optional)
+
+- backing-file:     The backing file string to write into the overlay
+                    image of 'top'.  If 'top' is the active layer,
+                    specifying a backing file string is an error. This
+                    filename is not validated.
+
+                    If a pathname string is such that it cannot be
+                    resolved by QEMU, that means that subsequent QMP or
+                    HMP commands must use node-names for the image in
+                    question, as filename lookup methods will fail.
+
+                    If not specified, QEMU will automatically determine
+                    the backing file string to use, or error out if
+                    there is no obvious choice. Care should be taken
+                    when specifying the string, to specify a valid
+                    filename or protocol.
+                    (json-string, optional) (Since 2.1)
+
+          If top == base, that is an error.
+          If top == active, the job will not be completed by itself,
+          user needs to complete the job with the block-job-complete
+          command after getting the ready event. (Since 2.0)
+
+          If the base image is smaller than top, then the base image
+          will be resized to be the same size as top.  If top is
+          smaller than the base image, the base will not be
+          truncated.  If you want the base image size to match the
+          size of the smaller top, you can safely truncate it
+          yourself once the commit operation successfully completes.
+          (json-string)
+- "speed":  the maximum speed, in bytes per second (json-int, optional)
+
+
+Example:
+
+-> { "execute": "block-commit", "arguments": { "device": "virtio0",
+                                              "top": "/tmp/snap1.qcow2" } }
+<- { "return": {} }
+
+drive-backup
+------------
+
+Start a point-in-time copy of a block device to a new destination.  The
+status of ongoing drive-backup operations can be checked with
+query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
+The operation can be stopped before it has completed using the
+block-job-cancel command.
+
+Arguments:
+
+- "device": the name of the device which should be copied.
+            (json-string)
+- "target": the target of the new image. If the file exists, or if it is a
+            device, the existing file/device will be used as the new
+            destination.  If it does not exist, a new file will be created.
+            (json-string)
+- "format": the format of the new destination, default is to probe if 'mode' is
+            'existing', else the format of the source
+            (json-string, optional)
+- "sync": what parts of the disk image should be copied to the destination;
+  possibilities include "full" for all the disk, "top" for only the sectors
+  allocated in the topmost image, or "none" to only replicate new I/O
+  (MirrorSyncMode).
+- "mode": whether and how QEMU should create a new image
+          (NewImageMode, optional, default 'absolute-paths')
+- "speed": the maximum speed, in bytes per second (json-int, optional)
+- "on-source-error": the action to take on an error on the source, default
+                     'report'.  'stop' and 'enospc' can only be used
+                     if the block device supports io-status.
+                     (BlockdevOnError, optional)
+- "on-target-error": the action to take on an error on the target, default
+                     'report' (no limitations, since this applies to
+                     a different block device than device).
+                     (BlockdevOnError, optional)
+
+Example:
+-> { "execute": "drive-backup", "arguments": { "device": "drive0",
+                                               "sync": "full",
+                                               "target": "backup.img" } }
+<- { "return": {} }
+
+blockdev-backup
+---------------
+
+The device version of drive-backup: this command takes an existing named device
+as backup target.
+
+Arguments:
+
+- "device": the name of the device which should be copied.
+            (json-string)
+- "target": the name of the backup target device. (json-string)
+- "sync": what parts of the disk image should be copied to the destination;
+          possibilities include "full" for all the disk, "top" for only the
+          sectors allocated in the topmost image, or "none" to only replicate
+          new I/O (MirrorSyncMode).
+- "speed": the maximum speed, in bytes per second (json-int, optional)
+- "on-source-error": the action to take on an error on the source, default
+                     'report'.  'stop' and 'enospc' can only be used
+                     if the block device supports io-status.
+                     (BlockdevOnError, optional)
+- "on-target-error": the action to take on an error on the target, default
+                     'report' (no limitations, since this applies to
+                     a different block device than device).
+                     (BlockdevOnError, optional)
+
+Example:
+-> { "execute": "blockdev-backup", "arguments": { "device": "src-id",
+                                                  "sync": "full",
+                                                  "target": "tgt-id" } }
+<- { "return": {} }
+
+transaction
+-----------
+
+Atomically operate on one or more block devices.  The only supported operations
+for now are drive-backup, internal and external snapshotting.  A list of
+dictionaries is accepted, that contains the actions to be performed.
+If there is any failure performing any of the operations, all operations
+for the group are abandoned.
+
+For external snapshots, the dictionary contains the device, the file to use for
+the new snapshot, and the format.  The default format, if not specified, is
+qcow2.
+
+Each new snapshot defaults to being created by QEMU (wiping any
+contents if the file already exists), but it is also possible to reuse
+an externally-created file.  In the latter case, you should ensure that
+the new image file has the same contents as the current one; QEMU cannot
+perform any meaningful check.  Typically this is achieved by using the
+current image file as the backing file for the new image.
+
+On failure, the original disks pre-snapshot attempt will be used.
+
+For internal snapshots, the dictionary contains the device and the snapshot's
+name.  If an internal snapshot matching name already exists, the request will
+be rejected.  Only some image formats support it, for example, qcow2, rbd,
+and sheepdog.
+
+On failure, qemu will try delete the newly created internal snapshot in the
+transaction.  When an I/O error occurs during deletion, the user needs to fix
+it later with qemu-img or other command.
+
+Arguments:
+
+actions array:
+    - "type": the operation to perform.  The only supported
+      value is "blockdev-snapshot-sync". (json-string)
+    - "data": a dictionary.  The contents depend on the value
+      of "type".  When "type" is "blockdev-snapshot-sync":
+      - "device": device name to snapshot (json-string)
+      - "node-name": graph node name to snapshot (json-string)
+      - "snapshot-file": name of new image file (json-string)
+      - "snapshot-node-name": graph node name of the new snapshot (json-string)
+      - "format": format of new image (json-string, optional)
+      - "mode": whether and how QEMU should create the snapshot file
+        (NewImageMode, optional, default "absolute-paths")
+      When "type" is "blockdev-snapshot-internal-sync":
+      - "device": device name to snapshot (json-string)
+      - "name": name of the new snapshot (json-string)
+
+Example:
+
+-> { "execute": "transaction",
+     "arguments": { "actions": [
+         { "type": "blockdev-snapshot-sync", "data" : { "device": "ide-hd0",
+                                         "snapshot-file": "/some/place/my-image",
+                                         "format": "qcow2" } },
+         { "type": "blockdev-snapshot-sync", "data" : { "node-name": "myfile",
+                                         "snapshot-file": "/some/place/my-image2",
+                                         "snapshot-node-name": "node3432",
+                                         "mode": "existing",
+                                         "format": "qcow2" } },
+         { "type": "blockdev-snapshot-sync", "data" : { "device": "ide-hd1",
+                                         "snapshot-file": "/some/place/my-image2",
+                                         "mode": "existing",
+                                         "format": "qcow2" } },
+         { "type": "blockdev-snapshot-internal-sync", "data" : {
+                                         "device": "ide-hd2",
+                                         "name": "snapshot0" } } ] } }
+<- { "return": {} }
+
+blockdev-snapshot-sync
+----------------------
+
+Synchronous snapshot of a block device. snapshot-file specifies the
+target of the new image. If the file exists, or if it is a device, the
+snapshot will be created in the existing file/device. If does not
+exist, a new file will be created. format specifies the format of the
+snapshot image, default is qcow2.
+
+Arguments:
+
+- "device": device name to snapshot (json-string)
+- "node-name": graph node name to snapshot (json-string)
+- "snapshot-file": name of new image file (json-string)
+- "snapshot-node-name": graph node name of the new snapshot (json-string)
+- "mode": whether and how QEMU should create the snapshot file
+  (NewImageMode, optional, default "absolute-paths")
+- "format": format of new image (json-string, optional)
+
+Example:
+
+-> { "execute": "blockdev-snapshot-sync", "arguments": { "device": "ide-hd0",
+                                                         "snapshot-file":
+                                                        "/some/place/my-image",
+                                                        "format": "qcow2" } }
+<- { "return": {} }
+
+blockdev-snapshot-internal-sync
+-------------------------------
+
+Synchronously take an internal snapshot of a block device when the format of
+image used supports it.  If the name is an empty string, or a snapshot with
+name already exists, the operation will fail.
+
+Arguments:
+
+- "device": device name to snapshot (json-string)
+- "name": name of the new snapshot (json-string)
+
+Example:
+
+-> { "execute": "blockdev-snapshot-internal-sync",
+                "arguments": { "device": "ide-hd0",
+                               "name": "snapshot0" }
+   }
+<- { "return": {} }
+
+blockdev-snapshot-delete-internal-sync
+--------------------------------------
+
+Synchronously delete an internal snapshot of a block device when the format of
+image used supports it.  The snapshot is identified by name or id or both.  One
+of name or id is required.  If the snapshot is not found, the operation will
+fail.
+
+Arguments:
+
+- "device": device name (json-string)
+- "id": ID of the snapshot (json-string, optional)
+- "name": name of the snapshot (json-string, optional)
+
+Example:
+
+-> { "execute": "blockdev-snapshot-delete-internal-sync",
+                "arguments": { "device": "ide-hd0",
+                               "name": "snapshot0" }
+   }
+<- { "return": {
+                   "id": "1",
+                   "name": "snapshot0",
+                   "vm-state-size": 0,
+                   "date-sec": 1000012,
+                   "date-nsec": 10,
+                   "vm-clock-sec": 100,
+                   "vm-clock-nsec": 20
+     }
+   }
+
+drive-mirror
+------------
+
+Start mirroring a block device's writes to a new destination. target
+specifies the target of the new image. If the file exists, or if it is
+a device, it will be used as the new destination for writes. If it does not
+exist, a new file will be created. format specifies the format of the
+mirror image, default is to probe if mode='existing', else the format
+of the source.
+
+Arguments:
+
+- "device": device name to operate on (json-string)
+- "target": name of new image file (json-string)
+- "format": format of new image (json-string, optional)
+- "node-name": the name of the new block driver state in the node graph
+               (json-string, optional)
+- "replaces": the block driver node name to replace when finished
+              (json-string, optional)
+- "mode": how an image file should be created into the target
+  file/device (NewImageMode, optional, default 'absolute-paths')
+- "speed": maximum speed of the streaming job, in bytes per second
+  (json-int)
+- "granularity": granularity of the dirty bitmap, in bytes (json-int, optional)
+- "buf_size": maximum amount of data in flight from source to target, in bytes
+  (json-int, default 10M)
+- "sync": what parts of the disk image should be copied to the destination;
+  possibilities include "full" for all the disk, "top" for only the sectors
+  allocated in the topmost image, or "none" to only replicate new I/O
+  (MirrorSyncMode).
+- "on-source-error": the action to take on an error on the source
+  (BlockdevOnError, default 'report')
+- "on-target-error": the action to take on an error on the target
+  (BlockdevOnError, default 'report')
+
+The default value of the granularity is the image cluster size clamped
+between 4096 and 65536, if the image format defines one.  If the format
+does not define a cluster size, the default value of the granularity
+is 65536.
+
+
+Example:
+
+-> { "execute": "drive-mirror", "arguments": { "device": "ide-hd0",
+                                               "target": "/some/place/my-image",
+                                               "sync": "full",
+                                               "format": "qcow2" } }
+<- { "return": {} }
+
+change-backing-file
+-------------------
+Since: 2.1
+
+Change the backing file in the image file metadata.  This does not cause
+QEMU to reopen the image file to reparse the backing filename (it may,
+however, perform a reopen to change permissions from r/o -> r/w -> r/o,
+if needed). The new backing file string is written into the image file
+metadata, and the QEMU internal strings are updated.
+
+Arguments:
+
+- "image-node-name":    The name of the block driver state node of the
+                        image to modify.  The "device" is argument is used to
+                        verify "image-node-name" is in the chain described by
+                        "device".
+                        (json-string, optional)
+
+- "device":             The name of the device.
+                        (json-string)
+
+- "backing-file":       The string to write as the backing file.  This string is
+                        not validated, so care should be taken when specifying
+                        the string or the image chain may not be able to be
+                        reopened again.
+                        (json-string)
+
+Returns: Nothing on success
+         If "device" does not exist or cannot be determined, DeviceNotFound
+
+balloon
+-------
+
+Request VM to change its memory allocation (in bytes).
+
+Arguments:
+
+- "value": New memory allocation (json-int)
+
+Example:
+
+-> { "execute": "balloon", "arguments": { "value": 536870912 } }
+<- { "return": {} }
+
+set_link
+--------
+
+Change the link status of a network adapter.
+
+Arguments:
+
+- "name": network device name (json-string)
+- "up": status is up (json-bool)
+
+Example:
+
+-> { "execute": "set_link", "arguments": { "name": "e1000.0", "up": false } }
+<- { "return": {} }
+
+getfd
+-----
+
+Receive a file descriptor via SCM rights and assign it a name.
+
+Arguments:
+
+- "fdname": file descriptor name (json-string)
+
+Example:
+
+-> { "execute": "getfd", "arguments": { "fdname": "fd1" } }
+<- { "return": {} }
+
+Notes:
+
+(1) If the name specified by the "fdname" argument already exists,
+    the file descriptor assigned to it will be closed and replaced
+    by the received file descriptor.
+(2) The 'closefd' command can be used to explicitly close the file
+    descriptor when it is no longer needed.
+
+closefd
+-------
+
+Close a file descriptor previously passed via SCM rights.
+
+Arguments:
+
+- "fdname": file descriptor name (json-string)
+
+Example:
+
+-> { "execute": "closefd", "arguments": { "fdname": "fd1" } }
+<- { "return": {} }
+
+add-fd
+-------
+
+Add a file descriptor, that was passed via SCM rights, to an fd set.
+
+Arguments:
+
+- "fdset-id": The ID of the fd set to add the file descriptor to.
+              (json-int, optional)
+- "opaque": A free-form string that can be used to describe the fd.
+            (json-string, optional)
+
+Return a json-object with the following information:
+
+- "fdset-id": The ID of the fd set that the fd was added to. (json-int)
+- "fd": The file descriptor that was received via SCM rights and added to the
+        fd set. (json-int)
+
+Example:
+
+-> { "execute": "add-fd", "arguments": { "fdset-id": 1 } }
+<- { "return": { "fdset-id": 1, "fd": 3 } }
+
+Notes:
+
+(1) The list of fd sets is shared by all monitor connections.
+(2) If "fdset-id" is not specified, a new fd set will be created.
+
+remove-fd
+---------
+
+Remove a file descriptor from an fd set.
+
+Arguments:
+
+- "fdset-id": The ID of the fd set that the file descriptor belongs to.
+              (json-int)
+- "fd": The file descriptor that is to be removed. (json-int, optional)
+
+Example:
+
+-> { "execute": "remove-fd", "arguments": { "fdset-id": 1, "fd": 3 } }
+<- { "return": {} }
+
+Notes:
+
+(1) The list of fd sets is shared by all monitor connections.
+(2) If "fd" is not specified, all file descriptors in "fdset-id" will be
+    removed.
+
+query-fdsets
+-------------
+
+Return information describing all fd sets.
+
+Arguments: None
+
+Example:
+
+-> { "execute": "query-fdsets" }
+<- { "return": [
+       {
+         "fds": [
+           {
+             "fd": 30,
+             "opaque": "rdonly:/path/to/file"
+           },
+           {
+             "fd": 24,
+             "opaque": "rdwr:/path/to/file"
+           }
+         ],
+         "fdset-id": 1
+       },
+       {
+         "fds": [
+           {
+             "fd": 28
+           },
+           {
+             "fd": 29
+           }
+         ],
+         "fdset-id": 0
+       }
+     ]
+   }
+
+Note: The list of fd sets is shared by all monitor connections.
+
+block_passwd
+------------
+
+Set the password of encrypted block devices.
+
+Arguments:
+
+- "device": device name (json-string)
+- "node-name": name in the block driver state graph (json-string)
+- "password": password (json-string)
+
+Example:
+
+-> { "execute": "block_passwd", "arguments": { "device": "ide0-hd0",
+                                               "password": "12345" } }
+<- { "return": {} }
+
+block_set_io_throttle
+------------
+
+Change I/O throttle limits for a block drive.
+
+Arguments:
+
+- "device": device name (json-string)
+- "bps": total throughput limit in bytes per second (json-int)
+- "bps_rd": read throughput limit in bytes per second (json-int)
+- "bps_wr": write throughput limit in bytes per second (json-int)
+- "iops": total I/O operations per second (json-int)
+- "iops_rd": read I/O operations per second (json-int)
+- "iops_wr": write I/O operations per second (json-int)
+- "bps_max":  total max in bytes (json-int)
+- "bps_rd_max":  read max in bytes (json-int)
+- "bps_wr_max":  write max in bytes (json-int)
+- "iops_max":  total I/O operations max (json-int)
+- "iops_rd_max":  read I/O operations max (json-int)
+- "iops_wr_max":  write I/O operations max (json-int)
+- "iops_size":  I/O size in bytes when limiting (json-int)
+
+Example:
+
+-> { "execute": "block_set_io_throttle", "arguments": { "device": "virtio0",
+                                               "bps": 1000000,
+                                               "bps_rd": 0,
+                                               "bps_wr": 0,
+                                               "iops": 0,
+                                               "iops_rd": 0,
+                                               "iops_wr": 0,
+                                               "bps_max": 8000000,
+                                               "bps_rd_max": 0,
+                                               "bps_wr_max": 0,
+                                               "iops_max": 0,
+                                               "iops_rd_max": 0,
+                                               "iops_wr_max": 0,
+                                               "iops_size": 0 } }
+<- { "return": {} }
+
+set_password
+------------
+
+Set the password for vnc/spice protocols.
+
+Arguments:
+
+- "protocol": protocol name (json-string)
+- "password": password (json-string)
+- "connected": [ keep | disconnect | fail ] (json-string, optional)
+
+Example:
+
+-> { "execute": "set_password", "arguments": { "protocol": "vnc",
+                                               "password": "secret" } }
+<- { "return": {} }
+
+expire_password
+---------------
+
+Set the password expire time for vnc/spice protocols.
+
+Arguments:
+
+- "protocol": protocol name (json-string)
+- "time": [ now | never | +secs | secs ] (json-string)
+
+Example:
+
+-> { "execute": "expire_password", "arguments": { "protocol": "vnc",
+                                                  "time": "+60" } }
+<- { "return": {} }
+
+add_client
+----------
+
+Add a graphics client
+
+Arguments:
+
+- "protocol": protocol name (json-string)
+- "fdname": file descriptor name (json-string)
+- "skipauth": whether to skip authentication (json-bool, optional)
+- "tls": whether to perform TLS (json-bool, optional)
+
+Example:
+
+-> { "execute": "add_client", "arguments": { "protocol": "vnc",
+                                             "fdname": "myclient" } }
+<- { "return": {} }
+
+qmp_capabilities
+----------------
+
+Enable QMP capabilities.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "qmp_capabilities" }
+<- { "return": {} }
+
+Note: This command must be issued before issuing any other command.
+
+human-monitor-command
+---------------------
+
+Execute a Human Monitor command.
+
+Arguments: 
+
+- command-line: the command name and its arguments, just like the
+                Human Monitor's shell (json-string)
+- cpu-index: select the CPU number to be used by commands which access CPU
+             data, like 'info registers'. The Monitor selects CPU 0 if this
+             argument is not provided (json-int, optional)
+
+Example:
+
+-> { "execute": "human-monitor-command", "arguments": { "command-line": "info kvm" } }
+<- { "return": "kvm support: enabled
+" }
+
+Notes:
+
+(1) The Human Monitor is NOT an stable interface, this means that command
+    names, arguments and responses can change or be removed at ANY time.
+    Applications that rely on long term stability guarantees should NOT
+    use this command
+
+(2) Limitations:
+
+    o This command is stateless, this means that commands that depend
+      on state information (such as getfd) might not work
+
+    o Commands that prompt the user for data (eg. 'cont' when the block
+      device is encrypted) don't currently work
+
+3. Query Commands
+=================
+
+
+query-version
+-------------
+
+Show QEMU version.
+
+Return a json-object with the following information:
+
+- "qemu": A json-object containing three integer values:
+    - "major": QEMU's major version (json-int)
+    - "minor": QEMU's minor version (json-int)
+    - "micro": QEMU's micro version (json-int)
+- "package": package's version (json-string)
+
+Example:
+
+-> { "execute": "query-version" }
+<- {
+      "return":{
+         "qemu":{
+            "major":0,
+            "minor":11,
+            "micro":5
+         },
+         "package":""
+      }
+   }
+
+query-commands
+--------------
+
+List QMP available commands.
+
+Each command is represented by a json-object, the returned value is a json-array
+of all commands.
+
+Each json-object contain:
+
+- "name": command's name (json-string)
+
+Example:
+
+-> { "execute": "query-commands" }
+<- {
+      "return":[
+         {
+            "name":"query-balloon"
+         },
+         {
+            "name":"system_powerdown"
+         }
+      ]
+   }
+
+Note: This example has been shortened as the real response is too long.
+
+query-events
+--------------
+
+List QMP available events.
+
+Each event is represented by a json-object, the returned value is a json-array
+of all events.
+
+Each json-object contains:
+
+- "name": event's name (json-string)
+
+Example:
+
+-> { "execute": "query-events" }
+<- {
+      "return":[
+         {
+            "name":"SHUTDOWN"
+         },
+         {
+            "name":"RESET"
+         }
+      ]
+   }
+
+Note: This example has been shortened as the real response is too long.
+
+query-chardev
+-------------
+
+Each device is represented by a json-object. The returned value is a json-array
+of all devices.
+
+Each json-object contain the following:
+
+- "label": device's label (json-string)
+- "filename": device's file (json-string)
+- "frontend-open": open/closed state of the frontend device attached to this
+                   backend (json-bool)
+
+Example:
+
+-> { "execute": "query-chardev" }
+<- {
+      "return": [
+         {
+            "label": "charchannel0",
+            "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.agent,server",
+            "frontend-open": false
+         },
+         {
+            "label": "charmonitor",
+            "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.monitor,server",
+            "frontend-open": true
+         },
+         {
+            "label": "charserial0",
+            "filename": "pty:/dev/pts/2",
+            "frontend-open": true
+         }
+      ]
+   }
+
+query-chardev-backends
+-------------
+
+List available character device backends.
+
+Each backend is represented by a json-object, the returned value is a json-array
+of all backends.
+
+Each json-object contains:
+
+- "name": backend name (json-string)
+
+Example:
+
+-> { "execute": "query-chardev-backends" }
+<- {
+      "return":[
+         {
+            "name":"udp"
+         },
+         {
+            "name":"tcp"
+         },
+         {
+            "name":"unix"
+         },
+         {
+            "name":"spiceport"
+         }
+      ]
+   }
+
+query-block
+-----------
+
+Show the block devices.
+
+Each block device information is stored in a json-object and the returned value
+is a json-array of all devices.
+
+Each json-object contain the following:
+
+- "device": device name (json-string)
+- "type": device type (json-string)
+         - deprecated, retained for backward compatibility
+         - Possible values: "unknown"
+- "removable": true if the device is removable, false otherwise (json-bool)
+- "locked": true if the device is locked, false otherwise (json-bool)
+- "tray_open": only present if removable, true if the device has a tray,
+               and it is open (json-bool)
+- "inserted": only present if the device is inserted, it is a json-object
+   containing the following:
+         - "file": device file name (json-string)
+         - "ro": true if read-only, false otherwise (json-bool)
+         - "drv": driver format name (json-string)
+             - Possible values: "blkdebug", "bochs", "cloop", "dmg",
+                                "file", "file", "ftp", "ftps", "host_cdrom",
+                                "host_device", "http", "https",
+                                "nbd", "parallels", "qcow", "qcow2", "raw",
+                                "tftp", "vdi", "vmdk", "vpc", "vvfat"
+         - "backing_file": backing file name (json-string, optional)
+         - "backing_file_depth": number of files in the backing file chain (json-int)
+         - "encrypted": true if encrypted, false otherwise (json-bool)
+         - "bps": limit total bytes per second (json-int)
+         - "bps_rd": limit read bytes per second (json-int)
+         - "bps_wr": limit write bytes per second (json-int)
+         - "iops": limit total I/O operations per second (json-int)
+         - "iops_rd": limit read operations per second (json-int)
+         - "iops_wr": limit write operations per second (json-int)
+         - "bps_max":  total max in bytes (json-int)
+         - "bps_rd_max":  read max in bytes (json-int)
+         - "bps_wr_max":  write max in bytes (json-int)
+         - "iops_max":  total I/O operations max (json-int)
+         - "iops_rd_max":  read I/O operations max (json-int)
+         - "iops_wr_max":  write I/O operations max (json-int)
+         - "iops_size": I/O size when limiting by iops (json-int)
+         - "detect_zeroes": detect and optimize zero writing (json-string)
+             - Possible values: "off", "on", "unmap"
+         - "write_threshold": write offset threshold in bytes, a event will be
+                              emitted if crossed. Zero if disabled (json-int)
+         - "image": the detail of the image, it is a json-object containing
+            the following:
+             - "filename": image file name (json-string)
+             - "format": image format (json-string)
+             - "virtual-size": image capacity in bytes (json-int)
+             - "dirty-flag": true if image is not cleanly closed, not present
+                             means clean (json-bool, optional)
+             - "actual-size": actual size on disk in bytes of the image, not
+                              present when image does not support thin
+                              provision (json-int, optional)
+             - "cluster-size": size of a cluster in bytes, not present if image
+                               format does not support it (json-int, optional)
+             - "encrypted": true if the image is encrypted, not present means
+                            false or the image format does not support
+                            encryption (json-bool, optional)
+             - "backing_file": backing file name, not present means no backing
+                               file is used or the image format does not
+                               support backing file chain
+                               (json-string, optional)
+             - "full-backing-filename": full path of the backing file, not
+                                        present if it equals backing_file or no
+                                        backing file is used
+                                        (json-string, optional)
+             - "backing-filename-format": the format of the backing file, not
+                                          present means unknown or no backing
+                                          file (json-string, optional)
+             - "snapshots": the internal snapshot info, it is an optional list
+                of json-object containing the following:
+                 - "id": unique snapshot id (json-string)
+                 - "name": snapshot name (json-string)
+                 - "vm-state-size": size of the VM state in bytes (json-int)
+                 - "date-sec": UTC date of the snapshot in seconds (json-int)
+                 - "date-nsec": fractional part in nanoseconds to be used with
+                                date-sec (json-int)
+                 - "vm-clock-sec": VM clock relative to boot in seconds
+                                   (json-int)
+                 - "vm-clock-nsec": fractional part in nanoseconds to be used
+                                    with vm-clock-sec (json-int)
+             - "backing-image": the detail of the backing image, it is an
+                                optional json-object only present when a
+                                backing image present for this image
+
+- "io-status": I/O operation status, only present if the device supports it
+               and the VM is configured to stop on errors. It's always reset
+               to "ok" when the "cont" command is issued (json_string, optional)
+             - Possible values: "ok", "failed", "nospace"
+
+Example:
+
+-> { "execute": "query-block" }
+<- {
+      "return":[
+         {
+            "io-status": "ok",
+            "device":"ide0-hd0",
+            "locked":false,
+            "removable":false,
+            "inserted":{
+               "ro":false,
+               "drv":"qcow2",
+               "encrypted":false,
+               "file":"disks/test.qcow2",
+               "backing_file_depth":1,
+               "bps":1000000,
+               "bps_rd":0,
+               "bps_wr":0,
+               "iops":1000000,
+               "iops_rd":0,
+               "iops_wr":0,
+               "bps_max": 8000000,
+               "bps_rd_max": 0,
+               "bps_wr_max": 0,
+               "iops_max": 0,
+               "iops_rd_max": 0,
+               "iops_wr_max": 0,
+               "iops_size": 0,
+               "detect_zeroes": "on",
+               "write_threshold": 0,
+               "image":{
+                  "filename":"disks/test.qcow2",
+                  "format":"qcow2",
+                  "virtual-size":2048000,
+                  "backing_file":"base.qcow2",
+                  "full-backing-filename":"disks/base.qcow2",
+                  "backing-filename-format:"qcow2",
+                  "snapshots":[
+                     {
+                        "id": "1",
+                        "name": "snapshot1",
+                        "vm-state-size": 0,
+                        "date-sec": 10000200,
+                        "date-nsec": 12,
+                        "vm-clock-sec": 206,
+                        "vm-clock-nsec": 30
+                     }
+                  ],
+                  "backing-image":{
+                      "filename":"disks/base.qcow2",
+                      "format":"qcow2",
+                      "virtual-size":2048000
+                  }
+               }
+            },
+            "type":"unknown"
+         },
+         {
+            "io-status": "ok",
+            "device":"ide1-cd0",
+            "locked":false,
+            "removable":true,
+            "type":"unknown"
+         },
+         {
+            "device":"floppy0",
+            "locked":false,
+            "removable":true,
+            "type":"unknown"
+         },
+         {
+            "device":"sd0",
+            "locked":false,
+            "removable":true,
+            "type":"unknown"
+         }
+      ]
+   }
+
+query-blockstats
+----------------
+
+Show block device statistics.
+
+Each device statistic information is stored in a json-object and the returned
+value is a json-array of all devices.
+
+Each json-object contain the following:
+
+- "device": device name (json-string)
+- "stats": A json-object with the statistics information, it contains:
+    - "rd_bytes": bytes read (json-int)
+    - "wr_bytes": bytes written (json-int)
+    - "rd_operations": read operations (json-int)
+    - "wr_operations": write operations (json-int)
+    - "flush_operations": cache flush operations (json-int)
+    - "wr_total_time_ns": total time spend on writes in nano-seconds (json-int)
+    - "rd_total_time_ns": total time spend on reads in nano-seconds (json-int)
+    - "flush_total_time_ns": total time spend on cache flushes in nano-seconds (json-int)
+    - "wr_highest_offset": Highest offset of a sector written since the
+                           BlockDriverState has been opened (json-int)
+    - "rd_merged": number of read requests that have been merged into
+                   another request (json-int)
+    - "wr_merged": number of write requests that have been merged into
+                   another request (json-int)
+- "parent": Contains recursively the statistics of the underlying
+            protocol (e.g. the host file for a qcow2 image). If there is
+            no underlying protocol, this field is omitted
+            (json-object, optional)
+
+Example:
+
+-> { "execute": "query-blockstats" }
+<- {
+      "return":[
+         {
+            "device":"ide0-hd0",
+            "parent":{
+               "stats":{
+                  "wr_highest_offset":3686448128,
+                  "wr_bytes":9786368,
+                  "wr_operations":751,
+                  "rd_bytes":122567168,
+                  "rd_operations":36772
+                  "wr_total_times_ns":313253456
+                  "rd_total_times_ns":3465673657
+                  "flush_total_times_ns":49653
+                  "flush_operations":61,
+                  "rd_merged":0,
+                  "wr_merged":0
+               }
+            },
+            "stats":{
+               "wr_highest_offset":2821110784,
+               "wr_bytes":9786368,
+               "wr_operations":692,
+               "rd_bytes":122739200,
+               "rd_operations":36604
+               "flush_operations":51,
+               "wr_total_times_ns":313253456
+               "rd_total_times_ns":3465673657
+               "flush_total_times_ns":49653,
+               "rd_merged":0,
+               "wr_merged":0
+            }
+         },
+         {
+            "device":"ide1-cd0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+               "flush_operations":0,
+               "wr_total_times_ns":0
+               "rd_total_times_ns":0
+               "flush_total_times_ns":0,
+               "rd_merged":0,
+               "wr_merged":0
+            }
+         },
+         {
+            "device":"floppy0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+               "flush_operations":0,
+               "wr_total_times_ns":0
+               "rd_total_times_ns":0
+               "flush_total_times_ns":0,
+               "rd_merged":0,
+               "wr_merged":0
+            }
+         },
+         {
+            "device":"sd0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+               "flush_operations":0,
+               "wr_total_times_ns":0
+               "rd_total_times_ns":0
+               "flush_total_times_ns":0,
+               "rd_merged":0,
+               "wr_merged":0
+            }
+         }
+      ]
+   }
+
+query-cpus
+----------
+
+Show CPU information.
+
+Return a json-array. Each CPU is represented by a json-object, which contains:
+
+- "CPU": CPU index (json-int)
+- "current": true if this is the current CPU, false otherwise (json-bool)
+- "halted": true if the cpu is halted, false otherwise (json-bool)
+- Current program counter. The key's name depends on the architecture:
+     "pc": i386/x86_64 (json-int)
+     "nip": PPC (json-int)
+     "pc" and "npc": sparc (json-int)
+     "PC": mips (json-int)
+- "thread_id": ID of the underlying host thread (json-int)
+
+Example:
+
+-> { "execute": "query-cpus" }
+<- {
+      "return":[
+         {
+            "CPU":0,
+            "current":true,
+            "halted":false,
+            "pc":3227107138
+            "thread_id":3134
+         },
+         {
+            "CPU":1,
+            "current":false,
+            "halted":true,
+            "pc":7108165
+            "thread_id":3135
+         }
+      ]
+   }
+
+query-iothreads
+---------------
+
+Returns a list of information about each iothread.
+
+Note this list excludes the QEMU main loop thread, which is not declared
+using the -object iothread command-line option.  It is always the main thread
+of the process.
+
+Return a json-array. Each iothread is represented by a json-object, which contains:
+
+- "id": name of iothread (json-str)
+- "thread-id": ID of the underlying host thread (json-int)
+
+Example:
+
+-> { "execute": "query-iothreads" }
+<- {
+      "return":[
+         {
+            "id":"iothread0",
+            "thread-id":3134
+         },
+         {
+            "id":"iothread1",
+            "thread-id":3135
+         }
+      ]
+   }
+
+query-pci
+---------
+
+PCI buses and devices information.
+
+The returned value is a json-array of all buses. Each bus is represented by
+a json-object, which has a key with a json-array of all PCI devices attached
+to it. Each device is represented by a json-object.
+
+The bus json-object contains the following:
+
+- "bus": bus number (json-int)
+- "devices": a json-array of json-objects, each json-object represents a
+             PCI device
+
+The PCI device json-object contains the following:
+
+- "bus": identical to the parent's bus number (json-int)
+- "slot": slot number (json-int)
+- "function": function number (json-int)
+- "class_info": a json-object containing:
+     - "desc": device class description (json-string, optional)
+     - "class": device class number (json-int)
+- "id": a json-object containing:
+     - "device": device ID (json-int)
+     - "vendor": vendor ID (json-int)
+- "irq": device's IRQ if assigned (json-int, optional)
+- "qdev_id": qdev id string (json-string)
+- "pci_bridge": It's a json-object, only present if this device is a
+                PCI bridge, contains:
+     - "bus": bus number (json-int)
+     - "secondary": secondary bus number (json-int)
+     - "subordinate": subordinate bus number (json-int)
+     - "io_range": I/O memory range information, a json-object with the
+                   following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "memory_range": memory range information, a json-object with the
+                       following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "prefetchable_range": Prefetchable memory range information, a
+                             json-object with the following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "devices": a json-array of PCI devices if there's any attached, each
+                  each element is represented by a json-object, which contains
+                  the same members of the 'PCI device json-object' described
+                  above (optional)
+- "regions": a json-array of json-objects, each json-object represents a
+             memory region of this device
+
+The memory range json-object contains the following:
+
+- "base": base memory address (json-int)
+- "limit": limit value (json-int)
+
+The region json-object can be an I/O region or a memory region, an I/O region
+json-object contains the following:
+
+- "type": "io" (json-string, fixed)
+- "bar": BAR number (json-int)
+- "address": memory address (json-int)
+- "size": memory size (json-int)
+
+A memory region json-object contains the following:
+
+- "type": "memory" (json-string, fixed)
+- "bar": BAR number (json-int)
+- "address": memory address (json-int)
+- "size": memory size (json-int)
+- "mem_type_64": true or false (json-bool)
+- "prefetch": true or false (json-bool)
+
+Example:
+
+-> { "execute": "query-pci" }
+<- {
+      "return":[
+         {
+            "bus":0,
+            "devices":[
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":0,
+                  "class_info":{
+                     "class":1536,
+                     "desc":"Host bridge"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":4663
+                  },
+                  "function":0,
+                  "regions":[
+   
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":1,
+                  "class_info":{
+                     "class":1537,
+                     "desc":"ISA bridge"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":28672
+                  },
+                  "function":0,
+                  "regions":[
+   
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":1,
+                  "class_info":{
+                     "class":257,
+                     "desc":"IDE controller"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":28688
+                  },
+                  "function":1,
+                  "regions":[
+                     {
+                        "bar":4,
+                        "size":16,
+                        "address":49152,
+                        "type":"io"
+                     }
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":2,
+                  "class_info":{
+                     "class":768,
+                     "desc":"VGA controller"
+                  },
+                  "id":{
+                     "device":4115,
+                     "vendor":184
+                  },
+                  "function":0,
+                  "regions":[
+                     {
+                        "prefetch":true,
+                        "mem_type_64":false,
+                        "bar":0,
+                        "size":33554432,
+                        "address":4026531840,
+                        "type":"memory"
+                     },
+                     {
+                        "prefetch":false,
+                        "mem_type_64":false,
+                        "bar":1,
+                        "size":4096,
+                        "address":4060086272,
+                        "type":"memory"
+                     },
+                     {
+                        "prefetch":false,
+                        "mem_type_64":false,
+                        "bar":6,
+                        "size":65536,
+                        "address":-1,
+                        "type":"memory"
+                     }
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "irq":11,
+                  "slot":4,
+                  "class_info":{
+                     "class":1280,
+                     "desc":"RAM controller"
+                  },
+                  "id":{
+                     "device":6900,
+                     "vendor":4098
+                  },
+                  "function":0,
+                  "regions":[
+                     {
+                        "bar":0,
+                        "size":32,
+                        "address":49280,
+                        "type":"io"
+                     }
+                  ]
+               }
+            ]
+         }
+      ]
+   }
+
+Note: This example has been shortened as the real response is too long.
+
+query-kvm
+---------
+
+Show KVM information.
+
+Return a json-object with the following information:
+
+- "enabled": true if KVM support is enabled, false otherwise (json-bool)
+- "present": true if QEMU has KVM support, false otherwise (json-bool)
+
+Example:
+
+-> { "execute": "query-kvm" }
+<- { "return": { "enabled": true, "present": true } }
+
+query-status
+------------
+
+Return a json-object with the following information:
+
+- "running": true if the VM is running, or false if it is paused (json-bool)
+- "singlestep": true if the VM is in single step mode,
+                false otherwise (json-bool)
+- "status": one of the following values (json-string)
+    "debug" - QEMU is running on a debugger
+    "inmigrate" - guest is paused waiting for an incoming migration
+    "internal-error" - An internal error that prevents further guest
+    execution has occurred
+    "io-error" - the last IOP has failed and the device is configured
+    to pause on I/O errors
+    "paused" - guest has been paused via the 'stop' command
+    "postmigrate" - guest is paused following a successful 'migrate'
+    "prelaunch" - QEMU was started with -S and guest has not started
+    "finish-migrate" - guest is paused to finish the migration process
+    "restore-vm" - guest is paused to restore VM state
+    "running" - guest is actively running
+    "save-vm" - guest is paused to save the VM state
+    "shutdown" - guest is shut down (and -no-shutdown is in use)
+    "watchdog" - the watchdog action is configured to pause and
+     has been triggered
+
+Example:
+
+-> { "execute": "query-status" }
+<- { "return": { "running": true, "singlestep": false, "status": "running" } }
+
+query-mice
+----------
+
+Show VM mice information.
+
+Each mouse is represented by a json-object, the returned value is a json-array
+of all mice.
+
+The mouse json-object contains the following:
+
+- "name": mouse's name (json-string)
+- "index": mouse's index (json-int)
+- "current": true if this mouse is receiving events, false otherwise (json-bool)
+- "absolute": true if the mouse generates absolute input events (json-bool)
+
+Example:
+
+-> { "execute": "query-mice" }
+<- {
+      "return":[
+         {
+            "name":"QEMU Microsoft Mouse",
+            "index":0,
+            "current":false,
+            "absolute":false
+         },
+         {
+            "name":"QEMU PS/2 Mouse",
+            "index":1,
+            "current":true,
+            "absolute":true
+         }
+      ]
+   }
+
+query-vnc
+---------
+
+Show VNC server information.
+
+Return a json-object with server information. Connected clients are returned
+as a json-array of json-objects.
+
+The main json-object contains the following:
+
+- "enabled": true or false (json-bool)
+- "host": server's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "service": server's port number (json-string)
+- "auth": authentication method (json-string)
+         - Possible values: "invalid", "none", "ra2", "ra2ne", "sasl", "tight",
+                            "tls", "ultra", "unknown", "vencrypt", "vencrypt",
+                            "vencrypt+plain", "vencrypt+tls+none",
+                            "vencrypt+tls+plain", "vencrypt+tls+sasl",
+                            "vencrypt+tls+vnc", "vencrypt+x509+none",
+                            "vencrypt+x509+plain", "vencrypt+x509+sasl",
+                            "vencrypt+x509+vnc", "vnc"
+- "clients": a json-array of all connected clients
+
+Clients are described by a json-object, each one contain the following:
+
+- "host": client's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "service": client's port number (json-string)
+- "x509_dname": TLS dname (json-string, optional)
+- "sasl_username": SASL username (json-string, optional)
+
+Example:
+
+-> { "execute": "query-vnc" }
+<- {
+      "return":{
+         "enabled":true,
+         "host":"0.0.0.0",
+         "service":"50402",
+         "auth":"vnc",
+         "family":"ipv4",
+         "clients":[
+            {
+               "host":"127.0.0.1",
+               "service":"50401",
+               "family":"ipv4"
+            }
+         ]
+      }
+   }
+
+query-spice
+-----------
+
+Show SPICE server information.
+
+Return a json-object with server information. Connected clients are returned
+as a json-array of json-objects.
+
+The main json-object contains the following:
+
+- "enabled": true or false (json-bool)
+- "host": server's IP address (json-string)
+- "port": server's port number (json-int, optional)
+- "tls-port": server's port number (json-int, optional)
+- "auth": authentication method (json-string)
+         - Possible values: "none", "spice"
+- "channels": a json-array of all active channels clients
+
+Channels are described by a json-object, each one contain the following:
+
+- "host": client's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "port": client's port number (json-string)
+- "connection-id": spice connection id.  All channels with the same id
+                   belong to the same spice session (json-int)
+- "channel-type": channel type.  "1" is the main control channel, filter for
+                  this one if you want track spice sessions only (json-int)
+- "channel-id": channel id.  Usually "0", might be different needed when
+                multiple channels of the same type exist, such as multiple
+                display channels in a multihead setup (json-int)
+- "tls": whether the channel is encrypted (json-bool)
+
+Example:
+
+-> { "execute": "query-spice" }
+<- {
+      "return": {
+         "enabled": true,
+         "auth": "spice",
+         "port": 5920,
+         "tls-port": 5921,
+         "host": "0.0.0.0",
+         "channels": [
+            {
+               "port": "54924",
+               "family": "ipv4",
+               "channel-type": 1,
+               "connection-id": 1804289383,
+               "host": "127.0.0.1",
+               "channel-id": 0,
+               "tls": true
+            },
+            {
+               "port": "36710",
+               "family": "ipv4",
+               "channel-type": 4,
+               "connection-id": 1804289383,
+               "host": "127.0.0.1",
+               "channel-id": 0,
+               "tls": false
+            },
+            [ ... more channels follow ... ]
+         ]
+      }
+   }
+
+query-name
+----------
+
+Show VM name.
+
+Return a json-object with the following information:
+
+- "name": VM's name (json-string, optional)
+
+Example:
+
+-> { "execute": "query-name" }
+<- { "return": { "name": "qemu-name" } }
+
+query-uuid
+----------
+
+Show VM UUID.
+
+Return a json-object with the following information:
+
+- "UUID": Universally Unique Identifier (json-string)
+
+Example:
+
+-> { "execute": "query-uuid" }
+<- { "return": { "UUID": "550e8400-e29b-41d4-a716-446655440000" } }
+
+query-command-line-options
+--------------------------
+
+Show command line option schema.
+
+Return a json-array of command line option schema for all options (or for
+the given option), returning an error if the given option doesn't exist.
+
+Each array entry contains the following:
+
+- "option": option name (json-string)
+- "parameters": a json-array describes all parameters of the option:
+    - "name": parameter name (json-string)
+    - "type": parameter type (one of 'string', 'boolean', 'number',
+              or 'size')
+    - "help": human readable description of the parameter
+              (json-string, optional)
+    - "default": default value string for the parameter
+                 (json-string, optional)
+
+Example:
+
+-> { "execute": "query-command-line-options", "arguments": { "option": "option-rom" } }
+<- { "return": [
+        {
+            "parameters": [
+                {
+                    "name": "romfile",
+                    "type": "string"
+                },
+                {
+                    "name": "bootindex",
+                    "type": "number"
+                }
+            ],
+            "option": "option-rom"
+        }
+     ]
+   }
+
+query-migrate
+-------------
+
+Migration status.
+
+Return a json-object. If migration is active there will be another json-object
+with RAM migration status and if block migration is active another one with
+block migration status.
+
+The main json-object contains the following:
+
+- "status": migration status (json-string)
+     - Possible values: "setup", "active", "completed", "failed", "cancelled"
+- "total-time": total amount of ms since migration started.  If
+                migration has ended, it returns the total migration
+                time (json-int)
+- "setup-time" amount of setup time in milliseconds _before_ the
+               iterations begin but _after_ the QMP command is issued.
+               This is designed to provide an accounting of any activities
+               (such as RDMA pinning) which may be expensive, but do not 
+               actually occur during the iterative migration rounds 
+               themselves. (json-int)
+- "downtime": only present when migration has finished correctly
+              total amount in ms for downtime that happened (json-int)
+- "expected-downtime": only present while migration is active
+                total amount in ms for downtime that was calculated on
+                the last bitmap round (json-int)
+- "ram": only present if "status" is "active", it is a json-object with the
+  following RAM information:
+         - "transferred": amount transferred in bytes (json-int)
+         - "remaining": amount remaining to transfer in bytes (json-int)
+         - "total": total amount of memory in bytes (json-int)
+         - "duplicate": number of pages filled entirely with the same
+            byte (json-int)
+            These are sent over the wire much more efficiently.
+         - "skipped": number of skipped zero pages (json-int)
+         - "normal" : number of whole pages transferred.  I.e. they
+            were not sent as duplicate or xbzrle pages (json-int)
+         - "normal-bytes" : number of bytes transferred in whole
+            pages. This is just normal pages times size of one page,
+            but this way upper levels don't need to care about page
+            size (json-int)
+         - "dirty-sync-count": times that dirty ram was synchronized (json-int)
+- "disk": only present if "status" is "active" and it is a block migration,
+  it is a json-object with the following disk information:
+         - "transferred": amount transferred in bytes (json-int)
+         - "remaining": amount remaining to transfer in bytes json-int)
+         - "total": total disk size in bytes (json-int)
+- "xbzrle-cache": only present if XBZRLE is active.
+  It is a json-object with the following XBZRLE information:
+         - "cache-size": XBZRLE cache size in bytes
+         - "bytes": number of bytes transferred for XBZRLE compressed pages
+         - "pages": number of XBZRLE compressed pages
+         - "cache-miss": number of XBRZRLE page cache misses
+         - "cache-miss-rate": rate of XBRZRLE page cache misses
+         - "overflow": number of times XBZRLE overflows.  This means
+           that the XBZRLE encoding was bigger than just sent the
+           whole page, and then we sent the whole page instead (as as
+           normal page).
+
+Examples:
+
+1. Before the first migration
+
+-> { "execute": "query-migrate" }
+<- { "return": {} }
+
+2. Migration is done and has succeeded
+
+-> { "execute": "query-migrate" }
+<- { "return": {
+        "status": "completed",
+        "ram":{
+          "transferred":123,
+          "remaining":123,
+          "total":246,
+          "total-time":12345,
+          "setup-time":12345,
+          "downtime":12345,
+          "duplicate":123,
+          "normal":123,
+          "normal-bytes":123456,
+          "dirty-sync-count":15
+        }
+     }
+   }
+
+3. Migration is done and has failed
+
+-> { "execute": "query-migrate" }
+<- { "return": { "status": "failed" } }
+
+4. Migration is being performed and is not a block migration:
+
+-> { "execute": "query-migrate" }
+<- {
+      "return":{
+         "status":"active",
+         "ram":{
+            "transferred":123,
+            "remaining":123,
+            "total":246,
+            "total-time":12345,
+            "setup-time":12345,
+            "expected-downtime":12345,
+            "duplicate":123,
+            "normal":123,
+            "normal-bytes":123456,
+            "dirty-sync-count":15
+         }
+      }
+   }
+
+5. Migration is being performed and is a block migration:
+
+-> { "execute": "query-migrate" }
+<- {
+      "return":{
+         "status":"active",
+         "ram":{
+            "total":1057024,
+            "remaining":1053304,
+            "transferred":3720,
+            "total-time":12345,
+            "setup-time":12345,
+            "expected-downtime":12345,
+            "duplicate":123,
+            "normal":123,
+            "normal-bytes":123456,
+            "dirty-sync-count":15
+         },
+         "disk":{
+            "total":20971520,
+            "remaining":20880384,
+            "transferred":91136
+         }
+      }
+   }
+
+6. Migration is being performed and XBZRLE is active:
+
+-> { "execute": "query-migrate" }
+<- {
+      "return":{
+         "status":"active",
+         "capabilities" : [ { "capability": "xbzrle", "state" : true } ],
+         "ram":{
+            "total":1057024,
+            "remaining":1053304,
+            "transferred":3720,
+            "total-time":12345,
+            "setup-time":12345,
+            "expected-downtime":12345,
+            "duplicate":10,
+            "normal":3333,
+            "normal-bytes":3412992,
+            "dirty-sync-count":15
+         },
+         "xbzrle-cache":{
+            "cache-size":67108864,
+            "bytes":20971520,
+            "pages":2444343,
+            "cache-miss":2244,
+            "cache-miss-rate":0.123,
+            "overflow":34434
+         }
+      }
+   }
+
+migrate-set-capabilities
+------------------------
+
+Enable/Disable migration capabilities
+
+- "xbzrle": XBZRLE support
+- "rdma-pin-all": pin all pages when using RDMA during migration
+- "auto-converge": throttle down guest to help convergence of migration
+- "zero-blocks": compress zero blocks during block migration
+
+Arguments:
+
+Example:
+
+-> { "execute": "migrate-set-capabilities" , "arguments":
+     { "capabilities": [ { "capability": "xbzrle", "state": true } ] } }
+
+query-migrate-capabilities
+--------------------------
+
+Query current migration capabilities
+
+- "capabilities": migration capabilities state
+         - "xbzrle" : XBZRLE state (json-bool)
+         - "rdma-pin-all" : RDMA Pin Page state (json-bool)
+         - "auto-converge" : Auto Converge state (json-bool)
+         - "zero-blocks" : Zero Blocks state (json-bool)
+
+Arguments:
+
+Example:
+
+-> { "execute": "query-migrate-capabilities" }
+<- { "return": [ { "state": false, "capability": "xbzrle" } ] }
+
+query-balloon
+-------------
+
+Show balloon information.
+
+Make an asynchronous request for balloon info. When the request completes a
+json-object will be returned containing the following data:
+
+- "actual": current balloon value in bytes (json-int)
+
+Example:
+
+-> { "execute": "query-balloon" }
+<- {
+      "return":{
+         "actual":1073741824,
+      }
+   }
+
+query-tpm
+---------
+
+Return information about the TPM device.
+
+Arguments: None
+
+Example:
+
+-> { "execute": "query-tpm" }
+<- { "return":
+     [
+       { "model": "tpm-tis",
+         "options":
+           { "type": "passthrough",
+             "data":
+               { "cancel-path": "/sys/class/misc/tpm0/device/cancel",
+                 "path": "/dev/tpm0"
+               }
+           },
+         "id": "tpm0"
+       }
+     ]
+   }
+
+query-tpm-models
+----------------
+
+Return a list of supported TPM models.
+
+Arguments: None
+
+Example:
+
+-> { "execute": "query-tpm-models" }
+<- { "return": [ "tpm-tis" ] }
+
+query-tpm-types
+---------------
+
+Return a list of supported TPM types.
+
+Arguments: None
+
+Example:
+
+-> { "execute": "query-tpm-types" }
+<- { "return": [ "passthrough" ] }
+
+chardev-add
+----------------
+
+Add a chardev.
+
+Arguments:
+
+- "id": the chardev's ID, must be unique (json-string)
+- "backend": chardev backend type + parameters
+
+Examples:
+
+-> { "execute" : "chardev-add",
+     "arguments" : { "id" : "foo",
+                     "backend" : { "type" : "null", "data" : {} } } }
+<- { "return": {} }
+
+-> { "execute" : "chardev-add",
+     "arguments" : { "id" : "bar",
+                     "backend" : { "type" : "file",
+                                   "data" : { "out" : "/tmp/bar.log" } } } }
+<- { "return": {} }
+
+-> { "execute" : "chardev-add",
+     "arguments" : { "id" : "baz",
+                     "backend" : { "type" : "pty", "data" : {} } } }
+<- { "return": { "pty" : "/dev/pty/42" } }
+
+chardev-remove
+--------------
+
+Remove a chardev.
+
+Arguments:
+
+- "id": the chardev's ID, must exist and not be in use (json-string)
+
+Example:
+
+-> { "execute": "chardev-remove", "arguments": { "id" : "foo" } }
+<- { "return": {} }
+
+query-rx-filter
+---------------
+
+Show rx-filter information.
+
+Returns a json-array of rx-filter information for all NICs (or for the
+given NIC), returning an error if the given NIC doesn't exist, or
+given NIC doesn't support rx-filter querying, or given net client
+isn't a NIC.
+
+The query will clear the event notification flag of each NIC, then qemu
+will start to emit event to QMP monitor.
+
+Each array entry contains the following:
+
+- "name": net client name (json-string)
+- "promiscuous": promiscuous mode is enabled (json-bool)
+- "multicast": multicast receive state (one of 'normal', 'none', 'all')
+- "unicast": unicast receive state  (one of 'normal', 'none', 'all')
+- "vlan": vlan receive state (one of 'normal', 'none', 'all') (Since 2.0)
+- "broadcast-allowed": allow to receive broadcast (json-bool)
+- "multicast-overflow": multicast table is overflowed (json-bool)
+- "unicast-overflow": unicast table is overflowed (json-bool)
+- "main-mac": main macaddr string (json-string)
+- "vlan-table": a json-array of active vlan id
+- "unicast-table": a json-array of unicast macaddr string
+- "multicast-table": a json-array of multicast macaddr string
+
+Example:
+
+-> { "execute": "query-rx-filter", "arguments": { "name": "vnet0" } }
+<- { "return": [
+        {
+            "promiscuous": true,
+            "name": "vnet0",
+            "main-mac": "52:54:00:12:34:56",
+            "unicast": "normal",
+            "vlan": "normal",
+            "vlan-table": [
+                4,
+                0
+            ],
+            "unicast-table": [
+            ],
+            "multicast": "normal",
+            "multicast-overflow": false,
+            "unicast-overflow": false,
+            "multicast-table": [
+                "01:00:5e:00:00:01",
+                "33:33:00:00:00:01",
+                "33:33:ff:12:34:56"
+            ],
+            "broadcast-allowed": false
+        }
+      ]
+   }
+
+blockdev-add
+------------
+
+Add a block device.
+
+This command is still a work in progress.  It doesn't support all
+block drivers, it lacks a matching blockdev-del, and more.  Stay away
+from it unless you want to help with its development.
+
+Arguments:
+
+- "options": block driver options
+
+Example (1):
+
+-> { "execute": "blockdev-add",
+    "arguments": { "options" : { "driver": "qcow2",
+                                 "file": { "driver": "file",
+                                           "filename": "test.qcow2" } } } }
+<- { "return": {} }
+
+Example (2):
+
+-> { "execute": "blockdev-add",
+     "arguments": {
+         "options": {
+           "driver": "qcow2",
+           "id": "my_disk",
+           "discard": "unmap",
+           "cache": {
+               "direct": true,
+               "writeback": true
+           },
+           "file": {
+               "driver": "file",
+               "filename": "/tmp/test.qcow2"
+           },
+           "backing": {
+               "driver": "raw",
+               "file": {
+                   "driver": "file",
+                   "filename": "/dev/fdset/4"
+               }
+           }
+         }
+       }
+     }
+
+<- { "return": {} }
+
+@query-named-block-nodes
+------------------------
+
+Return a list of BlockDeviceInfo for all the named block driver nodes
+
+Example:
+
+-> { "execute": "query-named-block-nodes" }
+<- { "return": [ { "ro":false,
+                   "drv":"qcow2",
+                   "encrypted":false,
+                   "file":"disks/test.qcow2",
+                   "node-name": "my-node",
+                   "backing_file_depth":1,
+                   "bps":1000000,
+                   "bps_rd":0,
+                   "bps_wr":0,
+                   "iops":1000000,
+                   "iops_rd":0,
+                   "iops_wr":0,
+                   "bps_max": 8000000,
+                   "bps_rd_max": 0,
+                   "bps_wr_max": 0,
+                   "iops_max": 0,
+                   "iops_rd_max": 0,
+                   "iops_wr_max": 0,
+                   "iops_size": 0,
+                   "write_threshold": 0,
+                   "image":{
+                      "filename":"disks/test.qcow2",
+                      "format":"qcow2",
+                      "virtual-size":2048000,
+                      "backing_file":"base.qcow2",
+                      "full-backing-filename":"disks/base.qcow2",
+                      "backing-filename-format:"qcow2",
+                      "snapshots":[
+                         {
+                            "id": "1",
+                            "name": "snapshot1",
+                            "vm-state-size": 0,
+                            "date-sec": 10000200,
+                            "date-nsec": 12,
+                            "vm-clock-sec": 206,
+                            "vm-clock-nsec": 30
+                         }
+                      ],
+                      "backing-image":{
+                          "filename":"disks/base.qcow2",
+                          "format":"qcow2",
+                          "virtual-size":2048000
+                      }
+                   } } ] }
+
+query-memdev
+------------
+
+Show memory devices information.
+
+
+Example (1):
+
+-> { "execute": "query-memdev" }
+<- { "return": [
+       {
+         "size": 536870912,
+         "merge": false,
+         "dump": true,
+         "prealloc": false,
+         "host-nodes": [0, 1],
+         "policy": "bind"
+       },
+       {
+         "size": 536870912,
+         "merge": false,
+         "dump": true,
+         "prealloc": true,
+         "host-nodes": [2, 3],
+         "policy": "preferred"
+       }
+     ]
+   }
+
+@query-memory-devices
+--------------------
+
+Return a list of memory devices.
+
+Example:
+-> { "execute": "query-memory-devices" }
+<- { "return": [ { "data":
+                      { "addr": 5368709120,
+                        "hotpluggable": true,
+                        "hotplugged": true,
+                        "id": "d1",
+                        "memdev": "/objects/memX",
+                        "node": 0,
+                        "size": 1073741824,
+                        "slot": 0},
+                   "type": "dimm"
+                 } ] }
+@query-acpi-ospm-status
+--------------------
+
+Return list of ACPIOSTInfo for devices that support status reporting
+via ACPI _OST method.
+
+Example:
+-> { "execute": "query-acpi-ospm-status" }
+<- { "return": [ { "device": "d1", "slot": "0", "slot-type": "DIMM", "source": 1, "status": 0},
+                 { "slot": "1", "slot-type": "DIMM", "source": 0, "status": 0},
+                 { "slot": "2", "slot-type": "DIMM", "source": 0, "status": 0},
+                 { "slot": "3", "slot-type": "DIMM", "source": 0, "status": 0}
+   ]}
+rtc-reset-reinjection
+---------------------
+
+Reset the RTC interrupt reinjection backlog.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "rtc-reset-reinjection" }
+<- { "return": {} }
+trace-event-get-state
+---------------------
+
+Query the state of events.
+
+Example:
+
+-> { "execute": "trace-event-get-state", "arguments": { "name": "qemu_memalign" } }
+<- { "return": [ { "name": "qemu_memalign", "state": "disabled" } ] }
+trace-event-set-state
+---------------------
+
+Set the state of events.
+
+Example:
+
+-> { "execute": "trace-event-set-state", "arguments": { "name": "qemu_memalign", "enable": "true" } }
+<- { "return": {} }
+@x-input-send-event
+-----------------
+
+Send input event to guest.
+
+Arguments:
+
+- "console": console index. (json-int, optional)
+- "events": list of input events.
+
+The consoles are visible in the qom tree, under
+/backend/console[$index]. They have a device link and head property, so
+it is possible to map which console belongs to which device and display.
+
+Note: this command is experimental, and not a stable API.
+
+Example (1):
+
+Press left mouse button.
+
+-> { "execute": "x-input-send-event",
+    "arguments": { "console": 0,
+                   "events": [ { "type": "btn",
+                    "data" : { "down": true, "button": "Left" } } ] } }
+<- { "return": {} }
+
+-> { "execute": "x-input-send-event",
+    "arguments": { "console": 0,
+                   "events": [ { "type": "btn",
+                    "data" : { "down": false, "button": "Left" } } ] } }
+<- { "return": {} }
+
+Example (2):
+
+Press ctrl-alt-del.
+
+-> { "execute": "x-input-send-event",
+     "arguments": { "console": 0, "events": [
+        { "type": "key", "data" : { "down": true,
+          "key": {"type": "qcode", "data": "ctrl" } } },
+        { "type": "key", "data" : { "down": true,
+          "key": {"type": "qcode", "data": "alt" } } },
+        { "type": "key", "data" : { "down": true,
+          "key": {"type": "qcode", "data": "delete" } } } ] } }
+<- { "return": {} }
+
+Example (3):
+
+Move mouse pointer to absolute coordinates (20000, 400).
+
+-> { "execute": "x-input-send-event" ,
+  "arguments": { "console": 0, "events": [
+               { "type": "abs", "data" : { "axis": "X", "value" : 20000 } },
+               { "type": "abs", "data" : { "axis": "Y", "value" : 400 } } ] } }
+<- { "return": {} }
+
+block-set-write-threshold
+------------
+
+Change the write threshold for a block drive. The threshold is an offset,
+thus must be non-negative. Default is no write threshold.
+Setting the threshold to zero disables it.
+
+Arguments:
+
+- "node-name": the node name in the block driver state graph (json-string)
+- "write-threshold": the write threshold in bytes (json-int)
+
+Example:
+
+-> { "execute": "block-set-write-threshold",
+  "arguments": { "node-name": "mydev",
+                 "write-threshold": 17179869184 } }
+<- { "return": {} }
+
diff --git a/qemu/share/locale/de_DE/LC_MESSAGES/qemu.mo b/qemu/share/locale/de_DE/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..af858b6
Binary files /dev/null and b/qemu/share/locale/de_DE/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/locale/fr_FR/LC_MESSAGES/qemu.mo b/qemu/share/locale/fr_FR/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..05ada3f
Binary files /dev/null and b/qemu/share/locale/fr_FR/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/locale/hu/LC_MESSAGES/qemu.mo b/qemu/share/locale/hu/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..3a070b5
Binary files /dev/null and b/qemu/share/locale/hu/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/locale/it/LC_MESSAGES/qemu.mo b/qemu/share/locale/it/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..9ef4a06
Binary files /dev/null and b/qemu/share/locale/it/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/locale/tr/LC_MESSAGES/qemu.mo b/qemu/share/locale/tr/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..7808274
Binary files /dev/null and b/qemu/share/locale/tr/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/locale/zh_CN/LC_MESSAGES/qemu.mo b/qemu/share/locale/zh_CN/LC_MESSAGES/qemu.mo
new file mode 100644
index 0000000..198282b
Binary files /dev/null and b/qemu/share/locale/zh_CN/LC_MESSAGES/qemu.mo differ
diff --git a/qemu/share/man/man1/qemu-img.1 b/qemu/share/man/man1/qemu-img.1
new file mode 100644
index 0000000..d6036c5
--- /dev/null
+++ b/qemu/share/man/man1/qemu-img.1
@@ -0,0 +1,666 @@
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+.    ds C`
+.    ds C'
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
+..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
+.\}
+.rr rF
+.\" ========================================================================
+.\"
+.IX Title "QEMU-IMG 1"
+.TH QEMU-IMG 1 "2018-02-24" " " " "
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+qemu\-img \- QEMU disk image utility
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+usage: qemu-img command [command options]
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+qemu-img allows you to create, convert and modify images offline. It can handle
+all image formats supported by \s-1QEMU.\s0
+.PP
+\&\fBWarning:\fR Never use qemu-img to modify images in use by a running virtual
+machine or any other process; this may destroy the image. Also, be aware that
+querying an image that is being modified by another process may encounter
+inconsistent state.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+The following commands are supported:
+.IP "\fBcheck [\-q] [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-r [leaks | all]] [\-T\fR \fIsrc_cache\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "check [-q] [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T src_cache] filename"
+.PD 0
+.IP "\fBcreate [\-q] [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
+.IX Item "create [-q] [-f fmt] [-o options] filename [size]"
+.IP "\fBcommit [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-b\fR \fIbase\fR\fB] [\-d] [\-p]\fR \fIfilename\fR" 4
+.IX Item "commit [-q] [-f fmt] [-t cache] [-b base] [-d] [-p] filename"
+.IP "\fBcompare [\-f\fR \fIfmt\fR\fB] [\-F\fR \fIfmt\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-p] [\-q] [\-s]\fR \fIfilename1\fR\fB \fR\fIfilename2\fR" 4
+.IX Item "compare [-f fmt] [-F fmt] [-T src_cache] [-p] [-q] [-s] filename1 filename2"
+.IP "\fBconvert [\-c] [\-p] [\-q] [\-n] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_id_or_name\fR\fB] [\-l\fR \fIsnapshot_param\fR\fB] [\-S\fR \fIsparse_size\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
+.IX Item "convert [-c] [-p] [-q] [-n] [-f fmt] [-t cache] [-T src_cache] [-O output_fmt] [-o options] [-s snapshot_id_or_name] [-l snapshot_param] [-S sparse_size] filename [filename2 [...]] output_filename"
+.IP "\fBinfo [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-\-backing\-chain]\fR \fIfilename\fR" 4
+.IX Item "info [-f fmt] [--output=ofmt] [--backing-chain] filename"
+.IP "\fBmap [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "map [-f fmt] [--output=ofmt] filename"
+.IP "\fBsnapshot [\-q] [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "snapshot [-q] [-l | -a snapshot | -c snapshot | -d snapshot] filename"
+.IP "\fBrebase [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-p] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "rebase [-q] [-f fmt] [-t cache] [-T src_cache] [-p] [-u] -b backing_file [-F backing_fmt] filename"
+.IP "\fBresize [\-q]\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
+.IX Item "resize [-q] filename [+ | -]size"
+.IP "\fBamend [\-p] [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] \-o\fR \fIoptions\fR\fB \fR\fIfilename\fR" 4
+.IX Item "amend [-p] [-q] [-f fmt] [-t cache] -o options filename"
+.PD
+.PP
+Command parameters:
+.IP "\fIfilename\fR" 4
+.IX Item "filename"
+.Vb 1
+\& is a disk image filename
+.Ve
+.IP "\fIfmt\fR" 4
+.IX Item "fmt"
+is the disk image format. It is guessed automatically in most cases. See below
+for a description of the supported disk formats.
+.IP "\fI\-\-backing\-chain\fR" 4
+.IX Item "--backing-chain"
+will enumerate information about backing files in a disk image chain. Refer
+below for further description.
+.IP "\fIsize\fR" 4
+.IX Item "size"
+is the disk image size in bytes. Optional suffixes \f(CW\*(C`k\*(C'\fR or \f(CW\*(C`K\*(C'\fR
+(kilobyte, 1024) \f(CW\*(C`M\*(C'\fR (megabyte, 1024k) and \f(CW\*(C`G\*(C'\fR (gigabyte, 1024M)
+and T (terabyte, 1024G) are supported.  \f(CW\*(C`b\*(C'\fR is ignored.
+.IP "\fIoutput_filename\fR" 4
+.IX Item "output_filename"
+is the destination disk image filename
+.IP "\fIoutput_fmt\fR" 4
+.IX Item "output_fmt"
+.Vb 1
+\& is the destination format
+.Ve
+.IP "\fIoptions\fR" 4
+.IX Item "options"
+is a comma separated list of format specific options in a
+name=value format. Use \f(CW\*(C`\-o ?\*(C'\fR for an overview of the options supported
+by the used format or see the format descriptions below for details.
+.IP "\fIsnapshot_param\fR" 4
+.IX Item "snapshot_param"
+is param used for internal snapshot, format is
+\&'snapshot.id=[\s-1ID\s0],snapshot.name=[\s-1NAME\s0]' or '[\s-1ID_OR_NAME\s0]'
+.IP "\fIsnapshot_id_or_name\fR" 4
+.IX Item "snapshot_id_or_name"
+is deprecated, use snapshot_param instead
+.IP "\fI\-c\fR" 4
+.IX Item "-c"
+indicates that target image must be compressed (qcow format only)
+.IP "\fI\-h\fR" 4
+.IX Item "-h"
+with or without a command shows help and lists the supported formats
+.IP "\fI\-p\fR" 4
+.IX Item "-p"
+display progress bar (compare, convert and rebase commands only).
+If the \fI\-p\fR option is not used for a command that supports it, the
+progress is reported when the process receives a \f(CW\*(C`SIGUSR1\*(C'\fR signal.
+.IP "\fI\-q\fR" 4
+.IX Item "-q"
+Quiet mode \- do not print any output (except errors). There's no progress bar
+in case both \fI\-q\fR and \fI\-p\fR options are used.
+.IP "\fI\-S\fR \fIsize\fR" 4
+.IX Item "-S size"
+indicates the consecutive number of bytes that must contain only zeros
+for qemu-img to create a sparse image during conversion. This value is rounded
+down to the nearest 512 bytes. You may use the common size suffixes like
+\&\f(CW\*(C`k\*(C'\fR for kilobytes.
+.IP "\fI\-t\fR \fIcache\fR" 4
+.IX Item "-t cache"
+specifies the cache mode that should be used with the (destination) file. See
+the documentation of the emulator's \f(CW\*(C`\-drive cache=...\*(C'\fR option for allowed
+values.
+.IP "\fI\-T\fR \fIsrc_cache\fR" 4
+.IX Item "-T src_cache"
+specifies the cache mode that should be used with the source file(s). See
+the documentation of the emulator's \f(CW\*(C`\-drive cache=...\*(C'\fR option for allowed
+values.
+.PP
+Parameters to snapshot subcommand:
+.IP "\fBsnapshot\fR" 4
+.IX Item "snapshot"
+is the name of the snapshot to create, apply or delete
+.IP "\fB\-a\fR" 4
+.IX Item "-a"
+applies a snapshot (revert disk to saved state)
+.IP "\fB\-c\fR" 4
+.IX Item "-c"
+creates a snapshot
+.IP "\fB\-d\fR" 4
+.IX Item "-d"
+deletes a snapshot
+.IP "\fB\-l\fR" 4
+.IX Item "-l"
+lists all snapshots in the given image
+.PP
+Parameters to compare subcommand:
+.IP "\fB\-f\fR" 4
+.IX Item "-f"
+First image format
+.IP "\fB\-F\fR" 4
+.IX Item "-F"
+Second image format
+.IP "\fB\-s\fR" 4
+.IX Item "-s"
+Strict mode \- fail on on different image size or sector allocation
+.PP
+Parameters to convert subcommand:
+.IP "\fB\-n\fR" 4
+.IX Item "-n"
+Skip the creation of the target volume
+.PP
+Command description:
+.IP "\fBcheck [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-r [leaks | all]] [\-T\fR \fIsrc_cache\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "check [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T src_cache] filename"
+Perform a consistency check on the disk image \fIfilename\fR. The command can
+output in the format \fIofmt\fR which is either \f(CW\*(C`human\*(C'\fR or \f(CW\*(C`json\*(C'\fR.
+.Sp
+If \f(CW\*(C`\-r\*(C'\fR is specified, qemu-img tries to repair any inconsistencies found
+during the check. \f(CW\*(C`\-r leaks\*(C'\fR repairs only cluster leaks, whereas
+\&\f(CW\*(C`\-r all\*(C'\fR fixes all kinds of errors, with a higher risk of choosing the
+wrong fix or hiding corruption that has already occurred.
+.Sp
+Only the formats \f(CW\*(C`qcow2\*(C'\fR, \f(CW\*(C`qed\*(C'\fR and \f(CW\*(C`vdi\*(C'\fR support
+consistency checks.
+.Sp
+In case the image does not have any inconsistencies, check exits with \f(CW0\fR.
+Other exit codes indicate the kind of inconsistency found or if another error
+occurred. The following table summarizes all exit codes of the check subcommand:
+.RS 4
+.IP "\fB0\fR" 4
+.IX Item "0"
+Check completed, the image is (now) consistent
+.IP "\fB1\fR" 4
+.IX Item "1"
+Check not completed because of internal errors
+.IP "\fB2\fR" 4
+.IX Item "2"
+Check completed, image is corrupted
+.IP "\fB3\fR" 4
+.IX Item "3"
+Check completed, image has leaked clusters, but is not corrupted
+.IP "\fB63\fR" 4
+.IX Item "63"
+Checks are not supported by the image format
+.RE
+.RS 4
+.Sp
+If \f(CW\*(C`\-r\*(C'\fR is specified, exit codes representing the image state refer to the
+state after (the attempt at) repairing it. That is, a successful \f(CW\*(C`\-r all\*(C'\fR
+will yield the exit code 0, independently of the image state before.
+.RE
+.IP "\fBcreate [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
+.IX Item "create [-f fmt] [-o options] filename [size]"
+Create the new disk image \fIfilename\fR of size \fIsize\fR and format
+\&\fIfmt\fR. Depending on the file format, you can add one or more \fIoptions\fR
+that enable additional features of this format.
+.Sp
+If the option \fIbacking_file\fR is specified, then the image will record
+only the differences from \fIbacking_file\fR. No size needs to be specified in
+this case. \fIbacking_file\fR will never be modified unless you use the
+\&\f(CW\*(C`commit\*(C'\fR monitor command (or qemu-img commit).
+.Sp
+The size can also be specified using the \fIsize\fR option with \f(CW\*(C`\-o\*(C'\fR,
+it doesn't need to be specified separately in this case.
+.IP "\fBcommit [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-b\fR \fIbase\fR\fB] [\-d] [\-p]\fR \fIfilename\fR" 4
+.IX Item "commit [-q] [-f fmt] [-t cache] [-b base] [-d] [-p] filename"
+Commit the changes recorded in \fIfilename\fR in its base image or backing file.
+If the backing file is smaller than the snapshot, then the backing file will be
+resized to be the same size as the snapshot.  If the snapshot is smaller than
+the backing file, the backing file will not be truncated.  If you want the
+backing file to match the size of the smaller snapshot, you can safely truncate
+it yourself once the commit operation successfully completes.
+.Sp
+The image \fIfilename\fR is emptied after the operation has succeeded. If you do
+not need \fIfilename\fR afterwards and intend to drop it, you may skip emptying
+\&\fIfilename\fR by specifying the \f(CW\*(C`\-d\*(C'\fR flag.
+.Sp
+If the backing chain of the given image file \fIfilename\fR has more than one
+layer, the backing file into which the changes will be committed may be
+specified as \fIbase\fR (which has to be part of \fIfilename\fR's backing
+chain). If \fIbase\fR is not specified, the immediate backing file of the top
+image (which is \fIfilename\fR) will be used. For reasons of consistency,
+explicitly specifying \fIbase\fR will always imply \f(CW\*(C`\-d\*(C'\fR (since emptying an
+image after committing to an indirect backing file would lead to different data
+being read from the image due to content in the intermediate backing chain
+overruling the commit target).
+.IP "\fBcompare [\-f\fR \fIfmt\fR\fB] [\-F\fR \fIfmt\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-p] [\-s] [\-q]\fR \fIfilename1\fR\fB \fR\fIfilename2\fR" 4
+.IX Item "compare [-f fmt] [-F fmt] [-T src_cache] [-p] [-s] [-q] filename1 filename2"
+Check if two images have the same content. You can compare images with
+different format or settings.
+.Sp
+The format is probed unless you specify it by \fI\-f\fR (used for
+\&\fIfilename1\fR) and/or \fI\-F\fR (used for \fIfilename2\fR) option.
+.Sp
+By default, images with different size are considered identical if the larger
+image contains only unallocated and/or zeroed sectors in the area after the end
+of the other image. In addition, if any sector is not allocated in one image
+and contains only zero bytes in the second one, it is evaluated as equal. You
+can use Strict mode by specifying the \fI\-s\fR option. When compare runs in
+Strict mode, it fails in case image size differs or a sector is allocated in
+one image and is not allocated in the second one.
+.Sp
+By default, compare prints out a result message. This message displays
+information that both images are same or the position of the first different
+byte. In addition, result message can report different image size in case
+Strict mode is used.
+.Sp
+Compare exits with \f(CW0\fR in case the images are equal and with \f(CW1\fR
+in case the images differ. Other exit codes mean an error occurred during
+execution and standard error output should contain an error message.
+The following table sumarizes all exit codes of the compare subcommand:
+.RS 4
+.IP "\fB0\fR" 4
+.IX Item "0"
+Images are identical
+.IP "\fB1\fR" 4
+.IX Item "1"
+Images differ
+.IP "\fB2\fR" 4
+.IX Item "2"
+Error on opening an image
+.IP "\fB3\fR" 4
+.IX Item "3"
+Error on checking a sector allocation
+.IP "\fB4\fR" 4
+.IX Item "4"
+Error on reading data
+.RE
+.RS 4
+.RE
+.IP "\fBconvert [\-c] [\-p] [\-n] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_id_or_name\fR\fB] [\-l\fR \fIsnapshot_param\fR\fB] [\-S\fR \fIsparse_size\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
+.IX Item "convert [-c] [-p] [-n] [-f fmt] [-t cache] [-T src_cache] [-O output_fmt] [-o options] [-s snapshot_id_or_name] [-l snapshot_param] [-S sparse_size] filename [filename2 [...]] output_filename"
+Convert the disk image \fIfilename\fR or a snapshot \fIsnapshot_param\fR(\fIsnapshot_id_or_name\fR is deprecated)
+to disk image \fIoutput_filename\fR using format \fIoutput_fmt\fR. It can be optionally compressed (\f(CW\*(C`\-c\*(C'\fR
+option) or use any format specific options like encryption (\f(CW\*(C`\-o\*(C'\fR option).
+.Sp
+Only the formats \f(CW\*(C`qcow\*(C'\fR and \f(CW\*(C`qcow2\*(C'\fR support compression. The
+compression is read-only. It means that if a compressed sector is
+rewritten, then it is rewritten as uncompressed data.
+.Sp
+Image conversion is also useful to get smaller image when using a
+growable format such as \f(CW\*(C`qcow\*(C'\fR: the empty sectors are detected and
+suppressed from the destination image.
+.Sp
+\&\fIsparse_size\fR indicates the consecutive number of bytes (defaults to 4k)
+that must contain only zeros for qemu-img to create a sparse image during
+conversion. If \fIsparse_size\fR is 0, the source will not be scanned for
+unallocated or zero sectors, and the destination image will always be
+fully allocated.
+.Sp
+You can use the \fIbacking_file\fR option to force the output image to be
+created as a copy on write image of the specified base image; the
+\&\fIbacking_file\fR should have the same content as the input's base image,
+however the path, image format, etc may differ.
+.Sp
+If the \f(CW\*(C`\-n\*(C'\fR option is specified, the target volume creation will be
+skipped. This is useful for formats such as \f(CW\*(C`rbd\*(C'\fR if the target
+volume has already been created with site specific options that cannot
+be supplied through qemu-img.
+.IP "\fBinfo [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-\-backing\-chain]\fR \fIfilename\fR" 4
+.IX Item "info [-f fmt] [--output=ofmt] [--backing-chain] filename"
+Give information about the disk image \fIfilename\fR. Use it in
+particular to know the size reserved on disk which can be different
+from the displayed size. If \s-1VM\s0 snapshots are stored in the disk image,
+they are displayed too. The command can output in the format \fIofmt\fR
+which is either \f(CW\*(C`human\*(C'\fR or \f(CW\*(C`json\*(C'\fR.
+.Sp
+If a disk image has a backing file chain, information about each disk image in
+the chain can be recursively enumerated by using the option \f(CW\*(C`\-\-backing\-chain\*(C'\fR.
+.Sp
+For instance, if you have an image chain like:
+.Sp
+.Vb 1
+\&        base.qcow2 <\- snap1.qcow2 <\- snap2.qcow2
+.Ve
+.Sp
+To enumerate information about each disk image in the above chain, starting from top to base, do:
+.Sp
+.Vb 1
+\&        qemu\-img info \-\-backing\-chain snap2.qcow2
+.Ve
+.IP "\fBmap [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "map [-f fmt] [--output=ofmt] filename"
+Dump the metadata of image \fIfilename\fR and its backing file chain.
+In particular, this commands dumps the allocation state of every sector
+of \fIfilename\fR, together with the topmost file that allocates it in
+the backing file chain.
+.Sp
+Two option formats are possible.  The default format (\f(CW\*(C`human\*(C'\fR)
+only dumps known-nonzero areas of the file.  Known-zero parts of the
+file are omitted altogether, and likewise for parts that are not allocated
+throughout the chain.  \fBqemu-img\fR output will identify a file
+from where the data can be read, and the offset in the file.  Each line
+will include four fields, the first three of which are hexadecimal
+numbers.  For example the first line of:
+.Sp
+.Vb 3
+\&        Offset          Length          Mapped to       File
+\&        0               0x20000         0x50000         /tmp/overlay.qcow2
+\&        0x100000        0x10000         0x95380000      /tmp/backing.qcow2
+.Ve
+.Sp
+means that 0x20000 (131072) bytes starting at offset 0 in the image are
+available in /tmp/overlay.qcow2 (opened in \f(CW\*(C`raw\*(C'\fR format) starting
+at offset 0x50000 (327680).  Data that is compressed, encrypted, or
+otherwise not available in raw format will cause an error if \f(CW\*(C`human\*(C'\fR
+format is in use.  Note that file names can include newlines, thus it is
+not safe to parse this output format in scripts.
+.Sp
+The alternative format \f(CW\*(C`json\*(C'\fR will return an array of dictionaries
+in \s-1JSON\s0 format.  It will include similar information in
+the \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`length\*(C'\fR, \f(CW\*(C`offset\*(C'\fR fields;
+it will also include other more specific information:
+.RS 4
+.IP "\-" 4
+whether the sectors contain actual data or not (boolean field \f(CW\*(C`data\*(C'\fR;
+if false, the sectors are either unallocated or stored as optimized
+all-zero clusters);
+.IP "\-" 4
+whether the data is known to read as zero (boolean field \f(CW\*(C`zero\*(C'\fR);
+.IP "\-" 4
+in order to make the output shorter, the target file is expressed as
+a \f(CW\*(C`depth\*(C'\fR; for example, a depth of 2 refers to the backing file
+of the backing file of \fIfilename\fR.
+.RE
+.RS 4
+.Sp
+In \s-1JSON\s0 format, the \f(CW\*(C`offset\*(C'\fR field is optional; it is absent in
+cases where \f(CW\*(C`human\*(C'\fR format would omit the entry or exit with an error.
+If \f(CW\*(C`data\*(C'\fR is false and the \f(CW\*(C`offset\*(C'\fR field is present, the
+corresponding sectors in the file are not yet in use, but they are
+preallocated.
+.Sp
+For more information, consult \fIinclude/block/block.h\fR in \s-1QEMU\s0's
+source code.
+.RE
+.IP "\fBsnapshot [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR \fB]\fR \fIfilename\fR" 4
+.IX Item "snapshot [-l | -a snapshot | -c snapshot | -d snapshot ] filename"
+List, apply, create or delete snapshots in image \fIfilename\fR.
+.IP "\fBrebase [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-T\fR \fIsrc_cache\fR\fB] [\-p] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "rebase [-f fmt] [-t cache] [-T src_cache] [-p] [-u] -b backing_file [-F backing_fmt] filename"
+Changes the backing file of an image. Only the formats \f(CW\*(C`qcow2\*(C'\fR and
+\&\f(CW\*(C`qed\*(C'\fR support changing the backing file.
+.Sp
+The backing file is changed to \fIbacking_file\fR and (if the image format of
+\&\fIfilename\fR supports this) the backing file format is changed to
+\&\fIbacking_fmt\fR. If \fIbacking_file\fR is specified as "" (the empty
+string), then the image is rebased onto no backing file (i.e. it will exist
+independently of any backing file).
+.Sp
+\&\fIcache\fR specifies the cache mode to be used for \fIfilename\fR, whereas
+\&\fIsrc_cache\fR specifies the cache mode for reading backing files.
+.Sp
+There are two different modes in which \f(CW\*(C`rebase\*(C'\fR can operate:
+.RS 4
+.IP "\fBSafe mode\fR" 4
+.IX Item "Safe mode"
+This is the default mode and performs a real rebase operation. The new backing
+file may differ from the old one and qemu-img rebase will take care of keeping
+the guest-visible content of \fIfilename\fR unchanged.
+.Sp
+In order to achieve this, any clusters that differ between \fIbacking_file\fR
+and the old backing file of \fIfilename\fR are merged into \fIfilename\fR
+before actually changing the backing file.
+.Sp
+Note that the safe mode is an expensive operation, comparable to converting
+an image. It only works if the old backing file still exists.
+.IP "\fBUnsafe mode\fR" 4
+.IX Item "Unsafe mode"
+qemu-img uses the unsafe mode if \f(CW\*(C`\-u\*(C'\fR is specified. In this mode, only the
+backing file name and format of \fIfilename\fR is changed without any checks
+on the file contents. The user must take care of specifying the correct new
+backing file, or the guest-visible content of the image will be corrupted.
+.Sp
+This mode is useful for renaming or moving the backing file to somewhere else.
+It can be used without an accessible old backing file, i.e. you can use it to
+fix an image whose backing file has already been moved/renamed.
+.RE
+.RS 4
+.Sp
+You can use \f(CW\*(C`rebase\*(C'\fR to perform a \*(L"diff\*(R" operation on two
+disk images.  This can be useful when you have copied or cloned
+a guest, and you want to get back to a thin image on top of a
+template or base image.
+.Sp
+Say that \f(CW\*(C`base.img\*(C'\fR has been cloned as \f(CW\*(C`modified.img\*(C'\fR by
+copying it, and that the \f(CW\*(C`modified.img\*(C'\fR guest has run so there
+are now some changes compared to \f(CW\*(C`base.img\*(C'\fR.  To construct a thin
+image called \f(CW\*(C`diff.qcow2\*(C'\fR that contains just the differences, do:
+.Sp
+.Vb 2
+\&        qemu\-img create \-f qcow2 \-b modified.img diff.qcow2
+\&        qemu\-img rebase \-b base.img diff.qcow2
+.Ve
+.Sp
+At this point, \f(CW\*(C`modified.img\*(C'\fR can be discarded, since
+\&\f(CW\*(C`base.img + diff.qcow2\*(C'\fR contains the same information.
+.RE
+.IP "\fBresize\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
+.IX Item "resize filename [+ | -]size"
+Change the disk image as if it had been created with \fIsize\fR.
+.Sp
+Before using this command to shrink a disk image, you \s-1MUST\s0 use file system and
+partitioning tools inside the \s-1VM\s0 to reduce allocated file systems and partition
+sizes accordingly.  Failure to do so will result in data loss!
+.Sp
+After using this command to grow a disk image, you must use file system and
+partitioning tools inside the \s-1VM\s0 to actually begin using the new space on the
+device.
+.IP "\fBamend [\-p] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] \-o\fR \fIoptions\fR\fB \fR\fIfilename\fR" 4
+.IX Item "amend [-p] [-f fmt] [-t cache] -o options filename"
+Amends the image format specific \fIoptions\fR for the image file
+\&\fIfilename\fR. Not all file formats support this operation.
+.SH "NOTES"
+.IX Header "NOTES"
+Supported image file formats:
+.IP "\fBraw\fR" 4
+.IX Item "raw"
+Raw disk image format (default). This format has the advantage of
+being simple and easily exportable to all other emulators. If your
+file system supports \fIholes\fR (for example in ext2 or ext3 on
+Linux or \s-1NTFS\s0 on Windows), then only the written sectors will reserve
+space. Use \f(CW\*(C`qemu\-img info\*(C'\fR to know the real size used by the
+image or \f(CW\*(C`ls \-ls\*(C'\fR on Unix/Linux.
+.Sp
+Supported options:
+.RS 4
+.ie n .IP """preallocation""" 4
+.el .IP "\f(CWpreallocation\fR" 4
+.IX Item "preallocation"
+Preallocation mode (allowed values: \f(CW\*(C`off\*(C'\fR, \f(CW\*(C`falloc\*(C'\fR, \f(CW\*(C`full\*(C'\fR).
+\&\f(CW\*(C`falloc\*(C'\fR mode preallocates space for image by calling \fIposix_fallocate()\fR.
+\&\f(CW\*(C`full\*(C'\fR mode preallocates space for image by writing zeros to underlying
+storage.
+.RE
+.RS 4
+.RE
+.IP "\fBqcow2\fR" 4
+.IX Item "qcow2"
+\&\s-1QEMU\s0 image format, the most versatile format. Use it to have smaller
+images (useful if your filesystem does not supports holes, for example
+on Windows), optional \s-1AES\s0 encryption, zlib based compression and
+support of multiple \s-1VM\s0 snapshots.
+.Sp
+Supported options:
+.RS 4
+.ie n .IP """compat""" 4
+.el .IP "\f(CWcompat\fR" 4
+.IX Item "compat"
+Determines the qcow2 version to use. \f(CW\*(C`compat=0.10\*(C'\fR uses the
+traditional image format that can be read by any \s-1QEMU\s0 since 0.10.
+\&\f(CW\*(C`compat=1.1\*(C'\fR enables image format extensions that only \s-1QEMU 1.1\s0 and
+newer understand (this is the default). Amongst others, this includes zero
+clusters, which allow efficient copy-on-read for sparse images.
+.ie n .IP """backing_file""" 4
+.el .IP "\f(CWbacking_file\fR" 4
+.IX Item "backing_file"
+File name of a base image (see \fBcreate\fR subcommand)
+.ie n .IP """backing_fmt""" 4
+.el .IP "\f(CWbacking_fmt\fR" 4
+.IX Item "backing_fmt"
+Image format of the base image
+.ie n .IP """encryption""" 4
+.el .IP "\f(CWencryption\fR" 4
+.IX Item "encryption"
+If this option is set to \f(CW\*(C`on\*(C'\fR, the image is encrypted with 128\-bit AES-CBC.
+.Sp
+The use of encryption in qcow and qcow2 images is considered to be flawed by
+modern cryptography standards, suffering from a number of design problems:
+.RS 4
+.IP "\-<The AES-CBC cipher is used with predictable initialization vectors based>" 4
+.IX Item "-<The AES-CBC cipher is used with predictable initialization vectors based>"
+on the sector number. This makes it vulnerable to chosen plaintext attacks
+which can reveal the existence of encrypted data.
+.IP "\-<The user passphrase is directly used as the encryption key. A poorly>" 4
+.IX Item "-<The user passphrase is directly used as the encryption key. A poorly>"
+chosen or short passphrase will compromise the security of the encryption.
+.IP "\-<In the event of the passphrase being compromised there is no way to>" 4
+.IX Item "-<In the event of the passphrase being compromised there is no way to>"
+change the passphrase to protect data in any qcow images. The files must
+be cloned, using a different encryption passphrase in the new file. The
+original file must then be securely erased using a program like shred,
+though even this is ineffective with many modern storage technologies.
+.RE
+.RS 4
+.Sp
+Use of qcow / qcow2 encryption is thus strongly discouraged. Users are
+recommended to use an alternative encryption technology such as the
+Linux dm-crypt / \s-1LUKS\s0 system.
+.RE
+.ie n .IP """cluster_size""" 4
+.el .IP "\f(CWcluster_size\fR" 4
+.IX Item "cluster_size"
+Changes the qcow2 cluster size (must be between 512 and 2M). Smaller cluster
+sizes can improve the image file size whereas larger cluster sizes generally
+provide better performance.
+.ie n .IP """preallocation""" 4
+.el .IP "\f(CWpreallocation\fR" 4
+.IX Item "preallocation"
+Preallocation mode (allowed values: \f(CW\*(C`off\*(C'\fR, \f(CW\*(C`metadata\*(C'\fR, \f(CW\*(C`falloc\*(C'\fR,
+\&\f(CW\*(C`full\*(C'\fR). An image with preallocated metadata is initially larger but can
+improve performance when the image needs to grow. \f(CW\*(C`falloc\*(C'\fR and \f(CW\*(C`full\*(C'\fR
+preallocations are like the same options of \f(CW\*(C`raw\*(C'\fR format, but sets up
+metadata also.
+.ie n .IP """lazy_refcounts""" 4
+.el .IP "\f(CWlazy_refcounts\fR" 4
+.IX Item "lazy_refcounts"
+If this option is set to \f(CW\*(C`on\*(C'\fR, reference count updates are postponed with
+the goal of avoiding metadata I/O and improving performance. This is
+particularly interesting with \fBcache=writethrough\fR which doesn't batch
+metadata updates. The tradeoff is that after a host crash, the reference count
+tables must be rebuilt, i.e. on the next open an (automatic) \f(CW\*(C`qemu\-img
+check \-r all\*(C'\fR is required, which may take some time.
+.Sp
+This option can only be enabled if \f(CW\*(C`compat=1.1\*(C'\fR is specified.
+.ie n .IP """nocow""" 4
+.el .IP "\f(CWnocow\fR" 4
+.IX Item "nocow"
+If this option is set to \f(CW\*(C`on\*(C'\fR, it will turn off \s-1COW\s0 of the file. It's only
+valid on btrfs, no effect on other file systems.
+.Sp
+Btrfs has low performance when hosting a \s-1VM\s0 image file, even more when the guest
+on the \s-1VM\s0 also using btrfs as file system. Turning off \s-1COW\s0 is a way to mitigate
+this bad performance. Generally there are two ways to turn off \s-1COW\s0 on btrfs:
+a) Disable it by mounting with nodatacow, then all newly created files will be
+\&\s-1NOCOW.\s0 b) For an empty file, add the \s-1NOCOW\s0 file attribute. That's what this option
+does.
+.Sp
+Note: this option is only valid to new or empty files. If there is an existing
+file which is \s-1COW\s0 and has data blocks already, it couldn't be changed to \s-1NOCOW\s0
+by setting \f(CW\*(C`nocow=on\*(C'\fR. One can issue \f(CW\*(C`lsattr filename\*(C'\fR to check if
+the \s-1NOCOW\s0 flag is set or not (Capital 'C' is \s-1NOCOW\s0 flag).
+.RE
+.RS 4
+.RE
+.IP "\fBOther\fR" 4
+.IX Item "Other"
+\&\s-1QEMU\s0 also supports various other image file formats for compatibility with
+older \s-1QEMU\s0 versions or other hypervisors, including \s-1VMDK, VDI, VHD \s0(vpc), \s-1VHDX,\s0
+qcow1 and \s-1QED.\s0 For a full list of supported formats see \f(CW\*(C`qemu\-img \-\-help\*(C'\fR.
+For a more detailed description of these formats, see the \s-1QEMU\s0 Emulation User
+Documentation.
+.Sp
+The main purpose of the block drivers for these formats is image conversion.
+For running VMs, it is recommended to convert the disk images to either raw or
+qcow2 in order to achieve good performance.
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+The \s-1HTML\s0 documentation of \s-1QEMU\s0 for more precise information and Linux
+user mode emulator invocation.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Fabrice Bellard
diff --git a/qemu/share/man/man1/qemu.1 b/qemu/share/man/man1/qemu.1
new file mode 100644
index 0000000..0f70d66
--- /dev/null
+++ b/qemu/share/man/man1/qemu.1
@@ -0,0 +1,2845 @@
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+.    ds C`
+.    ds C'
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
+..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
+.\}
+.rr rF
+.\" ========================================================================
+.\"
+.IX Title "QEMU 1"
+.TH QEMU 1 "2018-02-24" " " " "
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+qemu\-doc \- QEMU Emulator User Documentation
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+usage: qemu\-system\-i386 [options] [\fIdisk_image\fR]
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+The \s-1QEMU PC\s0 System emulator simulates the
+following peripherals:
+.IP "\-" 4
+i440FX host \s-1PCI\s0 bridge and \s-1PIIX3 PCI\s0 to \s-1ISA\s0 bridge
+.IP "\-" 4
+Cirrus \s-1CLGD 5446 PCI VGA\s0 card or dummy \s-1VGA\s0 card with Bochs \s-1VESA\s0
+extensions (hardware level, including all non standard modes).
+.IP "\-" 4
+\&\s-1PS/2\s0 mouse and keyboard
+.IP "\-" 4
+2 \s-1PCI IDE\s0 interfaces with hard disk and CD-ROM support
+.IP "\-" 4
+Floppy disk
+.IP "\-" 4
+\&\s-1PCI\s0 and \s-1ISA\s0 network adapters
+.IP "\-" 4
+Serial ports
+.IP "\-" 4
+Creative SoundBlaster 16 sound card
+.IP "\-" 4
+\&\s-1ENSONIQ\s0 AudioPCI \s-1ES1370\s0 sound card
+.IP "\-" 4
+Intel 82801AA \s-1AC97\s0 Audio compatible sound card
+.IP "\-" 4
+Intel \s-1HD\s0 Audio Controller and \s-1HDA\s0 codec
+.IP "\-" 4
+Adlib (\s-1OPL2\s0) \- Yamaha \s-1YM3812\s0 compatible chip
+.IP "\-" 4
+Gravis Ultrasound \s-1GF1\s0 sound card
+.IP "\-" 4
+\&\s-1CS4231A\s0 compatible sound card
+.IP "\-" 4
+\&\s-1PCI UHCI USB\s0 controller and a virtual \s-1USB\s0 hub.
+.PP
+\&\s-1SMP\s0 is supported with up to 255 CPUs.
+.PP
+\&\s-1QEMU\s0 uses the \s-1PC BIOS\s0 from the Seabios project and the Plex86/Bochs \s-1LGPL
+VGA BIOS.\s0
+.PP
+\&\s-1QEMU\s0 uses \s-1YM3812\s0 emulation by Tatsuyuki Satoh.
+.PP
+\&\s-1QEMU\s0 uses \s-1GUS\s0 emulation (\s-1GUSEMU32\s0 <\fBhttp://www.deinmeister.de/gusemu/\fR>)
+by Tibor \*(L"\s-1TS\*(R"\s0 Schütz.
+.PP
+Note that, by default, \s-1GUS\s0 shares \s-1\fIIRQ\s0\fR\|(7) with parallel ports and so
+\&\s-1QEMU\s0 must be told to not have parallel ports to have working \s-1GUS.\s0
+.PP
+.Vb 1
+\&        qemu\-system\-i386 dos.img \-soundhw gus \-parallel none
+.Ve
+.PP
+Alternatively:
+.PP
+.Vb 1
+\&        qemu\-system\-i386 dos.img \-device gus,irq=5
+.Ve
+.PP
+Or some other unclaimed \s-1IRQ.\s0
+.PP
+\&\s-1CS4231A\s0 is the chip used in Windows Sound System and \s-1GUSMAX\s0 products
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+\&\fIdisk_image\fR is a raw hard disk image for \s-1IDE\s0 hard disk 0. Some
+targets do not need a disk image.
+.PP
+Standard options:
+.IP "\fB\-h\fR" 4
+.IX Item "-h"
+Display help and exit
+.IP "\fB\-version\fR" 4
+.IX Item "-version"
+Display version information and exit
+.IP "\fB\-machine [type=]\fR\fIname\fR\fB[,prop=\fR\fIvalue\fR\fB[,...]]\fR" 4
+.IX Item "-machine [type=]name[,prop=value[,...]]"
+Select the emulated machine by \fIname\fR. Use \f(CW\*(C`\-machine help\*(C'\fR to list
+available machines. Supported machine properties are:
+.RS 4
+.IP "\fBaccel=\fR\fIaccels1\fR\fB[:\fR\fIaccels2\fR\fB[:...]]\fR" 4
+.IX Item "accel=accels1[:accels2[:...]]"
+This is used to enable an accelerator. Depending on the target architecture,
+kvm, xen, or tcg can be available. By default, tcg is used. If there is more
+than one accelerator specified, the next one is used if the previous one fails
+to initialize.
+.IP "\fBkernel_irqchip=on|off\fR" 4
+.IX Item "kernel_irqchip=on|off"
+Enables in-kernel irqchip support for the chosen accelerator when available.
+.IP "\fBvmport=on|off|auto\fR" 4
+.IX Item "vmport=on|off|auto"
+Enables emulation of VMWare \s-1IO\s0 port, for vmmouse etc. auto says to select the
+value based on accel. For accel=xen the default is off otherwise the default
+is on.
+.IP "\fBkvm_shadow_mem=size\fR" 4
+.IX Item "kvm_shadow_mem=size"
+Defines the size of the \s-1KVM\s0 shadow \s-1MMU.\s0
+.IP "\fBdump\-guest\-core=on|off\fR" 4
+.IX Item "dump-guest-core=on|off"
+Include guest memory in a core dump. The default is on.
+.IP "\fBmem\-merge=on|off\fR" 4
+.IX Item "mem-merge=on|off"
+Enables or disables memory merge support. This feature, when supported by
+the host, de-duplicates identical memory pages among VMs instances
+(enabled by default).
+.IP "\fBiommu=on|off\fR" 4
+.IX Item "iommu=on|off"
+Enables or disables emulated Intel \s-1IOMMU \s0(VT-d) support. The default is off.
+.IP "\fBaes\-key\-wrap=on|off\fR" 4
+.IX Item "aes-key-wrap=on|off"
+Enables or disables \s-1AES\s0 key wrapping support on s390\-ccw hosts. This feature
+controls whether \s-1AES\s0 wrapping keys will be created to allow
+execution of \s-1AES\s0 cryptographic functions.  The default is on.
+.IP "\fBdea\-key\-wrap=on|off\fR" 4
+.IX Item "dea-key-wrap=on|off"
+Enables or disables \s-1DEA\s0 key wrapping support on s390\-ccw hosts. This feature
+controls whether \s-1DEA\s0 wrapping keys will be created to allow
+execution of \s-1DEA\s0 cryptographic functions.  The default is on.
+.RE
+.RS 4
+.RE
+.IP "\fB\-cpu\fR \fImodel\fR" 4
+.IX Item "-cpu model"
+Select \s-1CPU\s0 model (\f(CW\*(C`\-cpu help\*(C'\fR for list and additional feature selection)
+.IP "\fB\-smp [cpus=]\fR\fIn\fR\fB[,cores=\fR\fIcores\fR\fB][,threads=\fR\fIthreads\fR\fB][,sockets=\fR\fIsockets\fR\fB][,maxcpus=\fR\fImaxcpus\fR\fB]\fR" 4
+.IX Item "-smp [cpus=]n[,cores=cores][,threads=threads][,sockets=sockets][,maxcpus=maxcpus]"
+Simulate an \s-1SMP\s0 system with \fIn\fR CPUs. On the \s-1PC\s0 target, up to 255
+CPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs
+to 4.
+For the \s-1PC\s0 target, the number of \fIcores\fR per socket, the number
+of \fIthreads\fR per cores and the total number of \fIsockets\fR can be
+specified. Missing values will be computed. If any on the three values is
+given, the total number of CPUs \fIn\fR can be omitted. \fImaxcpus\fR
+specifies the maximum number of hotpluggable CPUs.
+.IP "\fB\-numa node[,mem=\fR\fIsize\fR\fB][,cpus=\fR\fIcpu[\-cpu]\fR\fB][,nodeid=\fR\fInode\fR\fB]\fR" 4
+.IX Item "-numa node[,mem=size][,cpus=cpu[-cpu]][,nodeid=node]"
+.PD 0
+.IP "\fB\-numa node[,memdev=\fR\fIid\fR\fB][,cpus=\fR\fIcpu[\-cpu]\fR\fB][,nodeid=\fR\fInode\fR\fB]\fR" 4
+.IX Item "-numa node[,memdev=id][,cpus=cpu[-cpu]][,nodeid=node]"
+.PD
+Simulate a multi node \s-1NUMA\s0 system. If \fBmem\fR, \fBmemdev\fR
+and \fBcpus\fR are omitted, resources are split equally. Also, note
+that the \-\fBnuma\fR option doesn't allocate any of the specified
+resources. That is, it just assigns existing resources to \s-1NUMA\s0 nodes. This
+means that one still has to use the \fB\-m\fR, \fB\-smp\fR options
+to allocate \s-1RAM\s0 and VCPUs respectively, and possibly \fB\-object\fR
+to specify the memory backend for the \fBmemdev\fR suboption.
+.Sp
+\&\fBmem\fR and \fBmemdev\fR are mutually exclusive.  Furthermore, if one
+node uses \fBmemdev\fR, all of them have to use it.
+.IP "\fB\-add\-fd fd=\fR\fIfd\fR\fB,set=\fR\fIset\fR\fB[,opaque=\fR\fIopaque\fR\fB]\fR" 4
+.IX Item "-add-fd fd=fd,set=set[,opaque=opaque]"
+Add a file descriptor to an fd set.  Valid options are:
+.RS 4
+.IP "\fBfd=\fR\fIfd\fR" 4
+.IX Item "fd=fd"
+This option defines the file descriptor of which a duplicate is added to fd set.
+The file descriptor cannot be stdin, stdout, or stderr.
+.IP "\fBset=\fR\fIset\fR" 4
+.IX Item "set=set"
+This option defines the \s-1ID\s0 of the fd set to add the file descriptor to.
+.IP "\fBopaque=\fR\fIopaque\fR" 4
+.IX Item "opaque=opaque"
+This option defines a free-form string that can be used to describe \fIfd\fR.
+.RE
+.RS 4
+.Sp
+You can open an image using pre-opened file descriptors from an fd set:
+.Sp
+.Vb 4
+\&        qemu\-system\-i386
+\&        \-add\-fd fd=3,set=2,opaque="rdwr:/path/to/file"
+\&        \-add\-fd fd=4,set=2,opaque="rdonly:/path/to/file"
+\&        \-drive file=/dev/fdset/2,index=0,media=disk
+.Ve
+.RE
+.IP "\fB\-set\fR \fIgroup\fR\fB.\fR\fIid\fR\fB.\fR\fIarg\fR\fB=\fR\fIvalue\fR" 4
+.IX Item "-set group.id.arg=value"
+Set parameter \fIarg\fR for item \fIid\fR of type \fIgroup\fR
+"
+.IP "\fB\-global\fR \fIdriver\fR\fB.\fR\fIprop\fR\fB=\fR\fIvalue\fR" 4
+.IX Item "-global driver.prop=value"
+Set default value of \fIdriver\fR's property \fIprop\fR to \fIvalue\fR, e.g.:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-global ide\-drive.physical_block_size=4096 \-drive file=file,if=ide,index=0,media=disk
+.Ve
+.Sp
+In particular, you can use this to set driver properties for devices which are 
+created automatically by the machine model. To create a device which is not 
+created automatically and set properties on it, use \-\fBdevice\fR.
+.IP "\fB\-boot [order=\fR\fIdrives\fR\fB][,once=\fR\fIdrives\fR\fB][,menu=on|off][,splash=\fR\fIsp_name\fR\fB][,splash\-time=\fR\fIsp_time\fR\fB][,reboot\-timeout=\fR\fIrb_timeout\fR\fB][,strict=on|off]\fR" 4
+.IX Item "-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]"
+Specify boot order \fIdrives\fR as a string of drive letters. Valid
+drive letters depend on the target achitecture. The x86 \s-1PC\s0 uses: a, b
+(floppy 1 and 2), c (first hard disk), d (first CD-ROM), n\-p (Etherboot
+from network adapter 1\-4), hard disk boot is the default. To apply a
+particular boot order only on the first startup, specify it via
+\&\fBonce\fR.
+.Sp
+Interactive boot menus/prompts can be enabled via \fBmenu=on\fR as far
+as firmware/BIOS supports them. The default is non-interactive boot.
+.Sp
+A splash picture could be passed to bios, enabling user to show it as logo,
+when option splash=\fIsp_name\fR is given and menu=on, If firmware/BIOS
+supports them. Currently Seabios for X86 system support it.
+limitation: The splash file could be a jpeg file or a \s-1BMP\s0 file in 24 \s-1BPP\s0
+format(true color). The resolution should be supported by the \s-1SVGA\s0 mode, so
+the recommended is 320x240, 640x480, 800x640.
+.Sp
+A timeout could be passed to bios, guest will pause for \fIrb_timeout\fR ms
+when boot failed, then reboot. If \fIrb_timeout\fR is '\-1', guest will not
+reboot, qemu passes '\-1' to bios by default. Currently Seabios for X86
+system support it.
+.Sp
+Do strict boot via \fBstrict=on\fR as far as firmware/BIOS
+supports it. This only effects when boot priority is changed by
+bootindex options. The default is non-strict boot.
+.Sp
+.Vb 6
+\&        # try to boot from network first, then from hard disk
+\&        qemu\-system\-i386 \-boot order=nc
+\&        # boot from CD\-ROM first, switch back to default order after reboot
+\&        qemu\-system\-i386 \-boot once=d
+\&        # boot with a splash picture for 5 seconds.
+\&        qemu\-system\-i386 \-boot menu=on,splash=/root/boot.bmp,splash\-time=5000
+.Ve
+.Sp
+Note: The legacy format '\-boot \fIdrives\fR' is still supported but its
+use is discouraged as it may be removed from future versions.
+.IP "\fB\-m [size=]\fR\fImegs\fR\fB[,slots=n,maxmem=size]\fR" 4
+.IX Item "-m [size=]megs[,slots=n,maxmem=size]"
+Sets guest startup \s-1RAM\s0 size to \fImegs\fR megabytes. Default is 128 MiB.
+Optionally, a suffix of \*(L"M\*(R" or \*(L"G\*(R" can be used to signify a value in
+megabytes or gigabytes respectively. Optional pair \fIslots\fR, \fImaxmem\fR
+could be used to set amount of hotpluggable memory slots and maximum amount of
+memory. Note that \fImaxmem\fR must be aligned to the page size.
+.Sp
+For example, the following command-line sets the guest startup \s-1RAM\s0 size to
+1GB, creates 3 slots to hotplug additional memory and sets the maximum
+memory the guest can reach to 4GB:
+.Sp
+.Vb 1
+\&        qemu\-system\-x86_64 \-m 1G,slots=3,maxmem=4G
+.Ve
+.Sp
+If \fIslots\fR and \fImaxmem\fR are not specified, memory hotplug won't
+be enabled and the guest startup \s-1RAM\s0 will never increase.
+.IP "\fB\-mem\-path\fR \fIpath\fR" 4
+.IX Item "-mem-path path"
+Allocate guest \s-1RAM\s0 from a temporarily created file in \fIpath\fR.
+.IP "\fB\-mem\-prealloc\fR" 4
+.IX Item "-mem-prealloc"
+Preallocate memory when using \-mem\-path.
+.IP "\fB\-k\fR \fIlanguage\fR" 4
+.IX Item "-k language"
+Use keyboard layout \fIlanguage\fR (for example \f(CW\*(C`fr\*(C'\fR for
+French). This option is only needed where it is not easy to get raw \s-1PC\s0
+keycodes (e.g. on Macs, with some X11 servers or with a \s-1VNC\s0
+display). You don't normally need to use it on PC/Linux or PC/Windows
+hosts.
+.Sp
+The available layouts are:
+.Sp
+.Vb 3
+\&        ar  de\-ch  es  fo     fr\-ca  hu  ja  mk     no  pt\-br  sv
+\&        da  en\-gb  et  fr     fr\-ch  is  lt  nl     pl  ru     th
+\&        de  en\-us  fi  fr\-be  hr     it  lv  nl\-be  pt  sl     tr
+.Ve
+.Sp
+The default is \f(CW\*(C`en\-us\*(C'\fR.
+.IP "\fB\-audio\-help\fR" 4
+.IX Item "-audio-help"
+Will show the audio subsystem help: list of drivers, tunable
+parameters.
+.IP "\fB\-soundhw\fR \fIcard1\fR\fB[,\fR\fIcard2\fR\fB,...] or \-soundhw all\fR" 4
+.IX Item "-soundhw card1[,card2,...] or -soundhw all"
+Enable audio and selected sound hardware. Use 'help' to print all
+available sound hardware.
+.Sp
+.Vb 6
+\&        qemu\-system\-i386 \-soundhw sb16,adlib disk.img
+\&        qemu\-system\-i386 \-soundhw es1370 disk.img
+\&        qemu\-system\-i386 \-soundhw ac97 disk.img
+\&        qemu\-system\-i386 \-soundhw hda disk.img
+\&        qemu\-system\-i386 \-soundhw all disk.img
+\&        qemu\-system\-i386 \-soundhw help
+.Ve
+.Sp
+Note that Linux's i810_audio \s-1OSS\s0 kernel (for \s-1AC97\s0) module might
+require manually specifying clocking.
+.Sp
+.Vb 1
+\&        modprobe i810_audio clocking=48000
+.Ve
+.IP "\fB\-balloon none\fR" 4
+.IX Item "-balloon none"
+Disable balloon device.
+.IP "\fB\-balloon virtio[,addr=\fR\fIaddr\fR\fB]\fR" 4
+.IX Item "-balloon virtio[,addr=addr]"
+Enable virtio balloon device (default), optionally with \s-1PCI\s0 address
+\&\fIaddr\fR.
+.IP "\fB\-device\fR \fIdriver\fR\fB[,\fR\fIprop\fR\fB[=\fR\fIvalue\fR\fB][,...]]\fR" 4
+.IX Item "-device driver[,prop[=value][,...]]"
+Add device \fIdriver\fR.  \fIprop\fR=\fIvalue\fR sets driver
+properties.  Valid properties depend on the driver.  To get help on
+possible drivers and properties, use \f(CW\*(C`\-device help\*(C'\fR and
+\&\f(CW\*(C`\-device \f(CIdriver\f(CW,help\*(C'\fR.
+.IP "\fB\-name\fR \fIname\fR" 4
+.IX Item "-name name"
+Sets the \fIname\fR of the guest.
+This name will be displayed in the \s-1SDL\s0 window caption.
+The \fIname\fR will also be used for the \s-1VNC\s0 server.
+Also optionally set the top visible process name in Linux.
+Naming of individual threads can also be enabled on Linux to aid debugging.
+.IP "\fB\-uuid\fR \fIuuid\fR" 4
+.IX Item "-uuid uuid"
+Set system \s-1UUID.\s0
+.PP
+Block device options:
+.IP "\fB\-fda\fR \fIfile\fR" 4
+.IX Item "-fda file"
+.PD 0
+.IP "\fB\-fdb\fR \fIfile\fR" 4
+.IX Item "-fdb file"
+.PD
+Use \fIfile\fR as floppy disk 0/1 image.
+.IP "\fB\-hda\fR \fIfile\fR" 4
+.IX Item "-hda file"
+.PD 0
+.IP "\fB\-hdb\fR \fIfile\fR" 4
+.IX Item "-hdb file"
+.IP "\fB\-hdc\fR \fIfile\fR" 4
+.IX Item "-hdc file"
+.IP "\fB\-hdd\fR \fIfile\fR" 4
+.IX Item "-hdd file"
+.PD
+Use \fIfile\fR as hard disk 0, 1, 2 or 3 image.
+.IP "\fB\-cdrom\fR \fIfile\fR" 4
+.IX Item "-cdrom file"
+Use \fIfile\fR as CD-ROM image (you cannot use \fB\-hdc\fR and
+\&\fB\-cdrom\fR at the same time). You can use the host CD-ROM by
+using \fI/dev/cdrom\fR as filename.
+.IP "\fB\-drive\fR \fIoption\fR\fB[,\fR\fIoption\fR\fB[,\fR\fIoption\fR\fB[,...]]]\fR" 4
+.IX Item "-drive option[,option[,option[,...]]]"
+Define a new drive. Valid options are:
+.RS 4
+.IP "\fBfile=\fR\fIfile\fR" 4
+.IX Item "file=file"
+This option defines which disk image to use with
+this drive. If the filename contains comma, you must double it
+(for instance, \*(L"file=my,,file\*(R" to use file \*(L"my,file\*(R").
+.Sp
+Special files such as iSCSI devices can be specified using protocol
+specific URLs. See the section for \*(L"Device \s-1URL\s0 Syntax\*(R" for more information.
+.IP "\fBif=\fR\fIinterface\fR" 4
+.IX Item "if=interface"
+This option defines on which type on interface the drive is connected.
+Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.
+.IP "\fBbus=\fR\fIbus\fR\fB,unit=\fR\fIunit\fR" 4
+.IX Item "bus=bus,unit=unit"
+These options define where is connected the drive by defining the bus number and
+the unit id.
+.IP "\fBindex=\fR\fIindex\fR" 4
+.IX Item "index=index"
+This option defines where is connected the drive by using an index in the list
+of available connectors of a given interface type.
+.IP "\fBmedia=\fR\fImedia\fR" 4
+.IX Item "media=media"
+This option defines the type of the media: disk or cdrom.
+.IP "\fBcyls=\fR\fIc\fR\fB,heads=\fR\fIh\fR\fB,secs=\fR\fIs\fR\fB[,trans=\fR\fIt\fR\fB]\fR" 4
+.IX Item "cyls=c,heads=h,secs=s[,trans=t]"
+These options have the same definition as they have in \fB\-hdachs\fR.
+.IP "\fBsnapshot=\fR\fIsnapshot\fR" 4
+.IX Item "snapshot=snapshot"
+\&\fIsnapshot\fR is \*(L"on\*(R" or \*(L"off\*(R" and controls snapshot mode for the given drive
+(see \fB\-snapshot\fR).
+.IP "\fBcache=\fR\fIcache\fR" 4
+.IX Item "cache=cache"
+\&\fIcache\fR is \*(L"none\*(R", \*(L"writeback\*(R", \*(L"unsafe\*(R", \*(L"directsync\*(R" or \*(L"writethrough\*(R" and controls how the host cache is used to access block data.
+.IP "\fBaio=\fR\fIaio\fR" 4
+.IX Item "aio=aio"
+\&\fIaio\fR is \*(L"threads\*(R", or \*(L"native\*(R" and selects between pthread based disk I/O and native Linux \s-1AIO.\s0
+.IP "\fBdiscard=\fR\fIdiscard\fR" 4
+.IX Item "discard=discard"
+\&\fIdiscard\fR is one of \*(L"ignore\*(R" (or \*(L"off\*(R") or \*(L"unmap\*(R" (or \*(L"on\*(R") and controls whether \fIdiscard\fR (also known as \fItrim\fR or \fIunmap\fR) requests are ignored or passed to the filesystem.  Some machine types may not support discard requests.
+.IP "\fBformat=\fR\fIformat\fR" 4
+.IX Item "format=format"
+Specify which disk \fIformat\fR will be used rather than detecting
+the format.  Can be used to specifiy format=raw to avoid interpreting
+an untrusted format header.
+.IP "\fBserial=\fR\fIserial\fR" 4
+.IX Item "serial=serial"
+This option specifies the serial number to assign to the device.
+.IP "\fBaddr=\fR\fIaddr\fR" 4
+.IX Item "addr=addr"
+Specify the controller's \s-1PCI\s0 address (if=virtio only).
+.IP "\fBwerror=\fR\fIaction\fR\fB,rerror=\fR\fIaction\fR" 4
+.IX Item "werror=action,rerror=action"
+Specify which \fIaction\fR to take on write and read errors. Valid actions are:
+\&\*(L"ignore\*(R" (ignore the error and try to continue), \*(L"stop\*(R" (pause \s-1QEMU\s0),
+\&\*(L"report\*(R" (report the error to the guest), \*(L"enospc\*(R" (pause \s-1QEMU\s0 only if the
+host disk is full; report the error to the guest otherwise).
+The default setting is \fBwerror=enospc\fR and \fBrerror=report\fR.
+.IP "\fBreadonly\fR" 4
+.IX Item "readonly"
+Open drive \fBfile\fR as read-only. Guest write attempts will fail.
+.IP "\fBcopy\-on\-read=\fR\fIcopy-on-read\fR" 4
+.IX Item "copy-on-read=copy-on-read"
+\&\fIcopy-on-read\fR is \*(L"on\*(R" or \*(L"off\*(R" and enables whether to copy read backing
+file sectors into the image file.
+.IP "\fBdetect\-zeroes=\fR\fIdetect-zeroes\fR" 4
+.IX Item "detect-zeroes=detect-zeroes"
+\&\fIdetect-zeroes\fR is \*(L"off\*(R", \*(L"on\*(R" or \*(L"unmap\*(R" and enables the automatic
+conversion of plain zero writes by the \s-1OS\s0 to driver specific optimized
+zero write commands. You may even choose \*(L"unmap\*(R" if \fIdiscard\fR is set
+to \*(L"unmap\*(R" to allow a zero write to be converted to an \s-1UNMAP\s0 operation.
+.RE
+.RS 4
+.Sp
+By default, the \fBcache=writeback\fR mode is used. It will report data
+writes as completed as soon as the data is present in the host page cache.
+This is safe as long as your guest \s-1OS\s0 makes sure to correctly flush disk caches
+where needed. If your guest \s-1OS\s0 does not handle volatile disk write caches
+correctly and your host crashes or loses power, then the guest may experience
+data corruption.
+.Sp
+For such guests, you should consider using \fBcache=writethrough\fR. This
+means that the host page cache will be used to read and write data, but write
+notification will be sent to the guest only after \s-1QEMU\s0 has made sure to flush
+each write to the disk. Be aware that this has a major impact on performance.
+.Sp
+The host page cache can be avoided entirely with \fBcache=none\fR.  This will
+attempt to do disk \s-1IO\s0 directly to the guest's memory.  \s-1QEMU\s0 may still perform
+an internal copy of the data. Note that this is considered a writeback mode and
+the guest \s-1OS\s0 must handle the disk write cache correctly in order to avoid data
+corruption on host crashes.
+.Sp
+The host page cache can be avoided while only sending write notifications to
+the guest when the data has been flushed to the disk using
+\&\fBcache=directsync\fR.
+.Sp
+In case you don't care about data integrity over host failures, use
+\&\fBcache=unsafe\fR. This option tells \s-1QEMU\s0 that it never needs to write any
+data to the disk but can instead keep things in cache. If anything goes wrong,
+like your host losing power, the disk storage getting disconnected accidentally,
+etc. your image will most probably be rendered unusable.   When using
+the \fB\-snapshot\fR option, unsafe caching is always used.
+.Sp
+Copy-on-read avoids accessing the same backing file sectors repeatedly and is
+useful when the backing file is over a slow network.  By default copy-on-read
+is off.
+.Sp
+Instead of \fB\-cdrom\fR you can use:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive file=file,index=2,media=cdrom
+.Ve
+.Sp
+Instead of \fB\-hda\fR, \fB\-hdb\fR, \fB\-hdc\fR, \fB\-hdd\fR, you can
+use:
+.Sp
+.Vb 4
+\&        qemu\-system\-i386 \-drive file=file,index=0,media=disk
+\&        qemu\-system\-i386 \-drive file=file,index=1,media=disk
+\&        qemu\-system\-i386 \-drive file=file,index=2,media=disk
+\&        qemu\-system\-i386 \-drive file=file,index=3,media=disk
+.Ve
+.Sp
+You can open an image using pre-opened file descriptors from an fd set:
+.Sp
+.Vb 4
+\&        qemu\-system\-i386
+\&        \-add\-fd fd=3,set=2,opaque="rdwr:/path/to/file"
+\&        \-add\-fd fd=4,set=2,opaque="rdonly:/path/to/file"
+\&        \-drive file=/dev/fdset/2,index=0,media=disk
+.Ve
+.Sp
+You can connect a \s-1CDROM\s0 to the slave of ide0:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive file=file,if=ide,index=1,media=cdrom
+.Ve
+.Sp
+If you don't specify the \*(L"file=\*(R" argument, you define an empty drive:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive if=ide,index=1,media=cdrom
+.Ve
+.Sp
+You can connect a \s-1SCSI\s0 disk with unit \s-1ID 6\s0 on the bus #0:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive file=file,if=scsi,bus=0,unit=6
+.Ve
+.Sp
+Instead of \fB\-fda\fR, \fB\-fdb\fR, you can use:
+.Sp
+.Vb 2
+\&        qemu\-system\-i386 \-drive file=file,index=0,if=floppy
+\&        qemu\-system\-i386 \-drive file=file,index=1,if=floppy
+.Ve
+.Sp
+By default, \fIinterface\fR is \*(L"ide\*(R" and \fIindex\fR is automatically
+incremented:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive file=a \-drive file=b"
+.Ve
+.Sp
+is interpreted like:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-hda a \-hdb b
+.Ve
+.RE
+.IP "\fB\-mtdblock\fR \fIfile\fR" 4
+.IX Item "-mtdblock file"
+Use \fIfile\fR as on-board Flash memory image.
+.IP "\fB\-sd\fR \fIfile\fR" 4
+.IX Item "-sd file"
+Use \fIfile\fR as SecureDigital card image.
+.IP "\fB\-pflash\fR \fIfile\fR" 4
+.IX Item "-pflash file"
+Use \fIfile\fR as a parallel flash image.
+.IP "\fB\-snapshot\fR" 4
+.IX Item "-snapshot"
+Write to temporary files instead of disk image files. In this case,
+the raw disk image you use is not written back. You can however force
+the write back by pressing \fBC\-a s\fR.
+.IP "\fB\-hdachs\fR \fIc\fR\fB,\fR\fIh\fR\fB,\fR\fIs\fR\fB,[,\fR\fIt\fR\fB]\fR" 4
+.IX Item "-hdachs c,h,s,[,t]"
+Force hard disk 0 physical geometry (1 <= \fIc\fR <= 16383, 1 <=
+\&\fIh\fR <= 16, 1 <= \fIs\fR <= 63) and optionally force the \s-1BIOS\s0
+translation mode (\fIt\fR=none, lba or auto). Usually \s-1QEMU\s0 can guess
+all those parameters. This option is useful for old MS-DOS disk
+images.
+.IP "\fB\-fsdev\fR \fIfsdriver\fR\fB,id=\fR\fIid\fR\fB,path=\fR\fIpath\fR\fB,[security_model=\fR\fIsecurity_model\fR\fB][,writeout=\fR\fIwriteout\fR\fB][,readonly][,socket=\fR\fIsocket\fR\fB|sock_fd=\fR\fIsock_fd\fR\fB]\fR" 4
+.IX Item "-fsdev fsdriver,id=id,path=path,[security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]"
+Define a new file system device. Valid options are:
+.RS 4
+.IP "\fIfsdriver\fR" 4
+.IX Item "fsdriver"
+This option specifies the fs driver backend to use.
+Currently \*(L"local\*(R", \*(L"handle\*(R" and \*(L"proxy\*(R" file system drivers are supported.
+.IP "\fBid=\fR\fIid\fR" 4
+.IX Item "id=id"
+Specifies identifier for this device
+.IP "\fBpath=\fR\fIpath\fR" 4
+.IX Item "path=path"
+Specifies the export path for the file system device. Files under
+this path will be available to the 9p client on the guest.
+.IP "\fBsecurity_model=\fR\fIsecurity_model\fR" 4
+.IX Item "security_model=security_model"
+Specifies the security model to be used for this export path.
+Supported security models are \*(L"passthrough\*(R", \*(L"mapped-xattr\*(R", \*(L"mapped-file\*(R" and \*(L"none\*(R".
+In \*(L"passthrough\*(R" security model, files are stored using the same
+credentials as they are created on the guest. This requires \s-1QEMU\s0
+to run as root. In \*(L"mapped-xattr\*(R" security model, some of the file
+attributes like uid, gid, mode bits and link target are stored as
+file attributes. For \*(L"mapped-file\*(R" these attributes are stored in the
+hidden .virtfs_metadata directory. Directories exported by this security model cannot
+interact with other unix tools. \*(L"none\*(R" security model is same as
+passthrough except the sever won't report failures if it fails to
+set file attributes like ownership. Security model is mandatory
+only for local fsdriver. Other fsdrivers (like handle, proxy) don't take
+security model as a parameter.
+.IP "\fBwriteout=\fR\fIwriteout\fR" 4
+.IX Item "writeout=writeout"
+This is an optional argument. The only supported value is \*(L"immediate\*(R".
+This means that host page cache will be used to read and write data but
+write notification will be sent to the guest only when the data has been
+reported as written by the storage subsystem.
+.IP "\fBreadonly\fR" 4
+.IX Item "readonly"
+Enables exporting 9p share as a readonly mount for guests. By default
+read-write access is given.
+.IP "\fBsocket=\fR\fIsocket\fR" 4
+.IX Item "socket=socket"
+Enables proxy filesystem driver to use passed socket file for communicating
+with virtfs-proxy-helper
+.IP "\fBsock_fd=\fR\fIsock_fd\fR" 4
+.IX Item "sock_fd=sock_fd"
+Enables proxy filesystem driver to use passed socket descriptor for
+communicating with virtfs-proxy-helper. Usually a helper like libvirt
+will create socketpair and pass one of the fds as sock_fd
+.RE
+.RS 4
+.Sp
+\&\-fsdev option is used along with \-device driver \*(L"virtio\-9p\-pci\*(R".
+.RE
+.IP "\fB\-device virtio\-9p\-pci,fsdev=\fR\fIid\fR\fB,mount_tag=\fR\fImount_tag\fR" 4
+.IX Item "-device virtio-9p-pci,fsdev=id,mount_tag=mount_tag"
+Options for virtio\-9p\-pci driver are:
+.RS 4
+.IP "\fBfsdev=\fR\fIid\fR" 4
+.IX Item "fsdev=id"
+Specifies the id value specified along with \-fsdev option
+.IP "\fBmount_tag=\fR\fImount_tag\fR" 4
+.IX Item "mount_tag=mount_tag"
+Specifies the tag name to be used by the guest to mount this export point
+.RE
+.RS 4
+.RE
+.IP "\fB\-virtfs\fR \fIfsdriver\fR\fB[,path=\fR\fIpath\fR\fB],mount_tag=\fR\fImount_tag\fR\fB[,security_model=\fR\fIsecurity_model\fR\fB][,writeout=\fR\fIwriteout\fR\fB][,readonly][,socket=\fR\fIsocket\fR\fB|sock_fd=\fR\fIsock_fd\fR\fB]\fR" 4
+.IX Item "-virtfs fsdriver[,path=path],mount_tag=mount_tag[,security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]"
+The general form of a Virtual File system pass-through options are:
+.RS 4
+.IP "\fIfsdriver\fR" 4
+.IX Item "fsdriver"
+This option specifies the fs driver backend to use.
+Currently \*(L"local\*(R", \*(L"handle\*(R" and \*(L"proxy\*(R" file system drivers are supported.
+.IP "\fBid=\fR\fIid\fR" 4
+.IX Item "id=id"
+Specifies identifier for this device
+.IP "\fBpath=\fR\fIpath\fR" 4
+.IX Item "path=path"
+Specifies the export path for the file system device. Files under
+this path will be available to the 9p client on the guest.
+.IP "\fBsecurity_model=\fR\fIsecurity_model\fR" 4
+.IX Item "security_model=security_model"
+Specifies the security model to be used for this export path.
+Supported security models are \*(L"passthrough\*(R", \*(L"mapped-xattr\*(R", \*(L"mapped-file\*(R" and \*(L"none\*(R".
+In \*(L"passthrough\*(R" security model, files are stored using the same
+credentials as they are created on the guest. This requires \s-1QEMU\s0
+to run as root. In \*(L"mapped-xattr\*(R" security model, some of the file
+attributes like uid, gid, mode bits and link target are stored as
+file attributes. For \*(L"mapped-file\*(R" these attributes are stored in the
+hidden .virtfs_metadata directory. Directories exported by this security model cannot
+interact with other unix tools. \*(L"none\*(R" security model is same as
+passthrough except the sever won't report failures if it fails to
+set file attributes like ownership. Security model is mandatory only
+for local fsdriver. Other fsdrivers (like handle, proxy) don't take security
+model as a parameter.
+.IP "\fBwriteout=\fR\fIwriteout\fR" 4
+.IX Item "writeout=writeout"
+This is an optional argument. The only supported value is \*(L"immediate\*(R".
+This means that host page cache will be used to read and write data but
+write notification will be sent to the guest only when the data has been
+reported as written by the storage subsystem.
+.IP "\fBreadonly\fR" 4
+.IX Item "readonly"
+Enables exporting 9p share as a readonly mount for guests. By default
+read-write access is given.
+.IP "\fBsocket=\fR\fIsocket\fR" 4
+.IX Item "socket=socket"
+Enables proxy filesystem driver to use passed socket file for
+communicating with virtfs-proxy-helper. Usually a helper like libvirt
+will create socketpair and pass one of the fds as sock_fd
+.IP "\fBsock_fd\fR" 4
+.IX Item "sock_fd"
+Enables proxy filesystem driver to use passed 'sock_fd' as the socket
+descriptor for interfacing with virtfs-proxy-helper
+.RE
+.RS 4
+.RE
+.IP "\fB\-virtfs_synth\fR" 4
+.IX Item "-virtfs_synth"
+Create synthetic file system image
+.PP
+\&\s-1USB\s0 options:
+.IP "\fB\-usb\fR" 4
+.IX Item "-usb"
+Enable the \s-1USB\s0 driver (will be the default soon)
+.IP "\fB\-usbdevice\fR \fIdevname\fR" 4
+.IX Item "-usbdevice devname"
+Add the \s-1USB\s0 device \fIdevname\fR.
+.RS 4
+.IP "\fBmouse\fR" 4
+.IX Item "mouse"
+Virtual Mouse. This will override the \s-1PS/2\s0 mouse emulation when activated.
+.IP "\fBtablet\fR" 4
+.IX Item "tablet"
+Pointer device that uses absolute coordinates (like a touchscreen). This
+means \s-1QEMU\s0 is able to report the mouse position without having to grab the
+mouse. Also overrides the \s-1PS/2\s0 mouse emulation when activated.
+.IP "\fBdisk:[format=\fR\fIformat\fR\fB]:\fR\fIfile\fR" 4
+.IX Item "disk:[format=format]:file"
+Mass storage device based on file. The optional \fIformat\fR argument
+will be used rather than detecting the format. Can be used to specifiy
+\&\f(CW\*(C`format=raw\*(C'\fR to avoid interpreting an untrusted format header.
+.IP "\fBhost:\fR\fIbus\fR\fB.\fR\fIaddr\fR" 4
+.IX Item "host:bus.addr"
+Pass through the host device identified by \fIbus\fR.\fIaddr\fR (Linux only).
+.IP "\fBhost:\fR\fIvendor_id\fR\fB:\fR\fIproduct_id\fR" 4
+.IX Item "host:vendor_id:product_id"
+Pass through the host device identified by \fIvendor_id\fR:\fIproduct_id\fR
+(Linux only).
+.IP "\fBserial:[vendorid=\fR\fIvendor_id\fR\fB][,productid=\fR\fIproduct_id\fR\fB]:\fR\fIdev\fR" 4
+.IX Item "serial:[vendorid=vendor_id][,productid=product_id]:dev"
+Serial converter to host character device \fIdev\fR, see \f(CW\*(C`\-serial\*(C'\fR for the
+available devices.
+.IP "\fBbraille\fR" 4
+.IX Item "braille"
+Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+.IP "\fBnet:\fR\fIoptions\fR" 4
+.IX Item "net:options"
+Network adapter that supports \s-1CDC\s0 ethernet and \s-1RNDIS\s0 protocols.
+.RE
+.RS 4
+.RE
+.PP
+Display options:
+.IP "\fB\-display\fR \fItype\fR" 4
+.IX Item "-display type"
+Select type of display to use. This option is a replacement for the
+old style \-sdl/\-curses/... options. Valid values for \fItype\fR are
+.RS 4
+.IP "\fBsdl\fR" 4
+.IX Item "sdl"
+Display video output via \s-1SDL \s0(usually in a separate graphics
+window; see the \s-1SDL\s0 documentation for other possibilities).
+.IP "\fBcurses\fR" 4
+.IX Item "curses"
+Display video output via curses. For graphics device models which
+support a text mode, \s-1QEMU\s0 can display this output using a
+curses/ncurses interface. Nothing is displayed when the graphics
+device is in graphical mode or if the graphics device does not support
+a text mode. Generally only the \s-1VGA\s0 device models support text mode.
+.IP "\fBnone\fR" 4
+.IX Item "none"
+Do not display video output. The guest will still see an emulated
+graphics card, but its output will not be displayed to the \s-1QEMU\s0
+user. This option differs from the \-nographic option in that it
+only affects what is done with video output; \-nographic also changes
+the destination of the serial and parallel port data.
+.IP "\fBgtk\fR" 4
+.IX Item "gtk"
+Display video output in a \s-1GTK\s0 window. This interface provides drop-down
+menus and other \s-1UI\s0 elements to configure and control the \s-1VM\s0 during
+runtime.
+.IP "\fBvnc\fR" 4
+.IX Item "vnc"
+Start a \s-1VNC\s0 server on display <arg>
+.RE
+.RS 4
+.RE
+.IP "\fB\-nographic\fR" 4
+.IX Item "-nographic"
+Normally, \s-1QEMU\s0 uses \s-1SDL\s0 to display the \s-1VGA\s0 output. With this option,
+you can totally disable graphical output so that \s-1QEMU\s0 is a simple
+command line application. The emulated serial port is redirected on
+the console and muxed with the monitor (unless redirected elsewhere
+explicitly). Therefore, you can still use \s-1QEMU\s0 to debug a Linux kernel
+with a serial console.  Use \fBC\-a h\fR for help on switching between
+the console and monitor.
+.IP "\fB\-curses\fR" 4
+.IX Item "-curses"
+Normally, \s-1QEMU\s0 uses \s-1SDL\s0 to display the \s-1VGA\s0 output.  With this option,
+\&\s-1QEMU\s0 can display the \s-1VGA\s0 output when in text mode using a
+curses/ncurses interface.  Nothing is displayed in graphical mode.
+.IP "\fB\-no\-frame\fR" 4
+.IX Item "-no-frame"
+Do not use decorations for \s-1SDL\s0 windows and start them using the whole
+available screen space. This makes the using \s-1QEMU\s0 in a dedicated desktop
+workspace more convenient.
+.IP "\fB\-alt\-grab\fR" 4
+.IX Item "-alt-grab"
+Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note that this also
+affects the special keys (for fullscreen, monitor-mode switching, etc).
+.IP "\fB\-ctrl\-grab\fR" 4
+.IX Item "-ctrl-grab"
+Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note that this also
+affects the special keys (for fullscreen, monitor-mode switching, etc).
+.IP "\fB\-no\-quit\fR" 4
+.IX Item "-no-quit"
+Disable \s-1SDL\s0 window close capability.
+.IP "\fB\-sdl\fR" 4
+.IX Item "-sdl"
+Enable \s-1SDL.\s0
+.IP "\fB\-spice\fR \fIoption\fR\fB[,\fR\fIoption\fR\fB[,...]]\fR" 4
+.IX Item "-spice option[,option[,...]]"
+Enable the spice remote desktop protocol. Valid options are
+.RS 4
+.IP "\fBport=<nr>\fR" 4
+.IX Item "port=<nr>"
+Set the \s-1TCP\s0 port spice is listening on for plaintext channels.
+.IP "\fBaddr=<addr>\fR" 4
+.IX Item "addr=<addr>"
+Set the \s-1IP\s0 address spice is listening on.  Default is any address.
+.IP "\fBipv4\fR" 4
+.IX Item "ipv4"
+.PD 0
+.IP "\fBipv6\fR" 4
+.IX Item "ipv6"
+.IP "\fBunix\fR" 4
+.IX Item "unix"
+.PD
+Force using the specified \s-1IP\s0 version.
+.IP "\fBpassword=<secret>\fR" 4
+.IX Item "password=<secret>"
+Set the password you need to authenticate.
+.IP "\fBsasl\fR" 4
+.IX Item "sasl"
+Require that the client use \s-1SASL\s0 to authenticate with the spice.
+The exact choice of authentication method used is controlled from the
+system / user's \s-1SASL\s0 configuration file for the 'qemu' service. This
+is typically found in /etc/sasl2/qemu.conf. If running \s-1QEMU\s0 as an
+unprivileged user, an environment variable \s-1SASL_CONF_PATH\s0 can be used
+to make it search alternate locations for the service config.
+While some \s-1SASL\s0 auth methods can also provide data encryption (eg \s-1GSSAPI\s0),
+it is recommended that \s-1SASL\s0 always be combined with the 'tls' and
+\&'x509' settings to enable use of \s-1SSL\s0 and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials.
+.IP "\fBdisable-ticketing\fR" 4
+.IX Item "disable-ticketing"
+Allow client connects without authentication.
+.IP "\fBdisable-copy-paste\fR" 4
+.IX Item "disable-copy-paste"
+Disable copy paste between the client and the guest.
+.IP "\fBdisable-agent-file-xfer\fR" 4
+.IX Item "disable-agent-file-xfer"
+Disable spice-vdagent based file-xfer between the client and the guest.
+.IP "\fBtls\-port=<nr>\fR" 4
+.IX Item "tls-port=<nr>"
+Set the \s-1TCP\s0 port spice is listening on for encrypted channels.
+.IP "\fBx509\-dir=<dir>\fR" 4
+.IX Item "x509-dir=<dir>"
+Set the x509 file directory. Expects same filenames as \-vnc \f(CW$display\fR,x509=$dir
+.IP "\fBx509\-key\-file=<file>\fR" 4
+.IX Item "x509-key-file=<file>"
+.PD 0
+.IP "\fBx509\-key\-password=<file>\fR" 4
+.IX Item "x509-key-password=<file>"
+.IP "\fBx509\-cert\-file=<file>\fR" 4
+.IX Item "x509-cert-file=<file>"
+.IP "\fBx509\-cacert\-file=<file>\fR" 4
+.IX Item "x509-cacert-file=<file>"
+.IP "\fBx509\-dh\-key\-file=<file>\fR" 4
+.IX Item "x509-dh-key-file=<file>"
+.PD
+The x509 file names can also be configured individually.
+.IP "\fBtls\-ciphers=<list>\fR" 4
+.IX Item "tls-ciphers=<list>"
+Specify which ciphers to use.
+.IP "\fBtls\-channel=[main|display|cursor|inputs|record|playback]\fR" 4
+.IX Item "tls-channel=[main|display|cursor|inputs|record|playback]"
+.PD 0
+.IP "\fBplaintext\-channel=[main|display|cursor|inputs|record|playback]\fR" 4
+.IX Item "plaintext-channel=[main|display|cursor|inputs|record|playback]"
+.PD
+Force specific channel to be used with or without \s-1TLS\s0 encryption.  The
+options can be specified multiple times to configure multiple
+channels.  The special name \*(L"default\*(R" can be used to set the default
+mode.  For channels which are not explicitly forced into one mode the
+spice client is allowed to pick tls/plaintext as he pleases.
+.IP "\fBimage\-compression=[auto_glz|auto_lz|quic|glz|lz|off]\fR" 4
+.IX Item "image-compression=[auto_glz|auto_lz|quic|glz|lz|off]"
+Configure image compression (lossless).
+Default is auto_glz.
+.IP "\fBjpeg\-wan\-compression=[auto|never|always]\fR" 4
+.IX Item "jpeg-wan-compression=[auto|never|always]"
+.PD 0
+.IP "\fBzlib\-glz\-wan\-compression=[auto|never|always]\fR" 4
+.IX Item "zlib-glz-wan-compression=[auto|never|always]"
+.PD
+Configure wan image compression (lossy for slow links).
+Default is auto.
+.IP "\fBstreaming\-video=[off|all|filter]\fR" 4
+.IX Item "streaming-video=[off|all|filter]"
+Configure video stream detection.  Default is filter.
+.IP "\fBagent\-mouse=[on|off]\fR" 4
+.IX Item "agent-mouse=[on|off]"
+Enable/disable passing mouse events via vdagent.  Default is on.
+.IP "\fBplayback\-compression=[on|off]\fR" 4
+.IX Item "playback-compression=[on|off]"
+Enable/disable audio stream compression (using celt 0.5.1).  Default is on.
+.IP "\fBseamless\-migration=[on|off]\fR" 4
+.IX Item "seamless-migration=[on|off]"
+Enable/disable spice seamless migration. Default is off.
+.RE
+.RS 4
+.RE
+.IP "\fB\-portrait\fR" 4
+.IX Item "-portrait"
+Rotate graphical output 90 deg left (only \s-1PXA LCD\s0).
+.IP "\fB\-rotate\fR \fIdeg\fR" 4
+.IX Item "-rotate deg"
+Rotate graphical output some deg left (only \s-1PXA LCD\s0).
+.IP "\fB\-vga\fR \fItype\fR" 4
+.IX Item "-vga type"
+Select type of \s-1VGA\s0 card to emulate. Valid values for \fItype\fR are
+.RS 4
+.IP "\fBcirrus\fR" 4
+.IX Item "cirrus"
+Cirrus Logic \s-1GD5446\s0 Video card. All Windows versions starting from
+Windows 95 should recognize and use this graphic card. For optimal
+performances, use 16 bit color depth in the guest and the host \s-1OS.
+\&\s0(This one is the default)
+.IP "\fBstd\fR" 4
+.IX Item "std"
+Standard \s-1VGA\s0 card with Bochs \s-1VBE\s0 extensions.  If your guest \s-1OS\s0
+supports the \s-1VESA 2.0 VBE\s0 extensions (e.g. Windows \s-1XP\s0) and if you want
+to use high resolution modes (>= 1280x1024x16) then you should use
+this option.
+.IP "\fBvmware\fR" 4
+.IX Item "vmware"
+VMWare SVGA-II compatible adapter. Use it if you have sufficiently
+recent XFree86/XOrg server or Windows guest with a driver for this
+card.
+.IP "\fBqxl\fR" 4
+.IX Item "qxl"
+\&\s-1QXL\s0 paravirtual graphic card.  It is \s-1VGA\s0 compatible (including \s-1VESA
+2.0 VBE\s0 support).  Works best with qxl guest drivers installed though.
+Recommended choice when using the spice protocol.
+.IP "\fBtcx\fR" 4
+.IX Item "tcx"
+(sun4m only) Sun \s-1TCX\s0 framebuffer. This is the default framebuffer for
+sun4m machines and offers both 8\-bit and 24\-bit colour depths at a
+fixed resolution of 1024x768.
+.IP "\fBcg3\fR" 4
+.IX Item "cg3"
+(sun4m only) Sun cgthree framebuffer. This is a simple 8\-bit framebuffer
+for sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900 (\s-1OBP\s0)
+resolutions aimed at people wishing to run older Solaris versions.
+.IP "\fBnone\fR" 4
+.IX Item "none"
+Disable \s-1VGA\s0 card.
+.RE
+.RS 4
+.RE
+.IP "\fB\-full\-screen\fR" 4
+.IX Item "-full-screen"
+Start in full screen.
+.IP "\fB\-g\fR \fIwidth\fR\fBx\fR\fIheight\fR\fB[x\fR\fIdepth\fR\fB]\fR" 4
+.IX Item "-g widthxheight[xdepth]"
+Set the initial graphical resolution and depth (\s-1PPC, SPARC\s0 only).
+.IP "\fB\-vnc\fR \fIdisplay\fR\fB[,\fR\fIoption\fR\fB[,\fR\fIoption\fR\fB[,...]]]\fR" 4
+.IX Item "-vnc display[,option[,option[,...]]]"
+Normally, \s-1QEMU\s0 uses \s-1SDL\s0 to display the \s-1VGA\s0 output.  With this option,
+you can have \s-1QEMU\s0 listen on \s-1VNC\s0 display \fIdisplay\fR and redirect the \s-1VGA\s0
+display over the \s-1VNC\s0 session.  It is very useful to enable the usb
+tablet device when using this option (option \fB\-usbdevice
+tablet\fR). When using the \s-1VNC\s0 display, you must use the \fB\-k\fR
+parameter to set the keyboard layout if you are not using en-us. Valid
+syntax for the \fIdisplay\fR is
+.RS 4
+.IP "\fIhost\fR\fB:\fR\fId\fR" 4
+.IX Item "host:d"
+\&\s-1TCP\s0 connections will only be allowed from \fIhost\fR on display \fId\fR.
+By convention the \s-1TCP\s0 port is 5900+\fId\fR. Optionally, \fIhost\fR can
+be omitted in which case the server will accept connections from any host.
+.IP "\fBunix:\fR\fIpath\fR" 4
+.IX Item "unix:path"
+Connections will be allowed over \s-1UNIX\s0 domain sockets where \fIpath\fR is the
+location of a unix socket to listen for connections on.
+.IP "\fBnone\fR" 4
+.IX Item "none"
+\&\s-1VNC\s0 is initialized but not started. The monitor \f(CW\*(C`change\*(C'\fR command
+can be used to later start the \s-1VNC\s0 server.
+.RE
+.RS 4
+.Sp
+Following the \fIdisplay\fR value there may be one or more \fIoption\fR flags
+separated by commas. Valid options are
+.IP "\fBreverse\fR" 4
+.IX Item "reverse"
+Connect to a listening \s-1VNC\s0 client via a \*(L"reverse\*(R" connection. The
+client is specified by the \fIdisplay\fR. For reverse network
+connections (\fIhost\fR:\fId\fR,\f(CW\*(C`reverse\*(C'\fR), the \fId\fR argument
+is a \s-1TCP\s0 port number, not a display number.
+.IP "\fBwebsocket\fR" 4
+.IX Item "websocket"
+Opens an additional \s-1TCP\s0 listening port dedicated to \s-1VNC\s0 Websocket connections.
+By definition the Websocket port is 5700+\fIdisplay\fR. If \fIhost\fR is
+specified connections will only be allowed from this host.
+As an alternative the Websocket port could be specified by using
+\&\f(CW\*(C`websocket\*(C'\fR=\fIport\fR.
+\&\s-1TLS\s0 encryption for the Websocket connection is supported if the required
+certificates are specified with the \s-1VNC\s0 option \fBx509\fR.
+.IP "\fBpassword\fR" 4
+.IX Item "password"
+Require that password based authentication is used for client connections.
+.Sp
+The password must be set separately using the \f(CW\*(C`set_password\*(C'\fR command in
+the \fBpcsys_monitor\fR. The syntax to change your password is:
+\&\f(CW\*(C`set_password <protocol> <password>\*(C'\fR where <protocol> could be either
+\&\*(L"vnc\*(R" or \*(L"spice\*(R".
+.Sp
+If you would like to change <protocol> password expiration, you should use
+\&\f(CW\*(C`expire_password <protocol> <expiration\-time>\*(C'\fR where expiration time could
+be one of the following options: now, never, +seconds or \s-1UNIX\s0 time of
+expiration, e.g. +60 to make password expire in 60 seconds, or 1335196800
+to make password expire on \*(L"Mon Apr 23 12:00:00 \s-1EDT 2012\*(R" \s0(\s-1UNIX\s0 time for this
+date and time).
+.Sp
+You can also use keywords \*(L"now\*(R" or \*(L"never\*(R" for the expiration time to
+allow <protocol> password to expire immediately or never expire.
+.IP "\fBtls\fR" 4
+.IX Item "tls"
+Require that client use \s-1TLS\s0 when communicating with the \s-1VNC\s0 server. This
+uses anonymous \s-1TLS\s0 credentials so is susceptible to a man-in-the-middle
+attack. It is recommended that this option be combined with either the
+\&\fBx509\fR or \fBx509verify\fR options.
+.IP "\fBx509=\fR\fI/path/to/certificate/dir\fR" 4
+.IX Item "x509=/path/to/certificate/dir"
+Valid if \fBtls\fR is specified. Require that x509 credentials are used
+for negotiating the \s-1TLS\s0 session. The server will send its x509 certificate
+to the client. It is recommended that a password be set on the \s-1VNC\s0 server
+to provide authentication of the client when this is used. The path following
+this option specifies where the x509 certificates are to be loaded from.
+See the \fBvnc_security\fR section for details on generating certificates.
+.IP "\fBx509verify=\fR\fI/path/to/certificate/dir\fR" 4
+.IX Item "x509verify=/path/to/certificate/dir"
+Valid if \fBtls\fR is specified. Require that x509 credentials are used
+for negotiating the \s-1TLS\s0 session. The server will send its x509 certificate
+to the client, and request that the client send its own x509 certificate.
+The server will validate the client's certificate against the \s-1CA\s0 certificate,
+and reject clients when validation fails. If the certificate authority is
+trusted, this is a sufficient authentication mechanism. You may still wish
+to set a password on the \s-1VNC\s0 server as a second authentication layer. The
+path following this option specifies where the x509 certificates are to
+be loaded from. See the \fBvnc_security\fR section for details on generating
+certificates.
+.IP "\fBsasl\fR" 4
+.IX Item "sasl"
+Require that the client use \s-1SASL\s0 to authenticate with the \s-1VNC\s0 server.
+The exact choice of authentication method used is controlled from the
+system / user's \s-1SASL\s0 configuration file for the 'qemu' service. This
+is typically found in /etc/sasl2/qemu.conf. If running \s-1QEMU\s0 as an
+unprivileged user, an environment variable \s-1SASL_CONF_PATH\s0 can be used
+to make it search alternate locations for the service config.
+While some \s-1SASL\s0 auth methods can also provide data encryption (eg \s-1GSSAPI\s0),
+it is recommended that \s-1SASL\s0 always be combined with the 'tls' and
+\&'x509' settings to enable use of \s-1SSL\s0 and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials. See the \fBvnc_security\fR section for details on using
+\&\s-1SASL\s0 authentication.
+.IP "\fBacl\fR" 4
+.IX Item "acl"
+Turn on access control lists for checking of the x509 client certificate
+and \s-1SASL\s0 party. For x509 certs, the \s-1ACL\s0 check is made against the
+certificate's distinguished name. This is something that looks like
+\&\f(CW\*(C`C=GB,O=ACME,L=Boston,CN=bob\*(C'\fR. For \s-1SASL\s0 party, the \s-1ACL\s0 check is
+made against the username, which depending on the \s-1SASL\s0 plugin, may
+include a realm component, eg \f(CW\*(C`bob\*(C'\fR or \f(CW\*(C`bob@EXAMPLE.COM\*(C'\fR.
+When the \fBacl\fR flag is set, the initial access list will be
+empty, with a \f(CW\*(C`deny\*(C'\fR policy. Thus no one will be allowed to
+use the \s-1VNC\s0 server until the ACLs have been loaded. This can be
+achieved using the \f(CW\*(C`acl\*(C'\fR monitor command.
+.IP "\fBlossy\fR" 4
+.IX Item "lossy"
+Enable lossy compression methods (gradient, \s-1JPEG, ...\s0). If this
+option is set, \s-1VNC\s0 client may receive lossy framebuffer updates
+depending on its encoding settings. Enabling this option can save
+a lot of bandwidth at the expense of quality.
+.IP "\fBnon-adaptive\fR" 4
+.IX Item "non-adaptive"
+Disable adaptive encodings. Adaptive encodings are enabled by default.
+An adaptive encoding will try to detect frequently updated screen regions,
+and send updates in these regions using a lossy encoding (like \s-1JPEG\s0).
+This can be really helpful to save bandwidth when playing videos. Disabling
+adaptive encodings restores the original static behavior of encodings
+like Tight.
+.IP "\fBshare=[allow\-exclusive|force\-shared|ignore]\fR" 4
+.IX Item "share=[allow-exclusive|force-shared|ignore]"
+Set display sharing policy.  'allow\-exclusive' allows clients to ask
+for exclusive access.  As suggested by the rfb spec this is
+implemented by dropping other connections.  Connecting multiple
+clients in parallel requires all clients asking for a shared session
+(vncviewer: \-shared switch).  This is the default.  'force\-shared'
+disables exclusive client access.  Useful for shared desktop sessions,
+where you don't want someone forgetting specify \-shared disconnect
+everybody else.  'ignore' completely ignores the shared flag and
+allows everybody connect unconditionally.  Doesn't conform to the rfb
+spec but is traditional \s-1QEMU\s0 behavior.
+.RE
+.RS 4
+.RE
+.PP
+i386 target only:
+.IP "\fB\-win2k\-hack\fR" 4
+.IX Item "-win2k-hack"
+Use it when installing Windows 2000 to avoid a disk full bug. After
+Windows 2000 is installed, you no longer need this option (this option
+slows down the \s-1IDE\s0 transfers).
+.IP "\fB\-no\-fd\-bootchk\fR" 4
+.IX Item "-no-fd-bootchk"
+Disable boot signature checking for floppy disks in \s-1BIOS.\s0 May
+be needed to boot from old floppy disks.
+.IP "\fB\-no\-acpi\fR" 4
+.IX Item "-no-acpi"
+Disable \s-1ACPI \s0(Advanced Configuration and Power Interface) support. Use
+it if your guest \s-1OS\s0 complains about \s-1ACPI\s0 problems (\s-1PC\s0 target machine
+only).
+.IP "\fB\-no\-hpet\fR" 4
+.IX Item "-no-hpet"
+Disable \s-1HPET\s0 support.
+.IP "\fB\-acpitable [sig=\fR\fIstr\fR\fB][,rev=\fR\fIn\fR\fB][,oem_id=\fR\fIstr\fR\fB][,oem_table_id=\fR\fIstr\fR\fB][,oem_rev=\fR\fIn\fR\fB] [,asl_compiler_id=\fR\fIstr\fR\fB][,asl_compiler_rev=\fR\fIn\fR\fB][,data=\fR\fIfile1\fR\fB[:\fR\fIfile2\fR\fB]...]\fR" 4
+.IX Item "-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n] [,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]"
+Add \s-1ACPI\s0 table with specified header fields and context from specified files.
+For file=, take whole \s-1ACPI\s0 table from the specified files, including all
+\&\s-1ACPI\s0 headers (possible overridden by other options).
+For data=, only data
+portion of the table is used, all header information is specified in the
+command line.
+.IP "\fB\-smbios file=\fR\fIbinary\fR" 4
+.IX Item "-smbios file=binary"
+Load \s-1SMBIOS\s0 entry from binary file.
+.ie n .IP "\fB\-smbios type=0[,vendor=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,date=\fR\fIstr\fR\fB][,release=\fR\fI\fI%d\fI.%d\fR\fB][,uefi=on|off]\fR" 4
+.el .IP "\fB\-smbios type=0[,vendor=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,date=\fR\fIstr\fR\fB][,release=\fR\fI\f(CI%d\fI.%d\fR\fB][,uefi=on|off]\fR" 4
+.IX Item "-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d][,uefi=on|off]"
+Specify \s-1SMBIOS\s0 type 0 fields
+.IP "\fB\-smbios type=1[,manufacturer=\fR\fIstr\fR\fB][,product=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,uuid=\fR\fIuuid\fR\fB][,sku=\fR\fIstr\fR\fB][,family=\fR\fIstr\fR\fB]\fR" 4
+.IX Item "-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str][,uuid=uuid][,sku=str][,family=str]"
+Specify \s-1SMBIOS\s0 type 1 fields
+.IP "\fB\-smbios type=2[,manufacturer=\fR\fIstr\fR\fB][,product=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,asset=\fR\fIstr\fR\fB][,location=\fR\fIstr\fR\fB][,family=\fR\fIstr\fR\fB]\fR" 4
+.IX Item "-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str][,asset=str][,location=str][,family=str]"
+Specify \s-1SMBIOS\s0 type 2 fields
+.IP "\fB\-smbios type=3[,manufacturer=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,asset=\fR\fIstr\fR\fB][,sku=\fR\fIstr\fR\fB]\fR" 4
+.IX Item "-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str][,sku=str]"
+Specify \s-1SMBIOS\s0 type 3 fields
+.IP "\fB\-smbios type=4[,sock_pfx=\fR\fIstr\fR\fB][,manufacturer=\fR\fIstr\fR\fB][,version=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,asset=\fR\fIstr\fR\fB][,part=\fR\fIstr\fR\fB]\fR" 4
+.IX Item "-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str][,asset=str][,part=str]"
+Specify \s-1SMBIOS\s0 type 4 fields
+.ie n .IP "\fB\-smbios type=17[,loc_pfx=\fR\fIstr\fR\fB][,bank=\fR\fIstr\fR\fB][,manufacturer=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,asset=\fR\fIstr\fR\fB][,part=\fR\fIstr\fR\fB][,speed=\fR\fI\fI%d\fI\fR\fB]\fR" 4
+.el .IP "\fB\-smbios type=17[,loc_pfx=\fR\fIstr\fR\fB][,bank=\fR\fIstr\fR\fB][,manufacturer=\fR\fIstr\fR\fB][,serial=\fR\fIstr\fR\fB][,asset=\fR\fIstr\fR\fB][,part=\fR\fIstr\fR\fB][,speed=\fR\fI\f(CI%d\fI\fR\fB]\fR" 4
+.IX Item "-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str][,asset=str][,part=str][,speed=%d]"
+Specify \s-1SMBIOS\s0 type 17 fields
+.PP
+Network options:
+.IP "\fB\-net nic[,vlan=\fR\fIn\fR\fB][,macaddr=\fR\fImac\fR\fB][,model=\fR\fItype\fR\fB] [,name=\fR\fIname\fR\fB][,addr=\fR\fIaddr\fR\fB][,vectors=\fR\fIv\fR\fB]\fR" 4
+.IX Item "-net nic[,vlan=n][,macaddr=mac][,model=type] [,name=name][,addr=addr][,vectors=v]"
+Create a new Network Interface Card and connect it to \s-1VLAN \s0\fIn\fR (\fIn\fR
+= 0 is the default). The \s-1NIC\s0 is an e1000 by default on the \s-1PC\s0
+target. Optionally, the \s-1MAC\s0 address can be changed to \fImac\fR, the
+device address set to \fIaddr\fR (\s-1PCI\s0 cards only),
+and a \fIname\fR can be assigned for use in monitor commands.
+Optionally, for \s-1PCI\s0 cards, you can specify the number \fIv\fR of MSI-X vectors
+that the card should have; this option currently only affects virtio cards; set
+\&\fIv\fR = 0 to disable MSI-X. If no \fB\-net\fR option is specified, a single
+\&\s-1NIC\s0 is created.  \s-1QEMU\s0 can emulate several different models of network card.
+Valid values for \fItype\fR are
+\&\f(CW\*(C`virtio\*(C'\fR, \f(CW\*(C`i82551\*(C'\fR, \f(CW\*(C`i82557b\*(C'\fR, \f(CW\*(C`i82559er\*(C'\fR,
+\&\f(CW\*(C`ne2k_pci\*(C'\fR, \f(CW\*(C`ne2k_isa\*(C'\fR, \f(CW\*(C`pcnet\*(C'\fR, \f(CW\*(C`rtl8139\*(C'\fR,
+\&\f(CW\*(C`e1000\*(C'\fR, \f(CW\*(C`smc91c111\*(C'\fR, \f(CW\*(C`lance\*(C'\fR and \f(CW\*(C`mcf_fec\*(C'\fR.
+Not all devices are supported on all targets.  Use \f(CW\*(C`\-net nic,model=help\*(C'\fR
+for a list of available devices for your target.
+.IP "\fB\-netdev user,id=\fR\fIid\fR\fB[,\fR\fIoption\fR\fB][,\fR\fIoption\fR\fB][,...]\fR" 4
+.IX Item "-netdev user,id=id[,option][,option][,...]"
+.PD 0
+.IP "\fB\-net user[,\fR\fIoption\fR\fB][,\fR\fIoption\fR\fB][,...]\fR" 4
+.IX Item "-net user[,option][,option][,...]"
+.PD
+Use the user mode network stack which requires no administrator
+privilege to run. Valid options are:
+.RS 4
+.IP "\fBvlan=\fR\fIn\fR" 4
+.IX Item "vlan=n"
+Connect user mode stack to \s-1VLAN \s0\fIn\fR (\fIn\fR = 0 is the default).
+.IP "\fBid=\fR\fIid\fR" 4
+.IX Item "id=id"
+.PD 0
+.IP "\fBname=\fR\fIname\fR" 4
+.IX Item "name=name"
+.PD
+Assign symbolic name for use in monitor commands.
+.IP "\fBnet=\fR\fIaddr\fR\fB[/\fR\fImask\fR\fB]\fR" 4
+.IX Item "net=addr[/mask]"
+Set \s-1IP\s0 network address the guest will see. Optionally specify the netmask,
+either in the form a.b.c.d or as number of valid top-most bits. Default is
+10.0.2.0/24.
+.IP "\fBhost=\fR\fIaddr\fR" 4
+.IX Item "host=addr"
+Specify the guest-visible address of the host. Default is the 2nd \s-1IP\s0 in the
+guest network, i.e. x.x.x.2.
+.IP "\fBrestrict=on|off\fR" 4
+.IX Item "restrict=on|off"
+If this option is enabled, the guest will be isolated, i.e. it will not be
+able to contact the host and no guest \s-1IP\s0 packets will be routed over the host
+to the outside. This option does not affect any explicitly set forwarding rules.
+.IP "\fBhostname=\fR\fIname\fR" 4
+.IX Item "hostname=name"
+Specifies the client hostname reported by the built-in \s-1DHCP\s0 server.
+.IP "\fBdhcpstart=\fR\fIaddr\fR" 4
+.IX Item "dhcpstart=addr"
+Specify the first of the 16 IPs the built-in \s-1DHCP\s0 server can assign. Default
+is the 15th to 31st \s-1IP\s0 in the guest network, i.e. x.x.x.15 to x.x.x.31.
+.IP "\fBdns=\fR\fIaddr\fR" 4
+.IX Item "dns=addr"
+Specify the guest-visible address of the virtual nameserver. The address must
+be different from the host address. Default is the 3rd \s-1IP\s0 in the guest network,
+i.e. x.x.x.3.
+.IP "\fBdnssearch=\fR\fIdomain\fR" 4
+.IX Item "dnssearch=domain"
+Provides an entry for the domain-search list sent by the built-in
+\&\s-1DHCP\s0 server. More than one domain suffix can be transmitted by specifying
+this option multiple times. If supported, this will cause the guest to
+automatically try to append the given domain suffix(es) in case a domain name
+can not be resolved.
+.Sp
+Example:
+.Sp
+.Vb 1
+\&        qemu \-net user,dnssearch=mgmt.example.org,dnssearch=example.org [...]
+.Ve
+.IP "\fBtftp=\fR\fIdir\fR" 4
+.IX Item "tftp=dir"
+When using the user mode network stack, activate a built-in \s-1TFTP\s0
+server. The files in \fIdir\fR will be exposed as the root of a \s-1TFTP\s0 server.
+The \s-1TFTP\s0 client on the guest must be configured in binary mode (use the command
+\&\f(CW\*(C`bin\*(C'\fR of the Unix \s-1TFTP\s0 client).
+.IP "\fBbootfile=\fR\fIfile\fR" 4
+.IX Item "bootfile=file"
+When using the user mode network stack, broadcast \fIfile\fR as the \s-1BOOTP\s0
+filename. In conjunction with \fBtftp\fR, this can be used to network boot
+a guest from a local directory.
+.Sp
+Example (using pxelinux):
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-hda linux.img \-boot n \-net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
+.Ve
+.IP "\fBsmb=\fR\fIdir\fR\fB[,smbserver=\fR\fIaddr\fR\fB]\fR" 4
+.IX Item "smb=dir[,smbserver=addr]"
+When using the user mode network stack, activate a built-in \s-1SMB\s0
+server so that Windows OSes can access to the host files in \fI\fIdir\fI\fR
+transparently. The \s-1IP\s0 address of the \s-1SMB\s0 server can be set to \fIaddr\fR. By
+default the 4th \s-1IP\s0 in the guest network is used, i.e. x.x.x.4.
+.Sp
+In the guest Windows \s-1OS,\s0 the line:
+.Sp
+.Vb 1
+\&        10.0.2.4 smbserver
+.Ve
+.Sp
+must be added in the file \fIC:\eWINDOWS\eLMHOSTS\fR (for windows 9x/Me)
+or \fIC:\eWINNT\eSYSTEM32\eDRIVERS\eETC\eLMHOSTS\fR (Windows \s-1NT/2000\s0).
+.Sp
+Then \fI\fIdir\fI\fR can be accessed in \fI\esmbserver\eqemu\fR.
+.Sp
+Note that a \s-1SAMBA\s0 server must be installed on the host \s-1OS.
+QEMU\s0 was tested successfully with smbd versions from Red Hat 9,
+Fedora Core 3 and OpenSUSE 11.x.
+.IP "\fBhostfwd=[tcp|udp]:[\fR\fIhostaddr\fR\fB]:\fR\fIhostport\fR\fB\-[\fR\fIguestaddr\fR\fB]:\fR\fIguestport\fR" 4
+.IX Item "hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport"
+Redirect incoming \s-1TCP\s0 or \s-1UDP\s0 connections to the host port \fIhostport\fR to
+the guest \s-1IP\s0 address \fIguestaddr\fR on guest port \fIguestport\fR. If
+\&\fIguestaddr\fR is not specified, its value is x.x.x.15 (default first address
+given by the built-in \s-1DHCP\s0 server). By specifying \fIhostaddr\fR, the rule can
+be bound to a specific host interface. If no connection type is set, \s-1TCP\s0 is
+used. This option can be given multiple times.
+.Sp
+For example, to redirect host X11 connection from screen 1 to guest
+screen 0, use the following:
+.Sp
+.Vb 4
+\&        # on the host
+\&        qemu\-system\-i386 \-net user,hostfwd=tcp:127.0.0.1:6001\-:6000 [...]
+\&        # this host xterm should open in the guest X11 server
+\&        xterm \-display :1
+.Ve
+.Sp
+To redirect telnet connections from host port 5555 to telnet port on
+the guest, use the following:
+.Sp
+.Vb 3
+\&        # on the host
+\&        qemu\-system\-i386 \-net user,hostfwd=tcp::5555\-:23 [...]
+\&        telnet localhost 5555
+.Ve
+.Sp
+Then when you use on the host \f(CW\*(C`telnet localhost 5555\*(C'\fR, you
+connect to the guest telnet server.
+.IP "\fBguestfwd=[tcp]:\fR\fIserver\fR\fB:\fR\fIport\fR\fB\-\fR\fIdev\fR" 4
+.IX Item "guestfwd=[tcp]:server:port-dev"
+.PD 0
+.IP "\fBguestfwd=[tcp]:\fR\fIserver\fR\fB:\fR\fIport\fR\fB\-\fR\fIcmd:command\fR" 4
+.IX Item "guestfwd=[tcp]:server:port-cmd:command"
+.PD
+Forward guest \s-1TCP\s0 connections to the \s-1IP\s0 address \fIserver\fR on port \fIport\fR
+to the character device \fIdev\fR or to a program executed by \fIcmd:command\fR
+which gets spawned for each connection. This option can be given multiple times.
+.Sp
+You can either use a chardev directly and have that one used throughout \s-1QEMU\s0's
+lifetime, like in the following example:
+.Sp
+.Vb 3
+\&        # open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
+\&        # the guest accesses it
+\&        qemu \-net user,guestfwd=tcp:10.0.2.100:1234\-tcp:10.10.1.1:4321 [...]
+.Ve
+.Sp
+Or you can execute a command on every \s-1TCP\s0 connection established by the guest,
+so that \s-1QEMU\s0 behaves similar to an inetd process for that virtual server:
+.Sp
+.Vb 3
+\&        # call "netcat 10.10.1.1 4321" on every TCP connection to 10.0.2.100:1234
+\&        # and connect the TCP stream to its stdin/stdout
+\&        qemu \-net \*(Aquser,guestfwd=tcp:10.0.2.100:1234\-cmd:netcat 10.10.1.1 4321\*(Aq
+.Ve
+.RE
+.RS 4
+.Sp
+Note: Legacy stand-alone options \-tftp, \-bootp, \-smb and \-redir are still
+processed and applied to \-net user. Mixing them with the new configuration
+syntax gives undefined results. Their use for new applications is discouraged
+as they will be removed from future versions.
+.RE
+.IP "\fB\-netdev tap,id=\fR\fIid\fR\fB[,fd=\fR\fIh\fR\fB][,ifname=\fR\fIname\fR\fB][,script=\fR\fIfile\fR\fB][,downscript=\fR\fIdfile\fR\fB][,helper=\fR\fIhelper\fR\fB]\fR" 4
+.IX Item "-netdev tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]"
+.PD 0
+.IP "\fB\-net tap[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB][,fd=\fR\fIh\fR\fB][,ifname=\fR\fIname\fR\fB][,script=\fR\fIfile\fR\fB][,downscript=\fR\fIdfile\fR\fB][,helper=\fR\fIhelper\fR\fB]\fR" 4
+.IX Item "-net tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]"
+.PD
+Connect the host \s-1TAP\s0 network interface \fIname\fR to \s-1VLAN \s0\fIn\fR.
+.Sp
+Use the network script \fIfile\fR to configure it and the network script
+\&\fIdfile\fR to deconfigure it. If \fIname\fR is not provided, the \s-1OS\s0
+automatically provides one. The default network configure script is
+\&\fI/etc/qemu\-ifup\fR and the default network deconfigure script is
+\&\fI/etc/qemu\-ifdown\fR. Use \fBscript=no\fR or \fBdownscript=no\fR
+to disable script execution.
+.Sp
+If running \s-1QEMU\s0 as an unprivileged user, use the network helper
+\&\fIhelper\fR to configure the \s-1TAP\s0 interface. The default network
+helper executable is \fI/path/to/qemu\-bridge\-helper\fR.
+.Sp
+\&\fBfd\fR=\fIh\fR can be used to specify the handle of an already
+opened host \s-1TAP\s0 interface.
+.Sp
+Examples:
+.Sp
+.Vb 2
+\&        #launch a QEMU instance with the default network script
+\&        qemu\-system\-i386 linux.img \-net nic \-net tap
+\&
+\&
+\&        
+\&        #launch a QEMU instance with two NICs, each one connected
+\&        #to a TAP device
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,vlan=0 \-net tap,vlan=0,ifname=tap0 \e
+\&        \-net nic,vlan=1 \-net tap,vlan=1,ifname=tap1
+\&
+\&
+\&        
+\&        #launch a QEMU instance with the default network helper to
+\&        #connect a TAP device to bridge br0
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic \-net tap,"helper=/path/to/qemu\-bridge\-helper"
+.Ve
+.IP "\fB\-netdev bridge,id=\fR\fIid\fR\fB[,br=\fR\fIbridge\fR\fB][,helper=\fR\fIhelper\fR\fB]\fR" 4
+.IX Item "-netdev bridge,id=id[,br=bridge][,helper=helper]"
+.PD 0
+.IP "\fB\-net bridge[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB][,br=\fR\fIbridge\fR\fB][,helper=\fR\fIhelper\fR\fB]\fR" 4
+.IX Item "-net bridge[,vlan=n][,name=name][,br=bridge][,helper=helper]"
+.PD
+Connect a host \s-1TAP\s0 network interface to a host bridge device.
+.Sp
+Use the network helper \fIhelper\fR to configure the \s-1TAP\s0 interface and
+attach it to the bridge. The default network helper executable is
+\&\fI/path/to/qemu\-bridge\-helper\fR and the default bridge
+device is \fIbr0\fR.
+.Sp
+Examples:
+.Sp
+.Vb 3
+\&        #launch a QEMU instance with the default network helper to
+\&        #connect a TAP device to bridge br0
+\&        qemu\-system\-i386 linux.img \-net bridge \-net nic,model=virtio
+\&
+\&
+\&        
+\&        #launch a QEMU instance with the default network helper to
+\&        #connect a TAP device to bridge qemubr0
+\&        qemu\-system\-i386 linux.img \-net bridge,br=qemubr0 \-net nic,model=virtio
+.Ve
+.IP "\fB\-netdev socket,id=\fR\fIid\fR\fB[,fd=\fR\fIh\fR\fB][,listen=[\fR\fIhost\fR\fB]:\fR\fIport\fR\fB][,connect=\fR\fIhost\fR\fB:\fR\fIport\fR\fB]\fR" 4
+.IX Item "-netdev socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]"
+.PD 0
+.IP "\fB\-net socket[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB][,fd=\fR\fIh\fR\fB] [,listen=[\fR\fIhost\fR\fB]:\fR\fIport\fR\fB][,connect=\fR\fIhost\fR\fB:\fR\fIport\fR\fB]\fR" 4
+.IX Item "-net socket[,vlan=n][,name=name][,fd=h] [,listen=[host]:port][,connect=host:port]"
+.PD
+Connect the \s-1VLAN \s0\fIn\fR to a remote \s-1VLAN\s0 in another \s-1QEMU\s0 virtual
+machine using a \s-1TCP\s0 socket connection. If \fBlisten\fR is
+specified, \s-1QEMU\s0 waits for incoming connections on \fIport\fR
+(\fIhost\fR is optional). \fBconnect\fR is used to connect to
+another \s-1QEMU\s0 instance using the \fBlisten\fR option. \fBfd\fR=\fIh\fR
+specifies an already opened \s-1TCP\s0 socket.
+.Sp
+Example:
+.Sp
+.Vb 9
+\&        # launch a first QEMU instance
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:56 \e
+\&        \-net socket,listen=:1234
+\&        # connect the VLAN 0 of this instance to the VLAN 0
+\&        # of the first instance
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:57 \e
+\&        \-net socket,connect=127.0.0.1:1234
+.Ve
+.IP "\fB\-netdev socket,id=\fR\fIid\fR\fB[,fd=\fR\fIh\fR\fB][,mcast=\fR\fImaddr\fR\fB:\fR\fIport\fR\fB[,localaddr=\fR\fIaddr\fR\fB]]\fR" 4
+.IX Item "-netdev socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]]"
+.PD 0
+.IP "\fB\-net socket[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB][,fd=\fR\fIh\fR\fB][,mcast=\fR\fImaddr\fR\fB:\fR\fIport\fR\fB[,localaddr=\fR\fIaddr\fR\fB]]\fR" 4
+.IX Item "-net socket[,vlan=n][,name=name][,fd=h][,mcast=maddr:port[,localaddr=addr]]"
+.PD
+Create a \s-1VLAN \s0\fIn\fR shared with another \s-1QEMU\s0 virtual
+machines using a \s-1UDP\s0 multicast socket, effectively making a bus for
+every \s-1QEMU\s0 with same multicast address \fImaddr\fR and \fIport\fR.
+\&\s-1NOTES:\s0
+.RS 4
+.IP "1." 4
+Several \s-1QEMU\s0 can be running on different hosts and share same bus (assuming
+correct multicast setup for these hosts).
+.IP "2." 4
+mcast support is compatible with User Mode Linux (argument \fBeth\fR\fIN\fR\fB=mcast\fR), see
+<\fBhttp://user\-mode\-linux.sf.net\fR>.
+.IP "3." 4
+Use \fBfd=h\fR to specify an already opened \s-1UDP\s0 multicast socket.
+.RE
+.RS 4
+.Sp
+Example:
+.Sp
+.Vb 12
+\&        # launch one QEMU instance
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:56 \e
+\&        \-net socket,mcast=230.0.0.1:1234
+\&        # launch another QEMU instance on same "bus"
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:57 \e
+\&        \-net socket,mcast=230.0.0.1:1234
+\&        # launch yet another QEMU instance on same "bus"
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:58 \e
+\&        \-net socket,mcast=230.0.0.1:1234
+.Ve
+.Sp
+Example (User Mode Linux compat.):
+.Sp
+.Vb 7
+\&        # launch QEMU instance (note mcast address selected
+\&        # is UML\*(Aqs default)
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:56 \e
+\&        \-net socket,mcast=239.192.168.1:1102
+\&        # launch UML
+\&        /path/to/linux ubd0=/path/to/root_fs eth0=mcast
+.Ve
+.Sp
+Example (send packets from host's 1.2.3.4):
+.Sp
+.Vb 3
+\&        qemu\-system\-i386 linux.img \e
+\&        \-net nic,macaddr=52:54:00:12:34:56 \e
+\&        \-net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4
+.Ve
+.RE
+.IP "\fB\-netdev l2tpv3,id=\fR\fIid\fR\fB,src=\fR\fIsrcaddr\fR\fB,dst=\fR\fIdstaddr\fR\fB[,srcport=\fR\fIsrcport\fR\fB][,dstport=\fR\fIdstport\fR\fB],txsession=\fR\fItxsession\fR\fB[,rxsession=\fR\fIrxsession\fR\fB][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=\fR\fItxcookie\fR\fB][,rxcookie=\fR\fIrxcookie\fR\fB][,offset=\fR\fIoffset\fR\fB]\fR" 4
+.IX Item "-netdev l2tpv3,id=id,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]"
+.PD 0
+.IP "\fB\-net l2tpv3[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB],src=\fR\fIsrcaddr\fR\fB,dst=\fR\fIdstaddr\fR\fB[,srcport=\fR\fIsrcport\fR\fB][,dstport=\fR\fIdstport\fR\fB],txsession=\fR\fItxsession\fR\fB[,rxsession=\fR\fIrxsession\fR\fB][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=\fR\fItxcookie\fR\fB][,rxcookie=\fR\fIrxcookie\fR\fB][,offset=\fR\fIoffset\fR\fB]\fR" 4
+.IX Item "-net l2tpv3[,vlan=n][,name=name],src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]"
+.PD
+Connect \s-1VLAN \s0\fIn\fR to L2TPv3 pseudowire. L2TPv3 (\s-1RFC3391\s0) is a popular
+protocol to transport Ethernet (and other Layer 2) data frames between
+two systems. It is present in routers, firewalls and the Linux kernel
+(from version 3.3 onwards).
+.Sp
+This transport allows a \s-1VM\s0 to communicate to another \s-1VM,\s0 router or firewall directly.
+.IP "\fBsrc=\fR\fIsrcaddr\fR" 4
+.IX Item "src=srcaddr"
+source address (mandatory)
+.IP "\fBdst=\fR\fIdstaddr\fR" 4
+.IX Item "dst=dstaddr"
+destination address (mandatory)
+.IP "\fBudp\fR" 4
+.IX Item "udp"
+select udp encapsulation (default is ip).
+.IP "\fBsrcport=\fR\fIsrcport\fR" 4
+.IX Item "srcport=srcport"
+source udp port.
+.IP "\fBdstport=\fR\fIdstport\fR" 4
+.IX Item "dstport=dstport"
+destination udp port.
+.IP "\fBipv6\fR" 4
+.IX Item "ipv6"
+force v6, otherwise defaults to v4.
+.IP "\fBrxcookie=\fR\fIrxcookie\fR" 4
+.IX Item "rxcookie=rxcookie"
+.PD 0
+.IP "\fBtxcookie=\fR\fItxcookie\fR" 4
+.IX Item "txcookie=txcookie"
+.PD
+Cookies are a weak form of security in the l2tpv3 specification.
+Their function is mostly to prevent misconfiguration. By default they are 32
+bit.
+.IP "\fBcookie64\fR" 4
+.IX Item "cookie64"
+Set cookie size to 64 bit instead of the default 32
+.IP "\fBcounter=off\fR" 4
+.IX Item "counter=off"
+Force a 'cut\-down' L2TPv3 with no counter as in
+draft\-mkonstan\-l2tpext\-keyed\-ipv6\-tunnel\-00
+.IP "\fBpincounter=on\fR" 4
+.IX Item "pincounter=on"
+Work around broken counter handling in peer. This may also help on
+networks which have packet reorder.
+.IP "\fBoffset=\fR\fIoffset\fR" 4
+.IX Item "offset=offset"
+Add an extra offset between header and data
+.Sp
+For example, to attach a \s-1VM\s0 running on host 4.3.2.1 via L2TPv3 to the bridge br-lan
+on the remote Linux host 1.2.3.4:
+.Sp
+.Vb 9
+\&        # Setup tunnel on linux host using raw ip as encapsulation
+\&        # on 1.2.3.4
+\&        ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \e
+\&        encap udp udp_sport 16384 udp_dport 16384
+\&        ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \e
+\&        0xFFFFFFFF peer_session_id 0xFFFFFFFF
+\&        ifconfig vmtunnel0 mtu 1500
+\&        ifconfig vmtunnel0 up
+\&        brctl addif br\-lan vmtunnel0
+\&        
+\&        
+\&        # on 4.3.2.1
+\&        # launch QEMU instance \- if your network has reorder or is very lossy add ,pincounter
+\&        
+\&        qemu\-system\-i386 linux.img \-net nic \-net l2tpv3,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter
+.Ve
+.IP "\fB\-netdev vde,id=\fR\fIid\fR\fB[,sock=\fR\fIsocketpath\fR\fB][,port=\fR\fIn\fR\fB][,group=\fR\fIgroupname\fR\fB][,mode=\fR\fIoctalmode\fR\fB]\fR" 4
+.IX Item "-netdev vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]"
+.PD 0
+.IP "\fB\-net vde[,vlan=\fR\fIn\fR\fB][,name=\fR\fIname\fR\fB][,sock=\fR\fIsocketpath\fR\fB] [,port=\fR\fIn\fR\fB][,group=\fR\fIgroupname\fR\fB][,mode=\fR\fIoctalmode\fR\fB]\fR" 4
+.IX Item "-net vde[,vlan=n][,name=name][,sock=socketpath] [,port=n][,group=groupname][,mode=octalmode]"
+.PD
+Connect \s-1VLAN \s0\fIn\fR to \s-1PORT \s0\fIn\fR of a vde switch running on host and
+listening for incoming connections on \fIsocketpath\fR. Use \s-1GROUP \s0\fIgroupname\fR
+and \s-1MODE \s0\fIoctalmode\fR to change default ownership and permissions for
+communication port. This option is only available if \s-1QEMU\s0 has been compiled
+with vde support enabled.
+.Sp
+Example:
+.Sp
+.Vb 4
+\&        # launch vde switch
+\&        vde_switch \-F \-sock /tmp/myswitch
+\&        # launch QEMU instance
+\&        qemu\-system\-i386 linux.img \-net nic \-net vde,sock=/tmp/myswitch
+.Ve
+.IP "\fB\-netdev hubport,id=\fR\fIid\fR\fB,hubid=\fR\fIhubid\fR" 4
+.IX Item "-netdev hubport,id=id,hubid=hubid"
+Create a hub port on \s-1QEMU \s0\*(L"vlan\*(R" \fIhubid\fR.
+.Sp
+The hubport netdev lets you connect a \s-1NIC\s0 to a \s-1QEMU \s0\*(L"vlan\*(R" instead of a single
+netdev.  \f(CW\*(C`\-net\*(C'\fR and \f(CW\*(C`\-device\*(C'\fR with parameter \fBvlan\fR create the
+required hub automatically.
+.IP "\fB\-netdev vhost\-user,chardev=\fR\fIid\fR\fB[,vhostforce=on|off]\fR" 4
+.IX Item "-netdev vhost-user,chardev=id[,vhostforce=on|off]"
+Establish a vhost-user netdev, backed by a chardev \fIid\fR. The chardev should
+be a unix domain socket backed one. The vhost-user uses a specifically defined
+protocol to pass vhost ioctl replacement messages to an application on the other
+end of the socket. On non-MSIX guests, the feature can be forced with
+\&\fIvhostforce\fR.
+.Sp
+Example:
+.Sp
+.Vb 5
+\&        qemu \-m 512 \-object memory\-backend\-file,id=mem,size=512M,mem\-path=/hugetlbfs,share=on \e
+\&        \-numa node,memdev=mem \e
+\&        \-chardev socket,path=/path/to/socket \e
+\&        \-netdev type=vhost\-user,id=net0,chardev=chr0 \e
+\&        \-device virtio\-net\-pci,netdev=net0
+.Ve
+.IP "\fB\-net dump[,vlan=\fR\fIn\fR\fB][,file=\fR\fIfile\fR\fB][,len=\fR\fIlen\fR\fB]\fR" 4
+.IX Item "-net dump[,vlan=n][,file=file][,len=len]"
+Dump network traffic on \s-1VLAN \s0\fIn\fR to file \fIfile\fR (\fIqemu\-vlan0.pcap\fR by default).
+At most \fIlen\fR bytes (64k by default) per packet are stored. The file format is
+libpcap, so it can be analyzed with tools such as tcpdump or Wireshark.
+.IP "\fB\-net none\fR" 4
+.IX Item "-net none"
+Indicate that no network devices should be configured. It is used to
+override the default configuration (\fB\-net nic \-net user\fR) which
+is activated if no \fB\-net\fR options are provided.
+.PP
+Character device options:
+.PP
+The general form of a character device option is:
+.IP "\fB\-chardev\fR \fIbackend\fR \fB,id=\fR\fIid\fR \fB[,mux=on|off] [,\fR\fIoptions\fR\fB]\fR" 4
+.IX Item "-chardev backend ,id=id [,mux=on|off] [,options]"
+Backend is one of:
+\&\fBnull\fR,
+\&\fBsocket\fR,
+\&\fBudp\fR,
+\&\fBmsmouse\fR,
+\&\fBvc\fR,
+\&\fBringbuf\fR,
+\&\fBfile\fR,
+\&\fBpipe\fR,
+\&\fBconsole\fR,
+\&\fBserial\fR,
+\&\fBpty\fR,
+\&\fBstdio\fR,
+\&\fBbraille\fR,
+\&\fBtty\fR,
+\&\fBparallel\fR,
+\&\fBparport\fR,
+\&\fBspicevmc\fR.
+\&\fBspiceport\fR.
+The specific backend will determine the applicable options.
+.Sp
+All devices must have an id, which can be any string up to 127 characters long.
+It is used to uniquely identify this device in other command line directives.
+.Sp
+A character device may be used in multiplexing mode by multiple front-ends.
+The key sequence of \fBControl-a\fR and \fBc\fR will rotate the input focus
+between attached front-ends. Specify \fBmux=on\fR to enable this mode.
+.Sp
+Options to each backend are described below.
+.IP "\fB\-chardev null ,id=\fR\fIid\fR" 4
+.IX Item "-chardev null ,id=id"
+A void device. This device will not emit any data, and will drop any data it
+receives. The null backend does not take any options.
+.IP "\fB\-chardev socket ,id=\fR\fIid\fR \fB[\fR\fI\s-1TCP\s0 options\fR \fBor\fR \fIunix options\fR\fB] [,server] [,nowait] [,telnet] [,reconnect=\fR\fIseconds\fR\fB]\fR" 4
+.IX Item "-chardev socket ,id=id [TCP options or unix options] [,server] [,nowait] [,telnet] [,reconnect=seconds]"
+Create a two-way stream socket, which can be either a \s-1TCP\s0 or a unix socket. A
+unix socket will be created if \fBpath\fR is specified. Behaviour is
+undefined if \s-1TCP\s0 options are specified for a unix socket.
+.Sp
+\&\fBserver\fR specifies that the socket shall be a listening socket.
+.Sp
+\&\fBnowait\fR specifies that \s-1QEMU\s0 should not block waiting for a client to
+connect to a listening socket.
+.Sp
+\&\fBtelnet\fR specifies that traffic on the socket should interpret telnet
+escape sequences.
+.Sp
+\&\fBreconnect\fR sets the timeout for reconnecting on non-server sockets when
+the remote end goes away.  qemu will delay this many seconds and then attempt
+to reconnect.  Zero disables reconnecting, and is the default.
+.Sp
+\&\s-1TCP\s0 and unix socket options are given below:
+.RS 4
+.IP "\fB\s-1TCP\s0 options: port=\fR\fIport\fR \fB[,host=\fR\fIhost\fR\fB] [,to=\fR\fIto\fR\fB] [,ipv4] [,ipv6] [,nodelay]\fR" 4
+.IX Item "TCP options: port=port [,host=host] [,to=to] [,ipv4] [,ipv6] [,nodelay]"
+\&\fBhost\fR for a listening socket specifies the local address to be bound.
+For a connecting socket species the remote host to connect to. \fBhost\fR is
+optional for listening sockets. If not specified it defaults to \f(CW0.0.0.0\fR.
+.Sp
+\&\fBport\fR for a listening socket specifies the local port to be bound. For a
+connecting socket specifies the port on the remote host to connect to.
+\&\fBport\fR can be given as either a port number or a service name.
+\&\fBport\fR is required.
+.Sp
+\&\fBto\fR is only relevant to listening sockets. If it is specified, and
+\&\fBport\fR cannot be bound, \s-1QEMU\s0 will attempt to bind to subsequent ports up
+to and including \fBto\fR until it succeeds. \fBto\fR must be specified
+as a port number.
+.Sp
+\&\fBipv4\fR and \fBipv6\fR specify that either IPv4 or IPv6 must be used.
+If neither is specified the socket may use either protocol.
+.Sp
+\&\fBnodelay\fR disables the Nagle algorithm.
+.IP "\fBunix options: path=\fR\fIpath\fR" 4
+.IX Item "unix options: path=path"
+\&\fBpath\fR specifies the local path of the unix socket. \fBpath\fR is
+required.
+.RE
+.RS 4
+.RE
+.IP "\fB\-chardev udp ,id=\fR\fIid\fR \fB[,host=\fR\fIhost\fR\fB] ,port=\fR\fIport\fR \fB[,localaddr=\fR\fIlocaladdr\fR\fB] [,localport=\fR\fIlocalport\fR\fB] [,ipv4] [,ipv6]\fR" 4
+.IX Item "-chardev udp ,id=id [,host=host] ,port=port [,localaddr=localaddr] [,localport=localport] [,ipv4] [,ipv6]"
+Sends all traffic from the guest to a remote host over \s-1UDP.\s0
+.Sp
+\&\fBhost\fR specifies the remote host to connect to. If not specified it
+defaults to \f(CW\*(C`localhost\*(C'\fR.
+.Sp
+\&\fBport\fR specifies the port on the remote host to connect to. \fBport\fR
+is required.
+.Sp
+\&\fBlocaladdr\fR specifies the local address to bind to. If not specified it
+defaults to \f(CW0.0.0.0\fR.
+.Sp
+\&\fBlocalport\fR specifies the local port to bind to. If not specified any
+available local port will be used.
+.Sp
+\&\fBipv4\fR and \fBipv6\fR specify that either IPv4 or IPv6 must be used.
+If neither is specified the device may use either protocol.
+.IP "\fB\-chardev msmouse ,id=\fR\fIid\fR" 4
+.IX Item "-chardev msmouse ,id=id"
+Forward \s-1QEMU\s0's emulated msmouse events to the guest. \fBmsmouse\fR does not
+take any options.
+.IP "\fB\-chardev vc ,id=\fR\fIid\fR \fB[[,width=\fR\fIwidth\fR\fB] [,height=\fR\fIheight\fR\fB]] [[,cols=\fR\fIcols\fR\fB] [,rows=\fR\fIrows\fR\fB]]\fR" 4
+.IX Item "-chardev vc ,id=id [[,width=width] [,height=height]] [[,cols=cols] [,rows=rows]]"
+Connect to a \s-1QEMU\s0 text console. \fBvc\fR may optionally be given a specific
+size.
+.Sp
+\&\fBwidth\fR and \fBheight\fR specify the width and height respectively of
+the console, in pixels.
+.Sp
+\&\fBcols\fR and \fBrows\fR specify that the console be sized to fit a text
+console with the given dimensions.
+.IP "\fB\-chardev ringbuf ,id=\fR\fIid\fR \fB[,size=\fR\fIsize\fR\fB]\fR" 4
+.IX Item "-chardev ringbuf ,id=id [,size=size]"
+Create a ring buffer with fixed size \fBsize\fR.
+\&\fIsize\fR must be a power of two, and defaults to \f(CW\*(C`64K\*(C'\fR).
+.IP "\fB\-chardev file ,id=\fR\fIid\fR \fB,path=\fR\fIpath\fR" 4
+.IX Item "-chardev file ,id=id ,path=path"
+Log all traffic received from the guest to a file.
+.Sp
+\&\fBpath\fR specifies the path of the file to be opened. This file will be
+created if it does not already exist, and overwritten if it does. \fBpath\fR
+is required.
+.IP "\fB\-chardev pipe ,id=\fR\fIid\fR \fB,path=\fR\fIpath\fR" 4
+.IX Item "-chardev pipe ,id=id ,path=path"
+Create a two-way connection to the guest. The behaviour differs slightly between
+Windows hosts and other hosts:
+.Sp
+On Windows, a single duplex pipe will be created at
+\&\fI\e.pipe\e\f(BIpath\fI\fR.
+.Sp
+On other hosts, 2 pipes will be created called \fI\f(BIpath\fI.in\fR and
+\&\fI\f(BIpath\fI.out\fR. Data written to \fI\f(BIpath\fI.in\fR will be
+received by the guest. Data written by the guest can be read from
+\&\fI\f(BIpath\fI.out\fR. \s-1QEMU\s0 will not create these fifos, and requires them to
+be present.
+.Sp
+\&\fBpath\fR forms part of the pipe path as described above. \fBpath\fR is
+required.
+.IP "\fB\-chardev console ,id=\fR\fIid\fR" 4
+.IX Item "-chardev console ,id=id"
+Send traffic from the guest to \s-1QEMU\s0's standard output. \fBconsole\fR does not
+take any options.
+.Sp
+\&\fBconsole\fR is only available on Windows hosts.
+.IP "\fB\-chardev serial ,id=\fR\fIid\fR \fB,path=\fR\fBpath\fR" 4
+.IX Item "-chardev serial ,id=id ,path=path"
+Send traffic from the guest to a serial device on the host.
+.Sp
+On Unix hosts serial will actually accept any tty device,
+not only serial lines.
+.Sp
+\&\fBpath\fR specifies the name of the serial device to open.
+.IP "\fB\-chardev pty ,id=\fR\fIid\fR" 4
+.IX Item "-chardev pty ,id=id"
+Create a new pseudo-terminal on the host and connect to it. \fBpty\fR does
+not take any options.
+.Sp
+\&\fBpty\fR is not available on Windows hosts.
+.IP "\fB\-chardev stdio ,id=\fR\fIid\fR \fB[,signal=on|off]\fR" 4
+.IX Item "-chardev stdio ,id=id [,signal=on|off]"
+Connect to standard input and standard output of the \s-1QEMU\s0 process.
+.Sp
+\&\fBsignal\fR controls if signals are enabled on the terminal, that includes
+exiting \s-1QEMU\s0 with the key sequence \fBControl-c\fR. This option is enabled by
+default, use \fBsignal=off\fR to disable it.
+.Sp
+\&\fBstdio\fR is not available on Windows hosts.
+.IP "\fB\-chardev braille ,id=\fR\fIid\fR" 4
+.IX Item "-chardev braille ,id=id"
+Connect to a local BrlAPI server. \fBbraille\fR does not take any options.
+.IP "\fB\-chardev tty ,id=\fR\fIid\fR \fB,path=\fR\fIpath\fR" 4
+.IX Item "-chardev tty ,id=id ,path=path"
+\&\fBtty\fR is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and
+DragonFlyBSD hosts.  It is an alias for \fBserial\fR.
+.Sp
+\&\fBpath\fR specifies the path to the tty. \fBpath\fR is required.
+.IP "\fB\-chardev parallel ,id=\fR\fIid\fR \fB,path=\fR\fIpath\fR" 4
+.IX Item "-chardev parallel ,id=id ,path=path"
+.PD 0
+.IP "\fB\-chardev parport ,id=\fR\fIid\fR \fB,path=\fR\fIpath\fR" 4
+.IX Item "-chardev parport ,id=id ,path=path"
+.PD
+\&\fBparallel\fR is only available on Linux, FreeBSD and DragonFlyBSD hosts.
+.Sp
+Connect to a local parallel port.
+.Sp
+\&\fBpath\fR specifies the path to the parallel port device. \fBpath\fR is
+required.
+.IP "\fB\-chardev spicevmc ,id=\fR\fIid\fR \fB,debug=\fR\fIdebug\fR\fB, name=\fR\fIname\fR" 4
+.IX Item "-chardev spicevmc ,id=id ,debug=debug, name=name"
+\&\fBspicevmc\fR is only available when spice support is built in.
+.Sp
+\&\fBdebug\fR debug level for spicevmc
+.Sp
+\&\fBname\fR name of spice channel to connect to
+.Sp
+Connect to a spice virtual machine channel, such as vdiport.
+.IP "\fB\-chardev spiceport ,id=\fR\fIid\fR \fB,debug=\fR\fIdebug\fR\fB, name=\fR\fIname\fR" 4
+.IX Item "-chardev spiceport ,id=id ,debug=debug, name=name"
+\&\fBspiceport\fR is only available when spice support is built in.
+.Sp
+\&\fBdebug\fR debug level for spicevmc
+.Sp
+\&\fBname\fR name of spice port to connect to
+.Sp
+Connect to a spice port, allowing a Spice client to handle the traffic
+identified by a name (preferably a fqdn).
+.PP
+Device \s-1URL\s0 Syntax:
+.PP
+In addition to using normal file images for the emulated storage devices,
+\&\s-1QEMU\s0 can also use networked resources such as iSCSI devices. These are
+specified using a special \s-1URL\s0 syntax.
+.IP "\fBiSCSI\fR" 4
+.IX Item "iSCSI"
+iSCSI support allows \s-1QEMU\s0 to access iSCSI resources directly and use as
+images for the guest storage. Both disk and cdrom images are supported.
+.Sp
+Syntax for specifying iSCSI LUNs is
+\&\*(L"iscsi://<target\-ip>[:<port>]/<target\-iqn>/<lun>\*(R"
+.Sp
+By default qemu will use the iSCSI initiator-name
+\&'iqn.2008\-11.org.linux\-kvm[:<name>]' but this can also be set from the command
+line or a configuration file.
+.Sp
+Example (without authentication):
+.Sp
+.Vb 3
+\&        qemu\-system\-i386 \-iscsi initiator\-name=iqn.2001\-04.com.example:my\-initiator \e
+\&        \-cdrom iscsi://192.0.2.1/iqn.2001\-04.com.example/2 \e
+\&        \-drive file=iscsi://192.0.2.1/iqn.2001\-04.com.example/1
+.Ve
+.Sp
+Example (\s-1CHAP\s0 username/password via \s-1URL\s0):
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-drive file=iscsi://user%password@192.0.2.1/iqn.2001\-04.com.example/1
+.Ve
+.Sp
+Example (\s-1CHAP\s0 username/password via environment variables):
+.Sp
+.Vb 3
+\&        LIBISCSI_CHAP_USERNAME="user" \e
+\&        LIBISCSI_CHAP_PASSWORD="password" \e
+\&        qemu\-system\-i386 \-drive file=iscsi://192.0.2.1/iqn.2001\-04.com.example/1
+.Ve
+.Sp
+iSCSI support is an optional feature of \s-1QEMU\s0 and only available when
+compiled and linked against libiscsi.
+.Sp
+iSCSI parameters such as username and password can also be specified via
+a configuration file. See qemu-doc for more information and examples.
+.IP "\fB\s-1NBD\s0\fR" 4
+.IX Item "NBD"
+\&\s-1QEMU\s0 supports \s-1NBD \s0(Network Block Devices) both using \s-1TCP\s0 protocol as well
+as Unix Domain Sockets.
+.Sp
+Syntax for specifying a \s-1NBD\s0 device using \s-1TCP
+\&\s0\*(L"nbd:<server\-ip>:<port>[:exportname=<export>]\*(R"
+.Sp
+Syntax for specifying a \s-1NBD\s0 device using Unix Domain Sockets
+\&\*(L"nbd:unix:<domain\-socket>[:exportname=<export>]\*(R"
+.Sp
+Example for \s-1TCP\s0
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-\-drive file=nbd:192.0.2.1:30000
+.Ve
+.Sp
+Example for Unix Domain Sockets
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-\-drive file=nbd:unix:/tmp/nbd\-socket
+.Ve
+.IP "\fB\s-1SSH\s0\fR" 4
+.IX Item "SSH"
+\&\s-1QEMU\s0 supports \s-1SSH \s0(Secure Shell) access to remote disks.
+.Sp
+Examples:
+.Sp
+.Vb 2
+\&        qemu\-system\-i386 \-drive file=ssh://user@host/path/to/disk.img
+\&        qemu\-system\-i386 \-drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img
+.Ve
+.Sp
+Currently authentication must be done using ssh-agent.  Other
+authentication methods may be supported in future.
+.IP "\fBSheepdog\fR" 4
+.IX Item "Sheepdog"
+Sheepdog is a distributed storage system for \s-1QEMU.
+QEMU\s0 supports using either local sheepdog devices or remote networked
+devices.
+.Sp
+Syntax for specifying a sheepdog device
+.Sp
+.Vb 1
+\&        sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]
+.Ve
+.Sp
+Example
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 \-\-drive file=sheepdog://192.0.2.1:30000/MyVirtualMachine
+.Ve
+.Sp
+See also <\fBhttp://http://www.osrg.net/sheepdog/\fR>.
+.IP "\fBGlusterFS\fR" 4
+.IX Item "GlusterFS"
+GlusterFS is an user space distributed file system.
+\&\s-1QEMU\s0 supports the use of GlusterFS volumes for hosting \s-1VM\s0 disk images using
+\&\s-1TCP,\s0 Unix Domain Sockets and \s-1RDMA\s0 transport protocols.
+.Sp
+Syntax for specifying a \s-1VM\s0 disk image on GlusterFS volume is
+.Sp
+.Vb 1
+\&        gluster[+transport]://[server[:port]]/volname/image[?socket=...]
+.Ve
+.Sp
+Example
+.Sp
+.Vb 1
+\&        qemu\-system\-x86_64 \-\-drive file=gluster://192.0.2.1/testvol/a.img
+.Ve
+.Sp
+See also <\fBhttp://www.gluster.org\fR>.
+.IP "\fB\s-1HTTP/HTTPS/FTP/FTPS/TFTP\s0\fR" 4
+.IX Item "HTTP/HTTPS/FTP/FTPS/TFTP"
+\&\s-1QEMU\s0 supports read-only access to files accessed over http(s), ftp(s) and tftp.
+.Sp
+Syntax using a single filename:
+.Sp
+.Vb 1
+\&        <protocol>://[<username>[:<password>]@]<host>/<path>
+.Ve
+.Sp
+where:
+.RS 4
+.IP "\fBprotocol\fR" 4
+.IX Item "protocol"
+\&'http', 'https', 'ftp', 'ftps', or 'tftp'.
+.IP "\fBusername\fR" 4
+.IX Item "username"
+Optional username for authentication to the remote server.
+.IP "\fBpassword\fR" 4
+.IX Item "password"
+Optional password for authentication to the remote server.
+.IP "\fBhost\fR" 4
+.IX Item "host"
+Address of the remote server.
+.IP "\fBpath\fR" 4
+.IX Item "path"
+Path on the remote server, including any query string.
+.RE
+.RS 4
+.Sp
+The following options are also supported:
+.IP "\fBurl\fR" 4
+.IX Item "url"
+The full \s-1URL\s0 when passing options to the driver explicitly.
+.IP "\fBreadahead\fR" 4
+.IX Item "readahead"
+The amount of data to read ahead with each range request to the remote server.
+This value may optionally have the suffix 'T', 'G', 'M', 'K', 'k' or 'b'. If it
+does not have a suffix, it will be assumed to be in bytes. The value must be a
+multiple of 512 bytes. It defaults to 256k.
+.IP "\fBsslverify\fR" 4
+.IX Item "sslverify"
+Whether to verify the remote server's certificate when connecting over \s-1SSL.\s0 It
+can have the value 'on' or 'off'. It defaults to 'on'.
+.IP "\fBcookie\fR" 4
+.IX Item "cookie"
+Send this cookie (it can also be a list of cookies separated by ';') with
+each outgoing request.  Only supported when using protocols such as \s-1HTTP\s0
+which support cookies, otherwise ignored.
+.IP "\fBtimeout\fR" 4
+.IX Item "timeout"
+Set the timeout in seconds of the \s-1CURL\s0 connection. This timeout is the time
+that \s-1CURL\s0 waits for a response from the remote server to get the size of the
+image to be downloaded. If not set, the default timeout of 5 seconds is used.
+.RE
+.RS 4
+.Sp
+Note that when passing options to qemu explicitly, \fBdriver\fR is the value
+of <protocol>.
+.Sp
+Example: boot from a remote Fedora 20 live \s-1ISO\s0 image
+.Sp
+.Vb 1
+\&        qemu\-system\-x86_64 \-\-drive media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora\-Live\-Desktop\-x86_64\-20\-1.iso,readonly
+\&        
+\&        qemu\-system\-x86_64 \-\-drive media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora\-Live\-Desktop\-x86_64\-20\-1.iso,readonly
+.Ve
+.Sp
+Example: boot from a remote Fedora 20 cloud image using a local overlay for
+writes, copy-on-read, and a readahead of 64k
+.Sp
+.Vb 1
+\&        qemu\-img create \-f qcow2 \-o backing_file=\*(Aqjson:{"file.driver":"http",, "file.url":"https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora\-x86_64\-20\-20131211.1\-sda.qcow2",, "file.readahead":"64k"}\*(Aq /tmp/Fedora\-x86_64\-20\-20131211.1\-sda.qcow2
+\&        
+\&        qemu\-system\-x86_64 \-drive file=/tmp/Fedora\-x86_64\-20\-20131211.1\-sda.qcow2,copy\-on\-read=on
+.Ve
+.Sp
+Example: boot from an image stored on a VMware vSphere server with a self-signed
+certificate using a local overlay for writes, a readahead of 64k and a timeout
+of 10 seconds.
+.Sp
+.Vb 1
+\&        qemu\-img create \-f qcow2 \-o backing_file=\*(Aqjson:{"file.driver":"https",, "file.url":"https://user:password@vsphere.example.com/folder/test/test\-flat.vmdk?dcPath=Datacenter&dsName=datastore1",, "file.sslverify":"off",, "file.readahead":"64k",, "file.timeout":10}\*(Aq /tmp/test.qcow2
+\&        
+\&        qemu\-system\-x86_64 \-drive file=/tmp/test.qcow2
+.Ve
+.RE
+.PP
+Bluetooth(R) options:
+.IP "\fB\-bt hci[...]\fR" 4
+.IX Item "-bt hci[...]"
+Defines the function of the corresponding Bluetooth \s-1HCI. \s0 \-bt options
+are matched with the HCIs present in the chosen machine type.  For
+example when emulating a machine with only one \s-1HCI\s0 built into it, only
+the first \f(CW\*(C`\-bt hci[...]\*(C'\fR option is valid and defines the \s-1HCI\s0's
+logic.  The Transport Layer is decided by the machine type.  Currently
+the machines \f(CW\*(C`n800\*(C'\fR and \f(CW\*(C`n810\*(C'\fR have one \s-1HCI\s0 and all other
+machines have none.
+.Sp
+The following three types are recognized:
+.RS 4
+.IP "\fB\-bt hci,null\fR" 4
+.IX Item "-bt hci,null"
+(default) The corresponding Bluetooth \s-1HCI\s0 assumes no internal logic
+and will not respond to any \s-1HCI\s0 commands or emit events.
+.IP "\fB\-bt hci,host[:\fR\fIid\fR\fB]\fR" 4
+.IX Item "-bt hci,host[:id]"
+(\f(CW\*(C`bluez\*(C'\fR only) The corresponding \s-1HCI\s0 passes commands / events
+to / from the physical \s-1HCI\s0 identified by the name \fIid\fR (default:
+\&\f(CW\*(C`hci0\*(C'\fR) on the computer running \s-1QEMU. \s0 Only available on \f(CW\*(C`bluez\*(C'\fR
+capable systems like Linux.
+.IP "\fB\-bt hci[,vlan=\fR\fIn\fR\fB]\fR" 4
+.IX Item "-bt hci[,vlan=n]"
+Add a virtual, standard \s-1HCI\s0 that will participate in the Bluetooth
+scatternet \fIn\fR (default \f(CW0\fR).  Similarly to \fB\-net\fR
+VLANs, devices inside a bluetooth network \fIn\fR can only communicate
+with other devices in the same network (scatternet).
+.RE
+.RS 4
+.RE
+.IP "\fB\-bt vhci[,vlan=\fR\fIn\fR\fB]\fR" 4
+.IX Item "-bt vhci[,vlan=n]"
+(Linux-host only) Create a \s-1HCI\s0 in scatternet \fIn\fR (default 0) attached
+to the host bluetooth stack instead of to the emulated target.  This
+allows the host and target machines to participate in a common scatternet
+and communicate.  Requires the Linux \f(CW\*(C`vhci\*(C'\fR driver installed.  Can
+be used as following:
+.Sp
+.Vb 1
+\&        qemu\-system\-i386 [...OPTIONS...] \-bt hci,vlan=5 \-bt vhci,vlan=5
+.Ve
+.IP "\fB\-bt device:\fR\fIdev\fR\fB[,vlan=\fR\fIn\fR\fB]\fR" 4
+.IX Item "-bt device:dev[,vlan=n]"
+Emulate a bluetooth device \fIdev\fR and place it in network \fIn\fR
+(default \f(CW0\fR).  \s-1QEMU\s0 can only emulate one type of bluetooth devices
+currently:
+.RS 4
+.IP "\fBkeyboard\fR" 4
+.IX Item "keyboard"
+Virtual wireless keyboard implementing the \s-1HIDP\s0 bluetooth profile.
+.RE
+.RS 4
+.RE
+.PP
+\&\s-1TPM\s0 device options:
+.PP
+The general form of a \s-1TPM\s0 device option is:
+.IP "\fB\-tpmdev\fR \fIbackend\fR \fB,id=\fR\fIid\fR \fB[,\fR\fIoptions\fR\fB]\fR" 4
+.IX Item "-tpmdev backend ,id=id [,options]"
+Backend type must be:
+\&\fBpassthrough\fR.
+.Sp
+The specific backend type will determine the applicable options.
+The \f(CW\*(C`\-tpmdev\*(C'\fR option creates the \s-1TPM\s0 backend and requires a
+\&\f(CW\*(C`\-device\*(C'\fR option that specifies the \s-1TPM\s0 frontend interface model.
+.Sp
+Options to each backend are described below.
+.Sp
+Use 'help' to print all available \s-1TPM\s0 backend types.
+.Sp
+.Vb 1
+\&        qemu \-tpmdev help
+.Ve
+.IP "\fB\-tpmdev passthrough, id=\fR\fIid\fR\fB, path=\fR\fIpath\fR\fB, cancel\-path=\fR\fIcancel-path\fR" 4
+.IX Item "-tpmdev passthrough, id=id, path=path, cancel-path=cancel-path"
+(Linux-host only) Enable access to the host's \s-1TPM\s0 using the passthrough
+driver.
+.Sp
+\&\fBpath\fR specifies the path to the host's \s-1TPM\s0 device, i.e., on
+a Linux host this would be \f(CW\*(C`/dev/tpm0\*(C'\fR.
+\&\fBpath\fR is optional and by default \f(CW\*(C`/dev/tpm0\*(C'\fR is used.
+.Sp
+\&\fBcancel-path\fR specifies the path to the host \s-1TPM\s0 device's sysfs
+entry allowing for cancellation of an ongoing \s-1TPM\s0 command.
+\&\fBcancel-path\fR is optional and by default \s-1QEMU\s0 will search for the
+sysfs entry to use.
+.Sp
+Some notes about using the host's \s-1TPM\s0 with the passthrough driver:
+.Sp
+The \s-1TPM\s0 device accessed by the passthrough driver must not be
+used by any other application on the host.
+.Sp
+Since the host's firmware (\s-1BIOS/UEFI\s0) has already initialized the \s-1TPM,\s0
+the \s-1VM\s0's firmware (\s-1BIOS/UEFI\s0) will not be able to initialize the
+\&\s-1TPM\s0 again and may therefore not show a TPM-specific menu that would
+otherwise allow the user to configure the \s-1TPM,\s0 e.g., allow the user to
+enable/disable or activate/deactivate the \s-1TPM.\s0
+Further, if \s-1TPM\s0 ownership is released from within a \s-1VM\s0 then the host's \s-1TPM\s0
+will get disabled and deactivated. To enable and activate the
+\&\s-1TPM\s0 again afterwards, the host has to be rebooted and the user is
+required to enter the firmware's menu to enable and activate the \s-1TPM.\s0
+If the \s-1TPM\s0 is left disabled and/or deactivated most \s-1TPM\s0 commands will fail.
+.Sp
+To create a passthrough \s-1TPM\s0 use the following two options:
+.Sp
+.Vb 1
+\&        \-tpmdev passthrough,id=tpm0 \-device tpm\-tis,tpmdev=tpm0
+.Ve
+.Sp
+Note that the \f(CW\*(C`\-tpmdev\*(C'\fR id is \f(CW\*(C`tpm0\*(C'\fR and is referenced by
+\&\f(CW\*(C`tpmdev=tpm0\*(C'\fR in the device option.
+.PP
+Linux/Multiboot boot specific:
+.PP
+When using these options, you can use a given Linux or Multiboot
+kernel without installing it in the disk image. It can be useful
+for easier testing of various kernels.
+.IP "\fB\-kernel\fR \fIbzImage\fR" 4
+.IX Item "-kernel bzImage"
+Use \fIbzImage\fR as kernel image. The kernel can be either a Linux kernel
+or in multiboot format.
+.IP "\fB\-append\fR \fIcmdline\fR" 4
+.IX Item "-append cmdline"
+Use \fIcmdline\fR as kernel command line
+.IP "\fB\-initrd\fR \fIfile\fR" 4
+.IX Item "-initrd file"
+Use \fIfile\fR as initial ram disk.
+.ie n .IP "\fB\-initrd ""\fR\fIfile1\fR \fBarg=foo,\fR\fIfile2\fR\fB""\fR" 4
+.el .IP "\fB\-initrd ``\fR\fIfile1\fR \fBarg=foo,\fR\fIfile2\fR\fB''\fR" 4
+.IX Item "-initrd ""file1 arg=foo,file2"""
+This syntax is only available with multiboot.
+.Sp
+Use \fIfile1\fR and \fIfile2\fR as modules and pass arg=foo as parameter to the
+first module.
+.IP "\fB\-dtb\fR \fIfile\fR" 4
+.IX Item "-dtb file"
+Use \fIfile\fR as a device tree binary (dtb) image and pass it to the kernel
+on boot.
+.PP
+Debug/Expert options:
+.IP "\fB\-serial\fR \fIdev\fR" 4
+.IX Item "-serial dev"
+Redirect the virtual serial port to host character device
+\&\fIdev\fR. The default device is \f(CW\*(C`vc\*(C'\fR in graphical mode and
+\&\f(CW\*(C`stdio\*(C'\fR in non graphical mode.
+.Sp
+This option can be used several times to simulate up to 4 serial
+ports.
+.Sp
+Use \f(CW\*(C`\-serial none\*(C'\fR to disable all serial ports.
+.Sp
+Available character devices are:
+.RS 4
+.IP "\fBvc[:\fR\fIW\fR\fBx\fR\fIH\fR\fB]\fR" 4
+.IX Item "vc[:WxH]"
+Virtual console. Optionally, a width and height can be given in pixel with
+.Sp
+.Vb 1
+\&        vc:800x600
+.Ve
+.Sp
+It is also possible to specify width or height in characters:
+.Sp
+.Vb 1
+\&        vc:80Cx24C
+.Ve
+.IP "\fBpty\fR" 4
+.IX Item "pty"
+[Linux only] Pseudo \s-1TTY \s0(a new \s-1PTY\s0 is automatically allocated)
+.IP "\fBnone\fR" 4
+.IX Item "none"
+No device is allocated.
+.IP "\fBnull\fR" 4
+.IX Item "null"
+void device
+.IP "\fBchardev:\fR\fIid\fR" 4
+.IX Item "chardev:id"
+Use a named character device defined with the \f(CW\*(C`\-chardev\*(C'\fR option.
+.IP "\fB/dev/XXX\fR" 4
+.IX Item "/dev/XXX"
+[Linux only] Use host tty, e.g. \fI/dev/ttyS0\fR. The host serial port
+parameters are set according to the emulated ones.
+.IP "\fB/dev/parport\fR\fIN\fR" 4
+.IX Item "/dev/parportN"
+[Linux only, parallel port only] Use host parallel port
+\&\fIN\fR. Currently \s-1SPP\s0 and \s-1EPP\s0 parallel port features can be used.
+.IP "\fBfile:\fR\fIfilename\fR" 4
+.IX Item "file:filename"
+Write output to \fIfilename\fR. No character can be read.
+.IP "\fBstdio\fR" 4
+.IX Item "stdio"
+[Unix only] standard input/output
+.IP "\fBpipe:\fR\fIfilename\fR" 4
+.IX Item "pipe:filename"
+name pipe \fIfilename\fR
+.IP "\fB\s-1COM\s0\fR\fIn\fR" 4
+.IX Item "COMn"
+[Windows only] Use host serial port \fIn\fR
+.IP "\fBudp:[\fR\fIremote_host\fR\fB]:\fR\fIremote_port\fR\fB[@[\fR\fIsrc_ip\fR\fB]:\fR\fIsrc_port\fR\fB]\fR" 4
+.IX Item "udp:[remote_host]:remote_port[@[src_ip]:src_port]"
+This implements \s-1UDP\s0 Net Console.
+When \fIremote_host\fR or \fIsrc_ip\fR are not specified
+they default to \f(CW0.0.0.0\fR.
+When not using a specified \fIsrc_port\fR a random port is automatically chosen.
+.Sp
+If you just want a simple readonly console you can use \f(CW\*(C`netcat\*(C'\fR or
+\&\f(CW\*(C`nc\*(C'\fR, by starting \s-1QEMU\s0 with: \f(CW\*(C`\-serial udp::4555\*(C'\fR and nc as:
+\&\f(CW\*(C`nc \-u \-l \-p 4555\*(C'\fR. Any time \s-1QEMU\s0 writes something to that port it
+will appear in the netconsole session.
+.Sp
+If you plan to send characters back via netconsole or you want to stop
+and start \s-1QEMU\s0 a lot of times, you should have \s-1QEMU\s0 use the same
+source port each time by using something like \f(CW\*(C`\-serial
+udp::4555@4556\*(C'\fR to \s-1QEMU.\s0 Another approach is to use a patched
+version of netcat which can listen to a \s-1TCP\s0 port and send and receive
+characters via udp.  If you have a patched version of netcat which
+activates telnet remote echo and single char transfer, then you can
+use the following options to step up a netcat redirector to allow
+telnet on port 5555 to access the \s-1QEMU\s0 port.
+.RS 4
+.ie n .IP """QEMU Options:""" 4
+.el .IP "\f(CWQEMU Options:\fR" 4
+.IX Item "QEMU Options:"
+\&\-serial udp::4555@4556
+.ie n .IP """netcat options:""" 4
+.el .IP "\f(CWnetcat options:\fR" 4
+.IX Item "netcat options:"
+\&\-u \-P 4555 \-L 0.0.0.0:4556 \-t \-p 5555 \-I \-T
+.ie n .IP """telnet options:""" 4
+.el .IP "\f(CWtelnet options:\fR" 4
+.IX Item "telnet options:"
+localhost 5555
+.RE
+.RS 4
+.RE
+.IP "\fBtcp:[\fR\fIhost\fR\fB]:\fR\fIport\fR\fB[,\fR\fIserver\fR\fB][,nowait][,nodelay][,reconnect=\fR\fIseconds\fR\fB]\fR" 4
+.IX Item "tcp:[host]:port[,server][,nowait][,nodelay][,reconnect=seconds]"
+The \s-1TCP\s0 Net Console has two modes of operation.  It can send the serial
+I/O to a location or wait for a connection from a location.  By default
+the \s-1TCP\s0 Net Console is sent to \fIhost\fR at the \fIport\fR.  If you use
+the \fIserver\fR option \s-1QEMU\s0 will wait for a client socket application
+to connect to the port before continuing, unless the \f(CW\*(C`nowait\*(C'\fR
+option was specified.  The \f(CW\*(C`nodelay\*(C'\fR option disables the Nagle buffering
+algorithm.  The \f(CW\*(C`reconnect\*(C'\fR option only applies if \fInoserver\fR is
+set, if the connection goes down it will attempt to reconnect at the
+given interval.  If \fIhost\fR is omitted, 0.0.0.0 is assumed. Only
+one \s-1TCP\s0 connection at a time is accepted. You can use \f(CW\*(C`telnet\*(C'\fR to
+connect to the corresponding character device.
+.RS 4
+.ie n .IP """Example to send tcp console to 192.168.0.2 port 4444""" 4
+.el .IP "\f(CWExample to send tcp console to 192.168.0.2 port 4444\fR" 4
+.IX Item "Example to send tcp console to 192.168.0.2 port 4444"
+\&\-serial tcp:192.168.0.2:4444
+.ie n .IP """Example to listen and wait on port 4444 for connection""" 4
+.el .IP "\f(CWExample to listen and wait on port 4444 for connection\fR" 4
+.IX Item "Example to listen and wait on port 4444 for connection"
+\&\-serial tcp::4444,server
+.ie n .IP """Example to not wait and listen on ip 192.168.0.100 port 4444""" 4
+.el .IP "\f(CWExample to not wait and listen on ip 192.168.0.100 port 4444\fR" 4
+.IX Item "Example to not wait and listen on ip 192.168.0.100 port 4444"
+\&\-serial tcp:192.168.0.100:4444,server,nowait
+.RE
+.RS 4
+.RE
+.IP "\fBtelnet:\fR\fIhost\fR\fB:\fR\fIport\fR\fB[,server][,nowait][,nodelay]\fR" 4
+.IX Item "telnet:host:port[,server][,nowait][,nodelay]"
+The telnet protocol is used instead of raw tcp sockets.  The options
+work the same as if you had specified \f(CW\*(C`\-serial tcp\*(C'\fR.  The
+difference is that the port acts like a telnet server or client using
+telnet option negotiation.  This will also allow you to send the
+\&\s-1MAGIC_SYSRQ\s0 sequence if you use a telnet that supports sending the break
+sequence.  Typically in unix telnet you do it with Control\-] and then
+type \*(L"send break\*(R" followed by pressing the enter key.
+.IP "\fBunix:\fR\fIpath\fR\fB[,server][,nowait][,reconnect=\fR\fIseconds\fR\fB]\fR" 4
+.IX Item "unix:path[,server][,nowait][,reconnect=seconds]"
+A unix domain socket is used instead of a tcp socket.  The option works the
+same as if you had specified \f(CW\*(C`\-serial tcp\*(C'\fR except the unix domain socket
+\&\fIpath\fR is used for connections.
+.IP "\fBmon:\fR\fIdev_string\fR" 4
+.IX Item "mon:dev_string"
+This is a special option to allow the monitor to be multiplexed onto
+another serial port.  The monitor is accessed with key sequence of
+\&\fBControl-a\fR and then pressing \fBc\fR.
+\&\fIdev_string\fR should be any one of the serial devices specified
+above.  An example to multiplex the monitor onto a telnet server
+listening on port 4444 would be:
+.RS 4
+.ie n .IP """\-serial mon:telnet::4444,server,nowait""" 4
+.el .IP "\f(CW\-serial mon:telnet::4444,server,nowait\fR" 4
+.IX Item "-serial mon:telnet::4444,server,nowait"
+.RE
+.RS 4
+.Sp
+When the monitor is multiplexed to stdio in this way, Ctrl+C will not terminate
+\&\s-1QEMU\s0 any more but will be passed to the guest instead.
+.RE
+.IP "\fBbraille\fR" 4
+.IX Item "braille"
+Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+.IP "\fBmsmouse\fR" 4
+.IX Item "msmouse"
+Three button serial mouse. Configure the guest to use Microsoft protocol.
+.RE
+.RS 4
+.RE
+.IP "\fB\-parallel\fR \fIdev\fR" 4
+.IX Item "-parallel dev"
+Redirect the virtual parallel port to host device \fIdev\fR (same
+devices as the serial port). On Linux hosts, \fI/dev/parportN\fR can
+be used to use hardware devices connected on the corresponding host
+parallel port.
+.Sp
+This option can be used several times to simulate up to 3 parallel
+ports.
+.Sp
+Use \f(CW\*(C`\-parallel none\*(C'\fR to disable all parallel ports.
+.IP "\fB\-monitor\fR \fIdev\fR" 4
+.IX Item "-monitor dev"
+Redirect the monitor to host device \fIdev\fR (same devices as the
+serial port).
+The default device is \f(CW\*(C`vc\*(C'\fR in graphical mode and \f(CW\*(C`stdio\*(C'\fR in
+non graphical mode.
+Use \f(CW\*(C`\-monitor none\*(C'\fR to disable the default monitor.
+.IP "\fB\-qmp\fR \fIdev\fR" 4
+.IX Item "-qmp dev"
+Like \-monitor but opens in 'control' mode.
+.IP "\fB\-qmp\-pretty\fR \fIdev\fR" 4
+.IX Item "-qmp-pretty dev"
+Like \-qmp but uses pretty \s-1JSON\s0 formatting.
+.IP "\fB\-mon [chardev=]name[,mode=readline|control][,default]\fR" 4
+.IX Item "-mon [chardev=]name[,mode=readline|control][,default]"
+Setup monitor on chardev \fIname\fR.
+.IP "\fB\-debugcon\fR \fIdev\fR" 4
+.IX Item "-debugcon dev"
+Redirect the debug console to host device \fIdev\fR (same devices as the
+serial port).  The debug console is an I/O port which is typically port
+0xe9; writing to that I/O port sends output to this device.
+The default device is \f(CW\*(C`vc\*(C'\fR in graphical mode and \f(CW\*(C`stdio\*(C'\fR in
+non graphical mode.
+.IP "\fB\-pidfile\fR \fIfile\fR" 4
+.IX Item "-pidfile file"
+Store the \s-1QEMU\s0 process \s-1PID\s0 in \fIfile\fR. It is useful if you launch \s-1QEMU\s0
+from a script.
+.IP "\fB\-singlestep\fR" 4
+.IX Item "-singlestep"
+Run the emulation in single step mode.
+.IP "\fB\-S\fR" 4
+.IX Item "-S"
+Do not start \s-1CPU\s0 at startup (you must type 'c' in the monitor).
+.IP "\fB\-realtime mlock=on|off\fR" 4
+.IX Item "-realtime mlock=on|off"
+Run qemu with realtime features.
+mlocking qemu and guest memory can be enabled via \fBmlock=on\fR
+(enabled by default).
+.IP "\fB\-gdb\fR \fIdev\fR" 4
+.IX Item "-gdb dev"
+Wait for gdb connection on device \fIdev\fR. Typical
+connections will likely be TCP-based, but also \s-1UDP,\s0 pseudo \s-1TTY,\s0 or even
+stdio are reasonable use case. The latter is allowing to start \s-1QEMU\s0 from
+within gdb and establish the connection via a pipe:
+.Sp
+.Vb 1
+\&        (gdb) target remote | exec qemu\-system\-i386 \-gdb stdio ...
+.Ve
+.IP "\fB\-s\fR" 4
+.IX Item "-s"
+Shorthand for \-gdb tcp::1234, i.e. open a gdbserver on \s-1TCP\s0 port 1234.
+.IP "\fB\-d\fR \fIitem1\fR\fB[,...]\fR" 4
+.IX Item "-d item1[,...]"
+Enable logging of specified items. Use '\-d help' for a list of log items.
+.IP "\fB\-D\fR \fIlogfile\fR" 4
+.IX Item "-D logfile"
+Output log in \fIlogfile\fR instead of to stderr
+.IP "\fB\-L\fR  \fIpath\fR" 4
+.IX Item "-L path"
+Set the directory for the \s-1BIOS, VGA BIOS\s0 and keymaps.
+.IP "\fB\-bios\fR \fIfile\fR" 4
+.IX Item "-bios file"
+Set the filename for the \s-1BIOS.\s0
+.IP "\fB\-enable\-kvm\fR" 4
+.IX Item "-enable-kvm"
+Enable \s-1KVM\s0 full virtualization support. This option is only available
+if \s-1KVM\s0 support is enabled when compiling.
+.IP "\fB\-xen\-domid\fR \fIid\fR" 4
+.IX Item "-xen-domid id"
+Specify xen guest domain \fIid\fR (\s-1XEN\s0 only).
+.IP "\fB\-xen\-create\fR" 4
+.IX Item "-xen-create"
+Create domain using xen hypercalls, bypassing xend.
+Warning: should not be used when xend is in use (\s-1XEN\s0 only).
+.IP "\fB\-xen\-attach\fR" 4
+.IX Item "-xen-attach"
+Attach to existing xen domain.
+xend will use this when starting \s-1QEMU \s0(\s-1XEN\s0 only).
+.IP "\fB\-no\-reboot\fR" 4
+.IX Item "-no-reboot"
+Exit instead of rebooting.
+.IP "\fB\-no\-shutdown\fR" 4
+.IX Item "-no-shutdown"
+Don't exit \s-1QEMU\s0 on guest shutdown, but instead only stop the emulation.
+This allows for instance switching to monitor to commit changes to the
+disk image.
+.IP "\fB\-loadvm\fR \fIfile\fR" 4
+.IX Item "-loadvm file"
+Start right away with a saved state (\f(CW\*(C`loadvm\*(C'\fR in monitor)
+.IP "\fB\-daemonize\fR" 4
+.IX Item "-daemonize"
+Daemonize the \s-1QEMU\s0 process after initialization.  \s-1QEMU\s0 will not detach from
+standard \s-1IO\s0 until it is ready to receive connections on any of its devices.
+This option is a useful way for external programs to launch \s-1QEMU\s0 without having
+to cope with initialization race conditions.
+.IP "\fB\-option\-rom\fR \fIfile\fR" 4
+.IX Item "-option-rom file"
+Load the contents of \fIfile\fR as an option \s-1ROM.\s0
+This option is useful to load things like EtherBoot.
+.IP "\fB\-rtc [base=utc|localtime|\fR\fIdate\fR\fB][,clock=host|vm][,driftfix=none|slew]\fR" 4
+.IX Item "-rtc [base=utc|localtime|date][,clock=host|vm][,driftfix=none|slew]"
+Specify \fBbase\fR as \f(CW\*(C`utc\*(C'\fR or \f(CW\*(C`localtime\*(C'\fR to let the \s-1RTC\s0 start at the current
+\&\s-1UTC\s0 or local time, respectively. \f(CW\*(C`localtime\*(C'\fR is required for correct date in
+MS-DOS or Windows. To start at a specific point in time, provide \fIdate\fR in the
+format \f(CW\*(C`2006\-06\-17T16:01:21\*(C'\fR or \f(CW\*(C`2006\-06\-17\*(C'\fR. The default base is \s-1UTC.\s0
+.Sp
+By default the \s-1RTC\s0 is driven by the host system time. This allows using of the
+\&\s-1RTC\s0 as accurate reference clock inside the guest, specifically if the host
+time is smoothly following an accurate external reference clock, e.g. via \s-1NTP.\s0
+If you want to isolate the guest time from the host, you can set \fBclock\fR
+to \f(CW\*(C`rt\*(C'\fR instead.  To even prevent it from progressing during suspension,
+you can set it to \f(CW\*(C`vm\*(C'\fR.
+.Sp
+Enable \fBdriftfix\fR (i386 targets only) if you experience time drift problems,
+specifically with Windows' \s-1ACPI HAL.\s0 This option will try to figure out how
+many timer interrupts were not processed by the Windows guest and will
+re-inject them.
+.IP "\fB\-icount [shift=\fR\fIN\fR\fB|auto]\fR" 4
+.IX Item "-icount [shift=N|auto]"
+Enable virtual instruction counter.  The virtual cpu will execute one
+instruction every 2^\fIN\fR ns of virtual time.  If \f(CW\*(C`auto\*(C'\fR is specified
+then the virtual cpu speed will be automatically adjusted to keep virtual
+time within a few seconds of real time.
+.Sp
+Note that while this option can give deterministic behavior, it does not
+provide cycle accurate emulation.  Modern CPUs contain superscalar out of
+order cores with complex cache hierarchies.  The number of instructions
+executed often has little or no correlation with actual performance.
+.Sp
+\&\fBalign=on\fR will activate the delay algorithm which will try to
+to synchronise the host clock and the virtual clock. The goal is to
+have a guest running at the real frequency imposed by the shift option.
+Whenever the guest clock is behind the host clock and if
+\&\fBalign=on\fR is specified then we print a messsage to the user
+to inform about the delay.
+Currently this option does not work when \fBshift\fR is \f(CW\*(C`auto\*(C'\fR.
+Note: The sync algorithm will work for those shift values for which
+the guest clock runs ahead of the host clock. Typically this happens
+when the shift value is high (how high depends on the host machine).
+.IP "\fB\-watchdog\fR \fImodel\fR" 4
+.IX Item "-watchdog model"
+Create a virtual hardware watchdog device.  Once enabled (by a guest
+action), the watchdog must be periodically polled by an agent inside
+the guest or else the guest will be restarted.
+.Sp
+The \fImodel\fR is the model of hardware watchdog to emulate.  Choices
+for model are: \f(CW\*(C`ib700\*(C'\fR (iBASE 700) which is a very simple \s-1ISA\s0
+watchdog with a single timer, or \f(CW\*(C`i6300esb\*(C'\fR (Intel 6300ESB I/O
+controller hub) which is a much more featureful PCI-based dual-timer
+watchdog.  Choose a model for which your guest has drivers.
+.Sp
+Use \f(CW\*(C`\-watchdog help\*(C'\fR to list available hardware models.  Only one
+watchdog can be enabled for a guest.
+.IP "\fB\-watchdog\-action\fR \fIaction\fR" 4
+.IX Item "-watchdog-action action"
+The \fIaction\fR controls what \s-1QEMU\s0 will do when the watchdog timer
+expires.
+The default is
+\&\f(CW\*(C`reset\*(C'\fR (forcefully reset the guest).
+Other possible actions are:
+\&\f(CW\*(C`shutdown\*(C'\fR (attempt to gracefully shutdown the guest),
+\&\f(CW\*(C`poweroff\*(C'\fR (forcefully poweroff the guest),
+\&\f(CW\*(C`pause\*(C'\fR (pause the guest),
+\&\f(CW\*(C`debug\*(C'\fR (print a debug message and continue), or
+\&\f(CW\*(C`none\*(C'\fR (do nothing).
+.Sp
+Note that the \f(CW\*(C`shutdown\*(C'\fR action requires that the guest responds
+to \s-1ACPI\s0 signals, which it may not be able to do in the sort of
+situations where the watchdog would have expired, and thus
+\&\f(CW\*(C`\-watchdog\-action shutdown\*(C'\fR is not recommended for production use.
+.Sp
+Examples:
+.RS 4
+.ie n .IP """\-watchdog i6300esb \-watchdog\-action pause""" 4
+.el .IP "\f(CW\-watchdog i6300esb \-watchdog\-action pause\fR" 4
+.IX Item "-watchdog i6300esb -watchdog-action pause"
+.PD 0
+.ie n .IP """\-watchdog ib700""" 4
+.el .IP "\f(CW\-watchdog ib700\fR" 4
+.IX Item "-watchdog ib700"
+.RE
+.RS 4
+.RE
+.IP "\fB\-echr\fR \fInumeric_ascii_value\fR" 4
+.IX Item "-echr numeric_ascii_value"
+.PD
+Change the escape character used for switching to the monitor when using
+monitor and serial sharing.  The default is \f(CW0x01\fR when using the
+\&\f(CW\*(C`\-nographic\*(C'\fR option.  \f(CW0x01\fR is equal to pressing
+\&\f(CW\*(C`Control\-a\*(C'\fR.  You can select a different character from the ascii
+control keys where 1 through 26 map to Control-a through Control-z.  For
+instance you could use the either of the following to change the escape
+character to Control-t.
+.RS 4
+.ie n .IP """\-echr 0x14""" 4
+.el .IP "\f(CW\-echr 0x14\fR" 4
+.IX Item "-echr 0x14"
+.PD 0
+.ie n .IP """\-echr 20""" 4
+.el .IP "\f(CW\-echr 20\fR" 4
+.IX Item "-echr 20"
+.RE
+.RS 4
+.RE
+.IP "\fB\-virtioconsole\fR \fIc\fR" 4
+.IX Item "-virtioconsole c"
+.PD
+Set virtio console.
+.Sp
+This option is maintained for backward compatibility.
+.Sp
+Please use \f(CW\*(C`\-device virtconsole\*(C'\fR for the new way of invocation.
+.IP "\fB\-show\-cursor\fR" 4
+.IX Item "-show-cursor"
+Show cursor.
+.IP "\fB\-tb\-size\fR \fIn\fR" 4
+.IX Item "-tb-size n"
+Set \s-1TB\s0 size.
+.IP "\fB\-incoming tcp:[\fR\fIhost\fR\fB]:\fR\fIport\fR\fB[,to=\fR\fImaxport\fR\fB][,ipv4][,ipv6]\fR" 4
+.IX Item "-incoming tcp:[host]:port[,to=maxport][,ipv4][,ipv6]"
+.PD 0
+.IP "\fB\-incoming rdma:\fR\fIhost\fR\fB:\fR\fIport\fR\fB[,ipv4][,ipv6]\fR" 4
+.IX Item "-incoming rdma:host:port[,ipv4][,ipv6]"
+.PD
+Prepare for incoming migration, listen on a given tcp port.
+.IP "\fB\-incoming unix:\fR\fIsocketpath\fR" 4
+.IX Item "-incoming unix:socketpath"
+Prepare for incoming migration, listen on a given unix socket.
+.IP "\fB\-incoming fd:\fR\fIfd\fR" 4
+.IX Item "-incoming fd:fd"
+Accept incoming migration from a given filedescriptor.
+.IP "\fB\-incoming exec:\fR\fIcmdline\fR" 4
+.IX Item "-incoming exec:cmdline"
+Accept incoming migration as an output from specified external command.
+.IP "\fB\-nodefaults\fR" 4
+.IX Item "-nodefaults"
+Don't create default devices. Normally, \s-1QEMU\s0 sets the default devices like serial
+port, parallel port, virtual console, monitor device, \s-1VGA\s0 adapter, floppy and
+CD-ROM drive and others. The \f(CW\*(C`\-nodefaults\*(C'\fR option will disable all those
+default devices.
+.IP "\fB\-chroot\fR \fIdir\fR" 4
+.IX Item "-chroot dir"
+Immediately before starting guest execution, chroot to the specified
+directory.  Especially useful in combination with \-runas.
+.IP "\fB\-runas\fR \fIuser\fR" 4
+.IX Item "-runas user"
+Immediately before starting guest execution, drop root privileges, switching
+to the specified user.
+.IP "\fB\-prom\-env\fR \fIvariable\fR\fB=\fR\fIvalue\fR" 4
+.IX Item "-prom-env variable=value"
+Set OpenBIOS nvram \fIvariable\fR to given \fIvalue\fR (\s-1PPC, SPARC\s0 only).
+.IP "\fB\-semihosting\fR" 4
+.IX Item "-semihosting"
+Enable semihosting mode (\s-1ARM, M68K,\s0 Xtensa only).
+.IP "\fB\-semihosting\-config [enable=on|off,]target=native|gdb|auto\fR" 4
+.IX Item "-semihosting-config [enable=on|off,]target=native|gdb|auto"
+Enable semihosting and define where the semihosting calls will be addressed,
+to \s-1QEMU \s0(\f(CW\*(C`native\*(C'\fR) or to \s-1GDB \s0(\f(CW\*(C`gdb\*(C'\fR). The default is \f(CW\*(C`auto\*(C'\fR, which means
+\&\f(CW\*(C`gdb\*(C'\fR during debug sessions and \f(CW\*(C`native\*(C'\fR otherwise (\s-1ARM, M68K,\s0 Xtensa only).
+.IP "\fB\-old\-param\fR" 4
+.IX Item "-old-param"
+Old param mode (\s-1ARM\s0 only).
+.IP "\fB\-sandbox\fR \fIarg\fR" 4
+.IX Item "-sandbox arg"
+Enable Seccomp mode 2 system call filter. 'on' will enable syscall filtering and 'off' will
+disable it.  The default is 'off'.
+.IP "\fB\-readconfig\fR \fIfile\fR" 4
+.IX Item "-readconfig file"
+Read device configuration from \fIfile\fR. This approach is useful when you want to spawn
+\&\s-1QEMU\s0 process with many command line options but you don't want to exceed the command line
+character limit.
+.IP "\fB\-writeconfig\fR \fIfile\fR" 4
+.IX Item "-writeconfig file"
+Write device configuration to \fIfile\fR. The \fIfile\fR can be either filename to save
+command line and device configuration into file or dash \f(CW\*(C`\-\*(C'\fR) character to print the
+output to stdout. This can be later used as input file for \f(CW\*(C`\-readconfig\*(C'\fR option.
+.IP "\fB\-nodefconfig\fR" 4
+.IX Item "-nodefconfig"
+Normally \s-1QEMU\s0 loads configuration files from \fIsysconfdir\fR and \fIdatadir\fR at startup.
+The \f(CW\*(C`\-nodefconfig\*(C'\fR option will prevent \s-1QEMU\s0 from loading any of those config files.
+.IP "\fB\-no\-user\-config\fR" 4
+.IX Item "-no-user-config"
+The \f(CW\*(C`\-no\-user\-config\*(C'\fR option makes \s-1QEMU\s0 not load any of the user-provided
+config files on \fIsysconfdir\fR, but won't make it skip the QEMU-provided config
+files from \fIdatadir\fR.
+.IP "\fB\-trace [events=\fR\fIfile\fR\fB][,file=\fR\fIfile\fR\fB]\fR" 4
+.IX Item "-trace [events=file][,file=file]"
+Specify tracing options.
+.RS 4
+.IP "\fBevents=\fR\fIfile\fR" 4
+.IX Item "events=file"
+Immediately enable events listed in \fIfile\fR.
+The file must contain one event name (as listed in the \fItrace-events\fR file)
+per line.
+This option is only available if \s-1QEMU\s0 has been compiled with
+either \fIsimple\fR or \fIstderr\fR tracing backend.
+.IP "\fBfile=\fR\fIfile\fR" 4
+.IX Item "file=file"
+Log output traces to \fIfile\fR.
+.Sp
+This option is only available if \s-1QEMU\s0 has been compiled with
+the \fIsimple\fR tracing backend.
+.RE
+.RS 4
+.RE
+.IP "\fB\-enable\-fips\fR" 4
+.IX Item "-enable-fips"
+Enable \s-1FIPS 140\-2\s0 compliance mode.
+.IP "\fB\-object\fR \fItypename\fR\fB[,\fR\fIprop1\fR\fB=\fR\fIvalue1\fR\fB,...]\fR" 4
+.IX Item "-object typename[,prop1=value1,...]"
+Create an new object of type \fItypename\fR setting properties
+in the order they are specified.  Note that the 'id'
+property must be set.  These objects are placed in the
+\&'/objects' path.
+.IP "\fB\-msg timestamp[=on|off]\fR" 4
+.IX Item "-msg timestamp[=on|off]"
+prepend a timestamp to each log message.(default:on)
+.IP "\fB\-dump\-vmstate\fR \fIfile\fR" 4
+.IX Item "-dump-vmstate file"
+Dump json-encoded vmstate information for current machine type to file
+in \fIfile\fR
+.PP
+During the graphical emulation, you can use special key combinations to change
+modes. The default key mappings are shown below, but if you use \f(CW\*(C`\-alt\-grab\*(C'\fR
+then the modifier is Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use
+\&\f(CW\*(C`\-ctrl\-grab\*(C'\fR then the modifier is the right Ctrl key (instead of Ctrl-Alt):
+.IP "\fBCtrl-Alt-f\fR" 4
+.IX Item "Ctrl-Alt-f"
+Toggle full screen
+.IP "\fBCtrl\-Alt\-+\fR" 4
+.IX Item "Ctrl-Alt-+"
+Enlarge the screen
+.IP "\fBCtrl\-Alt\*(--\fR" 4
+.IX Item "Ctrl-Alt"
+Shrink the screen
+.IP "\fBCtrl-Alt-u\fR" 4
+.IX Item "Ctrl-Alt-u"
+Restore the screen's un-scaled dimensions
+.IP "\fBCtrl-Alt-n\fR" 4
+.IX Item "Ctrl-Alt-n"
+Switch to virtual console 'n'. Standard console mappings are:
+.RS 4
+.IP "\fI1\fR" 4
+.IX Item "1"
+Target system display
+.IP "\fI2\fR" 4
+.IX Item "2"
+Monitor
+.IP "\fI3\fR" 4
+.IX Item "3"
+Serial port
+.RE
+.RS 4
+.RE
+.IP "\fBCtrl-Alt\fR" 4
+.IX Item "Ctrl-Alt"
+Toggle mouse and keyboard grab.
+.PP
+In the virtual consoles, you can use \fBCtrl-Up\fR, \fBCtrl-Down\fR,
+\&\fBCtrl-PageUp\fR and \fBCtrl-PageDown\fR to move in the back log.
+.PP
+During emulation, if you are using the \fB\-nographic\fR option, use
+\&\fBCtrl-a h\fR to get terminal commands:
+.IP "\fBCtrl-a h\fR" 4
+.IX Item "Ctrl-a h"
+.PD 0
+.IP "\fBCtrl-a ?\fR" 4
+.IX Item "Ctrl-a ?"
+.PD
+Print this help
+.IP "\fBCtrl-a x\fR" 4
+.IX Item "Ctrl-a x"
+Exit emulator
+.IP "\fBCtrl-a s\fR" 4
+.IX Item "Ctrl-a s"
+Save disk data back to file (if \-snapshot)
+.IP "\fBCtrl-a t\fR" 4
+.IX Item "Ctrl-a t"
+Toggle console timestamps
+.IP "\fBCtrl-a b\fR" 4
+.IX Item "Ctrl-a b"
+Send break (magic sysrq in Linux)
+.IP "\fBCtrl-a c\fR" 4
+.IX Item "Ctrl-a c"
+Switch between console and monitor
+.IP "\fBCtrl-a Ctrl-a\fR" 4
+.IX Item "Ctrl-a Ctrl-a"
+Send Ctrl-a
+.PP
+The following options are specific to the PowerPC emulation:
+.IP "\fB\-g\fR \fIW\fR\fBx\fR\fIH\fR\fB[x\fR\fI\s-1DEPTH\s0\fR\fB]\fR" 4
+.IX Item "-g WxH[xDEPTH]"
+Set the initial \s-1VGA\s0 graphic mode. The default is 800x600x32.
+.IP "\fB\-prom\-env\fR \fIstring\fR" 4
+.IX Item "-prom-env string"
+Set OpenBIOS variables in \s-1NVRAM,\s0 for example:
+.Sp
+.Vb 3
+\&        qemu\-system\-ppc \-prom\-env \*(Aqauto\-boot?=false\*(Aq \e
+\&         \-prom\-env \*(Aqboot\-device=hd:2,\eyaboot\*(Aq \e
+\&         \-prom\-env \*(Aqboot\-args=conf=hd:2,\eyaboot.conf\*(Aq
+.Ve
+.Sp
+These variables are not used by Open Hack'Ware.
+.PP
+The following options are specific to the Sparc32 emulation:
+.IP "\fB\-g\fR \fIW\fR\fBx\fR\fIH\fR\fBx[x\fR\fI\s-1DEPTH\s0\fR\fB]\fR" 4
+.IX Item "-g WxHx[xDEPTH]"
+Set the initial graphics mode. For \s-1TCX,\s0 the default is 1024x768x8 with the
+option of 1024x768x24. For cgthree, the default is 1024x768x8 with the option
+of 1152x900x8 for people who wish to use \s-1OBP.\s0
+.IP "\fB\-prom\-env\fR \fIstring\fR" 4
+.IX Item "-prom-env string"
+Set OpenBIOS variables in \s-1NVRAM,\s0 for example:
+.Sp
+.Vb 2
+\&        qemu\-system\-sparc \-prom\-env \*(Aqauto\-boot?=false\*(Aq \e
+\&         \-prom\-env \*(Aqboot\-device=sd(0,2,0):d\*(Aq \-prom\-env \*(Aqboot\-args=linux single\*(Aq
+.Ve
+.IP "\fB\-M [SS\-4|SS\-5|SS\-10|SS\-20|SS\-600MP|LX|Voyager|SPARCClassic] [|SPARCbook]\fR" 4
+.IX Item "-M [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic] [|SPARCbook]"
+Set the emulated machine type. Default is \s-1SS\-5.\s0
+.PP
+The following options are specific to the Sparc64 emulation:
+.IP "\fB\-prom\-env\fR \fIstring\fR" 4
+.IX Item "-prom-env string"
+Set OpenBIOS variables in \s-1NVRAM,\s0 for example:
+.Sp
+.Vb 1
+\&        qemu\-system\-sparc64 \-prom\-env \*(Aqauto\-boot?=false\*(Aq
+.Ve
+.IP "\fB\-M [sun4u|sun4v|Niagara]\fR" 4
+.IX Item "-M [sun4u|sun4v|Niagara]"
+Set the emulated machine type. The default is sun4u.
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+The \s-1HTML\s0 documentation of \s-1QEMU\s0 for more precise information and Linux
+user mode emulator invocation.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Fabrice Bellard
diff --git a/qemu/share/man/man8/qemu-nbd.8 b/qemu/share/man/man8/qemu-nbd.8
new file mode 100644
index 0000000..cdd0a23
--- /dev/null
+++ b/qemu/share/man/man8/qemu-nbd.8
@@ -0,0 +1,213 @@
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+.    ds C`
+.    ds C'
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
+..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
+.\}
+.rr rF
+.\" ========================================================================
+.\"
+.IX Title "QEMU-NBD 8"
+.TH QEMU-NBD 8 "2018-02-24" " " " "
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+qemu\-nbd \- QEMU Disk Network Block Device Server
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+usage: qemu-nbd [\s-1OPTION\s0]...  \fIfilename\fR
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+Export \s-1QEMU\s0 disk image using \s-1NBD\s0 protocol.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.IP "\fIfilename\fR" 4
+.IX Item "filename"
+.Vb 1
+\& is a disk image filename
+.Ve
+.IP "\fB\-p, \-\-port=\fR\fIport\fR" 4
+.IX Item "-p, --port=port"
+.Vb 1
+\&  port to listen on (default B<10809>)
+.Ve
+.IP "\fB\-o, \-\-offset=\fR\fIoffset\fR" 4
+.IX Item "-o, --offset=offset"
+.Vb 1
+\&  offset into the image
+.Ve
+.IP "\fB\-b, \-\-bind=\fR\fIiface\fR" 4
+.IX Item "-b, --bind=iface"
+.Vb 1
+\&  interface to bind to (default B<0.0.0.0>)
+.Ve
+.IP "\fB\-k, \-\-socket=\fR\fIpath\fR" 4
+.IX Item "-k, --socket=path"
+.Vb 1
+\&  Use a unix socket with path I<path>
+.Ve
+.IP "\fB\-f, \-\-format=\fR\fIformat\fR" 4
+.IX Item "-f, --format=format"
+.Vb 1
+\&  Set image format as I<format>
+.Ve
+.IP "\fB\-r, \-\-read\-only\fR" 4
+.IX Item "-r, --read-only"
+.Vb 1
+\&  export read\-only
+.Ve
+.IP "\fB\-P, \-\-partition=\fR\fInum\fR" 4
+.IX Item "-P, --partition=num"
+.Vb 1
+\&  only expose partition I<num>
+.Ve
+.IP "\fB\-s, \-\-snapshot\fR" 4
+.IX Item "-s, --snapshot"
+.Vb 3
+\&  use I<filename> as an external snapshot, create a temporary
+\&  file with backing_file=I<filename>, redirect the write to
+\&  the temporary one
+.Ve
+.IP "\fB\-l, \-\-load\-snapshot=\fR\fIsnapshot_param\fR" 4
+.IX Item "-l, --load-snapshot=snapshot_param"
+.Vb 3
+\&  load an internal snapshot inside I<filename> and export it
+\&  as an read\-only device, I<snapshot_param> format is
+\&  \*(Aqsnapshot.id=[ID],snapshot.name=[NAME]\*(Aq or \*(Aq[ID_OR_NAME]\*(Aq
+.Ve
+.IP "\fB\-n, \-\-nocache\fR" 4
+.IX Item "-n, --nocache"
+.PD 0
+.IP "\fB\-\-cache=\fR\fIcache\fR" 4
+.IX Item "--cache=cache"
+.PD
+.Vb 2
+\&  set cache mode to be used with the file.  See the documentation of
+\&  the emulator\*(Aqs C<\-drive cache=...> option for allowed values.
+.Ve
+.IP "\fB\-\-aio=\fR\fIaio\fR" 4
+.IX Item "--aio=aio"
+.Vb 2
+\&  choose asynchronous I/O mode between B<threads> (the default)
+\&  and B<native> (Linux only).
+.Ve
+.IP "\fB\-\-discard=\fR\fIdiscard\fR" 4
+.IX Item "--discard=discard"
+.Vb 3
+\&  toggles whether I<discard> (also known as I<trim> or I<unmap>)
+\&  requests are ignored or passed to the filesystem.  The default is no
+\&  (B<\-\-discard=ignore>).
+.Ve
+.IP "\fB\-c, \-\-connect=\fR\fIdev\fR" 4
+.IX Item "-c, --connect=dev"
+.Vb 1
+\&  connect I<filename> to NBD device I<dev>
+.Ve
+.IP "\fB\-d, \-\-disconnect\fR" 4
+.IX Item "-d, --disconnect"
+.Vb 1
+\&  disconnect the specified device
+.Ve
+.IP "\fB\-e, \-\-shared=\fR\fInum\fR" 4
+.IX Item "-e, --shared=num"
+.Vb 1
+\&  device can be shared by I<num> clients (default B<1>)
+.Ve
+.IP "\fB\-f, \-\-format=\fR\fIfmt\fR" 4
+.IX Item "-f, --format=fmt"
+.Vb 1
+\&  force block driver for format I<fmt> instead of auto\-detecting
+.Ve
+.IP "\fB\-t, \-\-persistent\fR" 4
+.IX Item "-t, --persistent"
+.Vb 1
+\&  don\*(Aqt exit on the last connection
+.Ve
+.IP "\fB\-v, \-\-verbose\fR" 4
+.IX Item "-v, --verbose"
+.Vb 1
+\&  display extra debugging information
+.Ve
+.IP "\fB\-h, \-\-help\fR" 4
+.IX Item "-h, --help"
+.Vb 1
+\&  display this help and exit
+.Ve
+.IP "\fB\-V, \-\-version\fR" 4
+.IX Item "-V, --version"
+.Vb 1
+\&  output version information and exit
+.Ve
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+\&\fIqemu\-img\fR\|(1)
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Copyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>.
+This is free software; see the source for copying conditions.  There is \s-1NO\s0
+warranty; not even for \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
diff --git a/qemu/share/qemu/QEMU,cgthree.bin b/qemu/share/qemu/QEMU,cgthree.bin
new file mode 100644
index 0000000..6fec946
Binary files /dev/null and b/qemu/share/qemu/QEMU,cgthree.bin differ
diff --git a/qemu/share/qemu/QEMU,tcx.bin b/qemu/share/qemu/QEMU,tcx.bin
new file mode 100644
index 0000000..d79cc1f
Binary files /dev/null and b/qemu/share/qemu/QEMU,tcx.bin differ
diff --git a/qemu/share/qemu/acpi-dsdt.aml b/qemu/share/qemu/acpi-dsdt.aml
new file mode 100644
index 0000000..558c10f
Binary files /dev/null and b/qemu/share/qemu/acpi-dsdt.aml differ
diff --git a/qemu/share/qemu/bamboo.dtb b/qemu/share/qemu/bamboo.dtb
new file mode 100644
index 0000000..d12e201
Binary files /dev/null and b/qemu/share/qemu/bamboo.dtb differ
diff --git a/qemu/share/qemu/bios-256k.bin b/qemu/share/qemu/bios-256k.bin
new file mode 100644
index 0000000..c6e25ac
Binary files /dev/null and b/qemu/share/qemu/bios-256k.bin differ
diff --git a/qemu/share/qemu/bios.bin b/qemu/share/qemu/bios.bin
new file mode 100644
index 0000000..46ca37b
Binary files /dev/null and b/qemu/share/qemu/bios.bin differ
diff --git a/qemu/share/qemu/efi-e1000.rom b/qemu/share/qemu/efi-e1000.rom
new file mode 100644
index 0000000..4e29d9d
Binary files /dev/null and b/qemu/share/qemu/efi-e1000.rom differ
diff --git a/qemu/share/qemu/efi-eepro100.rom b/qemu/share/qemu/efi-eepro100.rom
new file mode 100644
index 0000000..2a92d6f
Binary files /dev/null and b/qemu/share/qemu/efi-eepro100.rom differ
diff --git a/qemu/share/qemu/efi-ne2k_pci.rom b/qemu/share/qemu/efi-ne2k_pci.rom
new file mode 100644
index 0000000..6366017
Binary files /dev/null and b/qemu/share/qemu/efi-ne2k_pci.rom differ
diff --git a/qemu/share/qemu/efi-pcnet.rom b/qemu/share/qemu/efi-pcnet.rom
new file mode 100644
index 0000000..a61f586
Binary files /dev/null and b/qemu/share/qemu/efi-pcnet.rom differ
diff --git a/qemu/share/qemu/efi-rtl8139.rom b/qemu/share/qemu/efi-rtl8139.rom
new file mode 100644
index 0000000..c9c77ea
Binary files /dev/null and b/qemu/share/qemu/efi-rtl8139.rom differ
diff --git a/qemu/share/qemu/efi-virtio.rom b/qemu/share/qemu/efi-virtio.rom
new file mode 100644
index 0000000..eec2790
Binary files /dev/null and b/qemu/share/qemu/efi-virtio.rom differ
diff --git a/qemu/share/qemu/keymaps/ar b/qemu/share/qemu/keymaps/ar
new file mode 100644
index 0000000..c430c03
--- /dev/null
+++ b/qemu/share/qemu/keymaps/ar
@@ -0,0 +1,98 @@
+# generated from XKB map ar
+include common
+map 0x401
+exclam 0x02 shift
+at 0x03 shift
+numbersign 0x04 shift
+dollar 0x05 shift
+percent 0x06 shift
+asciicircum 0x07 shift
+ampersand 0x08 shift
+asterisk 0x09 shift
+parenleft 0x0a shift
+parenright 0x0b shift
+minus 0x0c
+underscore 0x0c shift
+equal 0x0d
+plus 0x0d shift
+Arabic_dad 0x10 altgr
+Arabic_fatha 0x10 shift altgr
+Arabic_sad 0x11 altgr
+Arabic_fathatan 0x11 shift altgr
+Arabic_theh 0x12 altgr
+Arabic_damma 0x12 shift altgr
+Arabic_qaf 0x13 altgr
+Arabic_dammatan 0x13 shift altgr
+Arabic_feh 0x14 altgr
+UFEF9 0x14 shift altgr
+Arabic_ghain 0x15 altgr
+Arabic_hamzaunderalef 0x15 shift altgr
+Arabic_ain 0x16 altgr
+grave 0x16 shift altgr
+Arabic_ha 0x17 altgr
+division 0x17 shift altgr
+Arabic_khah 0x18 altgr
+multiply 0x18 shift altgr
+Arabic_hah 0x19 altgr
+Arabic_semicolon 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+Arabic_jeem 0x1a altgr
+bracketright 0x1b
+braceright 0x1b shift
+Arabic_dal 0x1b altgr
+Arabic_sheen 0x1e altgr
+backslash 0x1e shift altgr
+Arabic_seen 0x1f altgr
+Arabic_yeh 0x20 altgr
+bracketleft 0x20 shift altgr
+Arabic_beh 0x21 altgr
+bracketright 0x21 shift altgr
+Arabic_lam 0x22 altgr
+UFEF7 0x22 shift altgr
+Arabic_alef 0x23 altgr
+Arabic_hamzaonalef 0x23 shift altgr
+Arabic_teh 0x24 altgr
+Arabic_tatweel 0x24 shift altgr
+Arabic_noon 0x25 altgr
+Arabic_comma 0x25 shift altgr
+Arabic_meem 0x26 altgr
+slash 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+Arabic_kaf 0x27 altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+Arabic_tah 0x28 altgr
+grave 0x29
+asciitilde 0x29 shift
+Arabic_thal 0x29 altgr
+Arabic_shadda 0x29 shift altgr
+backslash 0x2b
+bar 0x2b shift
+less 0x2b altgr
+greater 0x2b shift altgr
+Arabic_hamzaonyeh 0x2c altgr
+asciitilde 0x2c shift altgr
+Arabic_hamza 0x2d altgr
+Arabic_sukun 0x2d shift altgr
+Arabic_hamzaonwaw 0x2e altgr
+Arabic_kasra 0x2e shift altgr
+Arabic_ra 0x2f altgr
+Arabic_kasratan 0x2f shift altgr
+UFEFB 0x30 altgr
+UFEF5 0x30 shift altgr
+Arabic_alefmaksura 0x31 altgr
+Arabic_maddaonalef 0x31 shift altgr
+Arabic_tehmarbuta 0x32 altgr
+apostrophe 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+Arabic_waw 0x33 altgr
+period 0x34
+greater 0x34 shift
+Arabic_zain 0x34 altgr
+slash 0x35
+question 0x35 shift
+Arabic_zah 0x35 altgr
+Arabic_question_mark 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/bepo b/qemu/share/qemu/keymaps/bepo
new file mode 100644
index 0000000..d40041a
--- /dev/null
+++ b/qemu/share/qemu/keymaps/bepo
@@ -0,0 +1,333 @@
+include common
+
+# Bépo : Improved ergonomic french keymap using Dvorak method.
+# Built by community on 'Dvorak Fr / Bépo' :
+# see http://www.clavier-dvorak.org/wiki/ to join and help.
+#
+# Bépo layout (1.0rc2 version) for a pc105 keyboard (french) :
+# ┌────┐
+# │ S A│   S = Shift,  A = AltGr + Shift
+# │ s a│   s = normal, a = AltGr
+# └────┘
+#
+# ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┲━━━━━━━━━┓
+# │ # ¶ │ 1 „ │ 2 “ │ 3 ” │ 4 ≤ │ 5 ≥ │ 6   │ 7 ¬ │ 8 ¼ │ 9 ½ │ 0 ¾ │ ° ′ │ ` ″ ┃ ⌫ Retour┃
+# │ $ – │ " — │ « < │ » > │ ( [ │ ) ] │ @ ^ │ + ± │ - − │ / ÷ │ * × │ = ≠ │ % ‰ ┃  arrière┃
+# ┢━━━━━┷━┱───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┴─┬───┺━┳━━━━━━━┫
+# ┃       ┃ B ¦ │ É ˝ │ P § │ O Œ │ È ` │ !   │ V   │ D Ð │ L   │ J Ĳ │ Z Ə │ W   ┃Entrée ┃
+# ┃Tab ↹  ┃ b | │ é ˊ │ p & │ o œ │ è ` │ ˆ ¡ │ v ˇ │ d ð │ l / │ j ĳ │ z ə │ w ̆ ┃   ⏎   ┃
+# ┣━━━━━━━┻┱────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┴┬────┺┓      ┃
+# ┃        ┃ A Æ │ U Ù │ I ˙ │ E ¤ │ ; ̛ │ C ſ │ T Þ │ S ẞ │ R ™ │ N   │ M º │ Ç , ┃      ┃
+# ┃Maj ⇬   ┃ a æ │ u ù │ i ̈ │ e € │ , ’ │ c © │ t þ │ s ß │ r ® │ n ˜ │ m ¯ │ ç ¸ ┃      ┃
+# ┣━━━━━━━┳┹────┬┴────┬┴────┬┴────┬┴────┬┴────┬┴────┬┴────┬┴────┬┴────┬┴────┲┷━━━━━┻━━━━━━┫
+# ┃       ┃ Ê   │ À   │ Y ‘ │ X ’ │ : · │ K   │ ? ̉ │ Q ̣ │ G   │ H ‡ │ F ª ┃             ┃
+# ┃Shift ⇧┃ ê / │ à \ │ y { │ x } │ . … │ k ~ │ ' ¿ │ q ˚ │ g µ │ h † │ f ˛ ┃Shift ⇧      ┃
+# ┣━━━━━━━╋━━━━━┷━┳━━━┷━━━┱─┴─────┴─────┴─────┴─────┴─────┴───┲━┷━━━━━╈━━━━━┻━┳━━━━━━━┳━━━┛
+# ┃       ┃       ┃       ┃ Espace inséc.   Espace inséc. fin ┃       ┃       ┃       ┃
+# ┃Ctrl   ┃Meta   ┃Alt    ┃ ␣ (Espace)      _               ␣ ┃AltGr ⇮┃Menu   ┃Ctrl   ┃
+# ┗━━━━━━━┻━━━━━━━┻━━━━━━━┹───────────────────────────────────┺━━━━━━━┻━━━━━━━┻━━━━━━━┛
+
+
+# First row
+## keycode  41 = dollar numbersign       U+2013  U+00b6
+dollar        0x29
+numbersign    0x29  shift
+U2013         0x29        altgr
+U00b6         0x29  shift altgr
+
+## keycode   2 = +quotedbl +one          U+2014  U+201e
+quotedbl      0x2
+one           0x2  shift
+U2014         0x2        altgr
+U201e         0x2  shift altgr
+
+## keycode   3 = +guillemotleft  +two     less    U+201c
+guillemotleft  0x3
+two           0x3  shift
+less          0x3        altgr
+U201c         0x3  shift altgr
+
+## keycode   4 = +guillemotright +three  greater U+201d
+guillemotright  0x4
+three         0x4  shift
+greater       0x4        altgr
+U201d         0x4  shift altgr
+
+## keycode   5 = +parenleft +four        bracketleft  U+2264
+parenleft     0x5
+four          0x5  shift
+bracketleft   0x5        altgr
+U2264         0x5  shift altgr
+
+## keycode   6 = +parenright +five       bracketright  U+2265
+parenright    0x6
+five          0x6  shift
+bracketright  0x6        altgr
+U2265         0x6  shift altgr
+
+## keycode   7 = +at       +six          asciicircum
+at            0x7
+six           0x7  shift
+asciicircum   0x7        altgr
+
+## keycode   8 = +plus     +seven        U+00b1  U+00ac
+plus          0x8
+seven         0x8  shift
+U00b1         0x8        altgr
+U00ac         0x8  shift altgr
+
+## keycode   9 = +minus    +eight        U+2212  U+00bc
+minus         0x9
+eight         0x9  shift
+U2212         0x9        altgr
+U00bc         0x9  shift altgr
+
+## keycode  10 = +slash    +nine         U+00f7  U+00bd
+slash         0xa
+nine          0xa  shift
+U00f7         0xa        altgr
+U00bd         0xa  shift altgr
+
+## keycode  11 = +asterisk +zero         U+00d7  U+00be
+asterisk      0xb
+zero          0xb  shift
+U00d7         0xb        altgr
+U00be         0xb  shift altgr
+
+## keycode  12 = equal     U+00b0        U+2260  U+2032
+equal         0xc
+U00b0         0xc  shift
+U2260         0xc        altgr
+U2032         0xc  shift altgr
+
+## keycode  13 = percent   grave         U+2030  U+2033
+percent       0xd
+grave         0xd  shift
+U2030         0xd        altgr
+U2033         0xd  shift altgr
+
+
+# Second row
+
+# simplified letter definitions notation :
+## keycode 16 = b
+b             0x10  addupper
+## keycode 18 = p
+p             0x12  addupper
+## keycode 19 = o
+o             0x13  addupper
+## keycode 22 = v
+v             0x16  addupper
+## keycode 23 = d
+d             0x17  addupper
+## keycode 24 = l
+l             0x18  addupper
+## keycode 25 = j
+j             0x19  addupper
+## keycode 26 = z
+z             0x1a  addupper
+## keycode 27 = w
+w             0x1b  addupper
+
+# then, add specific definitions
+##                    AltGr keycode  16 = bar
+bar           0x10        altgr
+##              Shift AltGr keycode  16 = brokenbar
+brokenbar     0x10  shift altgr
+
+## keycode 17 = +eacute +Eacute dead_acute
+eacute        0x11
+Eacute        0x11  shift
+dead_acute    0x11        altgr
+
+##                    AltGr keycode  18 = ampersand
+ampersand     0x12        altgr
+##              Shift AltGr keycode  18 = U+00a7
+U00a7         0x12  shift altgr
+
+##                    AltGr keycode  19 = +U+0153
+U+0153        0x13        altgr
+##              Shift AltGr keycode  19 = +U+0152
+U+0152        0x13  shift altgr
+
+## keycode 20 = +egrave +Egrave dead_grave grave # no Meta !
+egrave        0x14
+Egrave        0x14  shift
+dead_grave    0x14        altgr
+
+## keycode 21 = dead_circumflex exclam exclamdown
+dead_circumflex  0x15
+exclam        0x15  shift
+exclamdown    0x15        altgr
+
+##                    AltGr keycode  22 = dead_caron
+dead_caron    0x16        altgr
+
+##                    AltGr keycode  23 = eth
+eth           0x17        altgr
+##              Shift AltGr keycode  23 = ETH
+ETH           0x17  shift altgr
+
+##                    AltGr keycode  25 = +U+0133
+U+0133        0x19        altgr
+##              Shift AltGr keycode  25 = +U+0132
+U+0132        0x19  shift altgr
+
+##                    AltGr keycode  26 = +U+0259
+U+0259        0x1a        altgr
+##              Shift AltGr keycode  26 = +U+018f
+U+018f        0x1a  shift altgr
+
+
+
+# Third row
+
+# simplified letter definitions notation :
+## keycode 30 = a
+a             0x1e  addupper
+## keycode 31 = u
+u             0x1f  addupper
+## keycode 32 = i
+i             0x20  addupper
+## keycode 33 = e
+e             0x21  addupper
+## keycode 35 = c
+c             0x23  addupper
+## keycode 36 = t
+t             0x24  addupper
+## keycode 37 = s
+s             0x25  addupper
+## keycode 38 = r
+r             0x26  addupper
+## keycode 39 = n
+n             0x27  addupper
+## keycode 40 = m
+m             0x28  addupper
+
+# then, add specific definitions
+##                    AltGr keycode  30 = +ae
+ae            0x1e        altgr
+##              Shift AltGr keycode  30 = +AE
+AE            0x1e  shift altgr
+
+##                    AltGr keycode  31 = +ugrave
+ugrave        0x1f        altgr
+##              Shift AltGr keycode  31 = +Ugrave
+Ugrave        0x1f  shift altgr
+
+##                    AltGr keycode  32 = dead_diaeresis
+dead_diaeresis  0x20        altgr
+
+
+##                    AltGr keycode  33 = U+20ac
+U20ac         0x21        altgr
+
+## keycode 34 = comma semicolon U+2019 +U+031b
+comma         0x22
+semicolon     0x22  shift
+U2019         0x22        altgr
+U+031b        0x22  shift altgr
+
+##                    AltGr keycode  35 = copyright
+copyright     0x23        altgr
+##              Shift AltGr keycode  35 = U+017f
+U017f         0x23  shift altgr
+
+##                    AltGr keycode  36 = +thorn
+thorn         0x24        altgr
+##              Shift AltGr keycode  36 = +THORN
+THORN         0x24  shift altgr
+
+##                    AltGr keycode  37 = +ssharp
+ssharp        0x25        altgr
+##              Shift AltGr keycode  37 = U+1e9e
+U1e9e         0x25  shift altgr
+
+##                    AltGr keycode  38 = registered
+registered    0x26        altgr
+##              Shift AltGr keycode  38 = U+2122
+U2122         0x26  shift altgr
+
+##                    AltGr keycode  39 = dead_tilde
+dead_tilde    0x27        altgr
+
+##              Shift AltGr keycode  40 = masculine
+masculine     0x28  shift altgr
+
+## keycode 43 = +ccedilla +Ccedilla dead_cedilla
+ccedilla      0x2b
+Ccedilla      0x2b  shift
+dead_cedilla  0x2b        altgr
+
+
+# Fourth row
+
+# simplified letter definitions notation :
+## keycode 45 = y
+y             0x2d  addupper
+## keycode 46 = x
+x             0x2e  addupper
+## keycode 48 = k
+k             0x30  addupper
+## keycode 50 = q
+q             0x32  addupper
+## keycode 51 = g
+g             0x33  addupper
+## keycode 52 = h
+h             0x34  addupper
+## keycode 53 = f
+f             0x35  addupper
+
+# then, add specific definitions
+## keycode 86 = +ecircumflex +Ecircumflex slash slash
+ecircumflex   0x56
+Ecircumflex   0x56  shift
+
+## keycode 44 = +agrave +Agrave backslash
+agrave        0x2c
+Agrave        0x2c  shift
+backslash     0x2c        altgr
+
+##                    AltGr keycode  45 = braceleft
+braceleft     0x2d        altgr
+##              Shift AltGr keycode  45 = U+2018
+U2018         0x2d  shift altgr
+
+##                    AltGr keycode  46 = braceright
+braceright    0x2e        altgr
+
+## keycode 47 = period colon U+2026 periodcentered
+period        0x2f
+colon         0x2f  shift
+U2026         0x2f        altgr
+periodcentered  0x2f  shift altgr
+
+##                    AltGr keycode  48 = asciitilde
+asciitilde    0x30        altgr
+##              Shift AltGr keycode  48 = U+2328
+U2328         0x30  shift altgr
+
+## keycode 49 = apostrophe question questiondown +U+0309
+apostrophe    0x31
+question      0x31  shift
+questiondown  0x31        altgr
+U+0309        0x31  shift altgr
+
+##                    AltGr keycode  51 = mu
+mu            0x33        altgr
+
+##                    AltGr keycode  52 = U+2020
+U2020         0x34        altgr
+##              Shift AltGr keycode  52 = U+2021
+U2021         0x34  shift altgr
+
+##              Shift AltGr keycode  53 = ordfeminine
+ordfeminine   0x35  shift altgr
+
+
+
+## keycode 57 = space nobreakspace underscore U+202f
+space         0x39
+nobreakspace  0x39  shift
+underscore    0x39        altgr
+U202f         0x39  shift altgr
diff --git a/qemu/share/qemu/keymaps/common b/qemu/share/qemu/keymaps/common
new file mode 100644
index 0000000..adc56c7
--- /dev/null
+++ b/qemu/share/qemu/keymaps/common
@@ -0,0 +1,157 @@
+include modifiers
+
+#
+# Top row
+#
+1 0x2
+2 0x3
+3 0x4
+4 0x5
+5 0x6
+6 0x7
+7 0x8
+8 0x9
+9 0xa
+0 0xb
+BackSpace 0xe
+
+#
+# QWERTY first row
+#
+Tab 0xf localstate
+ISO_Left_Tab 0xf shift
+q 0x10 addupper
+w 0x11 addupper
+e 0x12 addupper
+r 0x13 addupper
+t 0x14 addupper
+y 0x15 addupper
+u 0x16 addupper
+i 0x17 addupper
+o 0x18 addupper
+p 0x19 addupper
+
+#
+# QWERTY second row
+#
+a 0x1e addupper
+s 0x1f addupper
+d 0x20 addupper
+f 0x21 addupper
+g 0x22 addupper
+h 0x23 addupper
+j 0x24 addupper
+k 0x25 addupper
+l 0x26 addupper
+Return 0x1c localstate
+
+#
+# QWERTY third row
+#
+z 0x2c addupper
+x 0x2d addupper
+c 0x2e addupper
+v 0x2f addupper
+b 0x30 addupper
+n 0x31 addupper
+m 0x32 addupper
+
+space 0x39 localstate
+
+less 0x56
+greater 0x56 shift
+bar 0x56 altgr
+brokenbar 0x56 shift altgr
+
+#
+# Esc and Function keys
+#
+Escape 0x1 localstate
+F1 0x3b localstate
+F2 0x3c localstate
+F3 0x3d localstate
+F4 0x3e localstate
+F5 0x3f localstate
+F6 0x40 localstate
+F7 0x41 localstate
+F8 0x42 localstate
+F9 0x43 localstate
+F10 0x44 localstate
+F11 0x57 localstate
+F12 0x58 localstate
+
+# Printscreen, Scrollock and Pause
+# Printscreen really requires four scancodes (0xe0, 0x2a, 0xe0, 0x37),
+# but (0xe0, 0x37) seems to work.
+Print 0xb7 localstate
+Sys_Req 0xb7 localstate
+Execute 0xb7 localstate
+Scroll_Lock 0x46
+
+#
+# Insert - PgDown
+#
+Insert 0xd2 localstate
+Delete 0xd3 localstate
+Home 0xc7 localstate
+End 0xcf localstate
+Page_Up 0xc9 localstate
+Page_Down 0xd1 localstate
+
+#
+# Arrow keys
+#
+Left 0xcb localstate
+Up 0xc8 localstate
+Down 0xd0 localstate
+Right 0xcd localstate
+
+#
+# Numpad
+#
+Num_Lock 0x45
+KP_Divide 0xb5
+KP_Multiply 0x37
+KP_Subtract 0x4a
+KP_Add 0x4e
+KP_Enter 0x9c
+
+KP_Decimal 0x53 numlock
+KP_Separator 0x53 numlock
+KP_Delete 0x53
+
+KP_0 0x52 numlock
+KP_Insert 0x52
+
+KP_1 0x4f numlock
+KP_End 0x4f
+
+KP_2 0x50 numlock
+KP_Down 0x50
+
+KP_3 0x51 numlock
+KP_Next 0x51
+
+KP_4 0x4b numlock
+KP_Left 0x4b
+
+KP_5 0x4c numlock
+KP_Begin 0x4c
+
+KP_6 0x4d numlock
+KP_Right 0x4d
+
+KP_7 0x47 numlock
+KP_Home 0x47
+
+KP_8 0x48 numlock
+KP_Up 0x48
+
+KP_9 0x49 numlock
+KP_Prior 0x49
+
+Caps_Lock 0x3a
+#
+# Inhibited keys
+#
+Multi_key 0x0 inhibit
diff --git a/qemu/share/qemu/keymaps/cz b/qemu/share/qemu/keymaps/cz
new file mode 100644
index 0000000..6584bfb
--- /dev/null
+++ b/qemu/share/qemu/keymaps/cz
@@ -0,0 +1,94 @@
+include common
+
+# Czech qwertz layout
+# comments are czech descriptions of the characters
+
+# -----------
+#  First row
+# -----------
+
+# strednik, kolecko
+semicolon 0x29
+dead_abovering 0x29 shift
+
+# numbers
+plus 0x2
+1 0x2 shift
+ecaron 0x3
+2 0x3 shift
+scaron 0x4
+3 0x4 shift
+ccaron 0x5
+4 0x5 shift
+rcaron 0x6
+5 0x6 shift
+zcaron 0x7
+6 0x7 shift
+yacute 0x8
+7 0x8 shift
+aacute 0x9
+8 0x9 shift
+iacute 0xa
+9 0xa shift
+eacute 0xb
+0 0xb shift
+
+# rovnitko
+equal 0x0c
+percent 0x0c shift
+
+# carka, hacek
+dead_acute 0x0d
+dead_caron 0x0d shift
+
+# ------------
+#  Second row
+# ------------
+
+z 0x15 addupper
+
+# u s carkou, zpetne lomitko
+uacute 0x1a
+slash 0x1a shift
+
+# prava zavorka, leva zavorka
+parenright 0x1b
+parenleft 0x1b shift
+
+# -----------
+#  Third row
+# -----------
+
+# u s krouzkem, uvozovky
+uring 0x27
+quotedbl 0x27 shift
+
+# paragraf, vykricnik
+section 0x28
+exclam 0x28 shift
+
+# vodorovna dvojtecka, apostrof
+dead_diaeresis 0x2b
+apostrophe 0x2b shift
+
+# ------------
+#  Fourth row
+# ------------
+
+# zpetne lomitko, roura
+backslash 0x2b
+bar 0x2b shift
+
+y 0x2c addupper
+
+# carka, otaznik
+comma 0x33
+question 0x33 shift
+
+# tecka, dvojtecka
+period 0x34
+colon 0x34 shift
+
+# minus, podtrzitko
+minus 0x35
+underscore 0x35 shift
diff --git a/qemu/share/qemu/keymaps/da b/qemu/share/qemu/keymaps/da
new file mode 100644
index 0000000..3884dcf
--- /dev/null
+++ b/qemu/share/qemu/keymaps/da
@@ -0,0 +1,120 @@
+# generated from XKB map dk
+include common
+map 0x406
+exclam 0x02 shift
+exclamdown 0x02 altgr
+onesuperior 0x02 shift altgr
+quotedbl 0x03 shift
+at 0x03 altgr
+twosuperior 0x03 shift altgr
+numbersign 0x04 shift
+sterling 0x04 altgr
+threesuperior 0x04 shift altgr
+currency 0x05 shift
+dollar 0x05 altgr
+onequarter 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+cent 0x06 shift altgr
+ampersand 0x07 shift
+yen 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+division 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+guillemotleft 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+guillemotright 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+plus 0x0c
+question 0x0c shift
+plusminus 0x0c altgr
+questiondown 0x0c shift altgr
+dead_acute 0x0d
+dead_grave 0x0d shift
+bar 0x0d altgr
+brokenbar 0x0d shift altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+registered 0x13 altgr
+thorn 0x14 altgr
+THORN 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oe 0x18 altgr
+OE 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+aring 0x1a
+Aring 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+dead_diaeresis 0x1b
+dead_circumflex 0x1b shift
+dead_tilde 0x1b altgr
+dead_caron 0x1b shift altgr
+ordfeminine 0x1e altgr
+masculine 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+ae 0x27
+AE 0x27 shift
+oslash 0x28
+Ooblique 0x28 shift
+dead_caron 0x28 shift altgr
+onehalf 0x29
+section 0x29 shift
+threequarters 0x29 altgr
+paragraph 0x29 shift altgr
+apostrophe 0x2b
+asterisk 0x2b shift
+dead_doubleacute 0x2b altgr
+multiply 0x2b shift altgr
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+copyright 0x2e altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+dead_cedilla 0x33 altgr
+dead_ogonek 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+dead_abovedot 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+hyphen 0x35 altgr
+macron 0x35 shift altgr
+nobreakspace 0x39 altgr
+less 0x56
+greater 0x56 shift
+backslash 0x56 altgr
+notsign 0x56 shift altgr
diff --git a/qemu/share/qemu/keymaps/de b/qemu/share/qemu/keymaps/de
new file mode 100644
index 0000000..ed929c7
--- /dev/null
+++ b/qemu/share/qemu/keymaps/de
@@ -0,0 +1,114 @@
+# generated from XKB map de
+include common
+map 0x407
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+section 0x04 shift
+threesuperior 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+currency 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+ssharp 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+acute 0x0d
+dead_acute 0x0d
+grave 0x0d shift
+dead_grave 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+z 0x15 addupper
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+udiaeresis 0x1a
+Udiaeresis 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+plus 0x1b
+asterisk 0x1b shift
+asciitilde 0x1b altgr
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+odiaeresis 0x27
+Odiaeresis 0x27 shift
+dead_doubleacute 0x27 altgr
+adiaeresis 0x28
+Adiaeresis 0x28 shift
+dead_caron 0x28 shift altgr
+asciicircum 0x29
+dead_circumflex 0x29
+degree 0x29 shift
+notsign 0x29 altgr
+numbersign 0x2b
+apostrophe 0x2b shift
+dead_breve 0x2b shift altgr
+y 0x2c addupper
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/de-ch b/qemu/share/qemu/keymaps/de-ch
new file mode 100644
index 0000000..852f8b8
--- /dev/null
+++ b/qemu/share/qemu/keymaps/de-ch
@@ -0,0 +1,169 @@
+# rdesktop Swiss-German (de-ch) keymap file
+# 2003-06-03 by noldi@tristar.ch
+#
+include common
+map 0x00000807
+#
+# Scan Code 1
+section 0x29
+degree 0x29 shift
+notsign 0x29 altgr inhibit
+#
+# Scan Code 2
+plus 0x2 shift
+brokenbar 0x02 altgr
+#
+# Scan Code 3
+quotedbl 0x03 shift
+at 0x03 altgr
+#
+# Scan Code 4
+asterisk 0x04 shift
+numbersign 0x04 altgr
+#
+# Scan Code 5
+ccedilla 0x05 shift
+onequarter 0x05 altgr inhibit
+#
+# Scan Code 6
+percent 0x06 shift
+onehalf 0x06 altgr inhibit
+#
+# Scan Code 7
+ampersand 0x07 shift
+notsign 0x07 altgr
+#
+# Scan Code 8
+slash 0x08 shift
+bar 0x08 altgr
+#
+# Scan Code 9
+parenleft 0x09 shift
+cent 0x09 altgr
+#
+# Scan Code 10
+parenright 0x0a shift
+#
+# Scan Code 11
+equal 0x0b shift
+braceright 0x0b altgr inhibit
+#
+# Scan Code 12
+apostrophe 0x0c
+question 0x0c shift
+dead_acute 0x0c altgr
+#
+# Scan Code 13
+dead_circumflex 0x0d
+dead_grave 0x0d shift
+dead_tilde 0x0d altgr
+#
+# Scan Code 19
+EuroSign 0x12 altgr
+#
+# Scan Code 22
+z 0x15 addupper
+#
+# Scan Code 27
+udiaeresis 0x1a
+egrave 0x1a shift
+bracketleft 0x1a altgr
+#
+# Scan Code 28
+dead_diaeresis 0x1b
+exclam 0x1b shift
+bracketright 0x1b altgr
+#
+# Scan Code 40
+odiaeresis 0x27
+eacute 0x27 shift
+#
+# Scan Code 41
+adiaeresis 0x28
+agrave 0x28 shift
+braceleft 0x28 altgr
+#
+# Scan Code 42 (only on international keyboards)
+dollar 0x2b
+sterling 0x2b shift
+braceright 0x2b altgr
+#
+# Scan Code 45 (only on international keyboards)
+backslash 0x56 altgr
+#
+# Scan Code 46
+y 0x2c addupper
+#
+# Scan Code 53
+comma 0x33
+semicolon 0x33 shift
+#
+# Scan Code 54
+period 0x34
+colon 0x34 shift
+#
+# Scan Code 55
+minus 0x35
+underscore 0x35 shift
+#
+# Suppress Windows unsupported AltGr keys
+#
+# Scan Code 17
+paragraph 0x10 altgr inhibit
+#
+# Scan Code 21
+tslash 0x14 altgr inhibit
+#
+# Scan Code 22
+leftarrow 0x15 altgr inhibit
+#
+# Scan Code 23
+downarrow 0x16 altgr inhibit
+#
+# Scan Code 24
+rightarrow 0x17 altgr inhibit
+#
+# Scan Code 25
+oslash 0x18 altgr inhibit
+#
+# Scan Code 26
+thorn 0x19 altgr inhibit
+#
+# Scan Code 31
+ae 0x1e altgr inhibit
+#
+# Scan Code 32
+ssharp 0x1f altgr inhibit
+#
+# Scan Code 33
+eth 0x20 altgr inhibit
+#
+# Scan Code 34
+dstroke 0x21 altgr inhibit
+#
+# Scan Code 35
+eng 0x22 altgr inhibit
+#
+# Scan Code 36
+hstroke 0x23 altgr inhibit
+#
+# Scan Code 38
+kra 0x25 altgr inhibit
+#
+# Scan Code 39
+lstroke 0x26 altgr inhibit
+#
+# Scan Code 46
+guillemotleft 0x2c altgr inhibit
+#
+# Scan Code 47
+guillemotright 0x2d altgr inhibit
+#
+# Scan Code 49
+leftdoublequotemark 0x2f altgr inhibit
+#
+# Scan Code 50
+rightdoublequotemark 0x30 altgr inhibit
+#
+# Scan Code 52
+mu 0x32 altgr inhibit
diff --git a/qemu/share/qemu/keymaps/en-gb b/qemu/share/qemu/keymaps/en-gb
new file mode 100644
index 0000000..b45f06c
--- /dev/null
+++ b/qemu/share/qemu/keymaps/en-gb
@@ -0,0 +1,119 @@
+# generated from XKB map gb
+include common
+map 0x809
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+sterling 0x04 shift
+threesuperior 0x04 altgr
+dollar 0x05 shift
+EuroSign 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+asciicircum 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+ampersand 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+asterisk 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenleft 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+parenright 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+minus 0x0c
+underscore 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+equal 0x0d
+plus 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+apostrophe 0x28
+at 0x28 shift
+dead_circumflex 0x28 altgr
+dead_caron 0x28 shift altgr
+grave 0x29
+notsign 0x29 shift
+bar 0x29 altgr
+numbersign 0x2b
+asciitilde 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+guillemotleft 0x2c altgr
+less 0x2c shift altgr
+guillemotright 0x2d altgr
+greater 0x2d shift altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
+backslash 0x56
+bar 0x56 shift
diff --git a/qemu/share/qemu/keymaps/en-us b/qemu/share/qemu/keymaps/en-us
new file mode 100644
index 0000000..f5784bb
--- /dev/null
+++ b/qemu/share/qemu/keymaps/en-us
@@ -0,0 +1,35 @@
+# generated from XKB map us
+include common
+map 0x409
+exclam 0x02 shift
+at 0x03 shift
+numbersign 0x04 shift
+dollar 0x05 shift
+percent 0x06 shift
+asciicircum 0x07 shift
+ampersand 0x08 shift
+asterisk 0x09 shift
+parenleft 0x0a shift
+parenright 0x0b shift
+minus 0x0c
+underscore 0x0c shift
+equal 0x0d
+plus 0x0d shift
+bracketleft 0x1a
+braceleft 0x1a shift
+bracketright 0x1b
+braceright 0x1b shift
+semicolon 0x27
+colon 0x27 shift
+apostrophe 0x28
+quotedbl 0x28 shift
+grave 0x29
+asciitilde 0x29 shift
+backslash 0x2b
+bar 0x2b shift
+comma 0x33
+less 0x33 shift
+period 0x34
+greater 0x34 shift
+slash 0x35
+question 0x35 shift
diff --git a/qemu/share/qemu/keymaps/es b/qemu/share/qemu/keymaps/es
new file mode 100644
index 0000000..0c29eec
--- /dev/null
+++ b/qemu/share/qemu/keymaps/es
@@ -0,0 +1,105 @@
+# generated from XKB map es
+include common
+map 0x40a
+exclam 0x02 shift
+bar 0x02 altgr
+quotedbl 0x03 shift
+at 0x03 altgr
+oneeighth 0x03 shift altgr
+periodcentered 0x04 shift
+numbersign 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+asciitilde 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+notsign 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+trademark 0x09 shift altgr
+parenright 0x0a shift
+plusminus 0x0a shift altgr
+equal 0x0b shift
+degree 0x0b shift altgr
+apostrophe 0x0c
+question 0x0c shift
+exclamdown 0x0d
+questiondown 0x0d shift
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+dead_grave 0x1a
+dead_circumflex 0x1a shift
+bracketleft 0x1a altgr
+dead_abovering 0x1a shift altgr
+plus 0x1b
+asterisk 0x1b shift
+bracketright 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+ntilde 0x27
+Ntilde 0x27 shift
+dead_doubleacute 0x27 shift altgr
+dead_acute 0x28
+dead_diaeresis 0x28 shift
+braceleft 0x28 altgr
+masculine 0x29
+ordfeminine 0x29 shift
+backslash 0x29 altgr
+ccedilla 0x2b
+Ccedilla 0x2b shift
+braceright 0x2b altgr
+dead_breve 0x2b shift altgr
+guillemotleft 0x2c altgr
+less 0x56
+greater 0x56 shift
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/et b/qemu/share/qemu/keymaps/et
new file mode 100644
index 0000000..85541a3
--- /dev/null
+++ b/qemu/share/qemu/keymaps/et
@@ -0,0 +1,85 @@
+map 0x00000425
+include common
+
+#
+# Top row
+#
+dead_caron 0x29
+dead_tilde 0x29 shift
+
+# 1
+exclam 0x2 shift
+
+# 2
+quotedbl 0x3 shift
+at 0x3 altgr
+
+# 3
+numbersign 0x4 shift
+sterling 0x4 altgr
+# 4
+currency 0x5 shift
+dollar 0x5 altgr
+# 5
+percent 0x6 shift
+# 6
+ampersand 0x7 shift
+# 7
+slash 0x8 shift
+braceleft 0x8 altgr
+# 8
+parenleft 0x9 shift
+bracketleft 0x9 altgr
+# 9
+parenright 0xa shift
+bracketright 0xa altgr
+# 0
+equal 0xb shift
+braceright 0xb altgr
+
+plus 0xc
+question 0xc shift
+backslash 0xc altgr
+
+acute 0xd
+dead_acute 0xd
+grave 0xd shift
+dead_grave 0xd shift
+
+#
+# QWERTY first row
+#
+EuroSign 0x12 altgr
+udiaeresis 0x1a
+Udiaeresis 0x1a shift
+otilde 0x1b
+Otilde 0x1b shift
+section 0x1b altgr
+
+#
+# QWERTY second row
+#
+scaron 0x1f altgr
+Scaron 0x1f altgr shift
+odiaeresis 0x27
+Odiaeresis 0x27 shift
+adiaeresis 0x28
+Adiaeresis 0x28 shift
+asciicircum 0x28 altgr
+apostrophe 0x2b
+asterisk 0x2b shift
+onehalf 0x2b altgr
+#
+# QWERTY third row
+#
+less 0x56
+greater 0x56 shift
+bar 0x56 altgr
+zcaron 0x2c altgr
+Zcaron 0x2c altgr shift
+comma 0x33
+semicolon 0x33 shift
+period 0x34
+colon 0x34 shift
+minus 0x35
+underscore 0x35 shift
diff --git a/qemu/share/qemu/keymaps/fi b/qemu/share/qemu/keymaps/fi
new file mode 100644
index 0000000..4be7586
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fi
@@ -0,0 +1,122 @@
+# generated from XKB map se_FI
+include common
+map 0x40b
+exclam 0x02 shift
+exclamdown 0x02 altgr
+onesuperior 0x02 shift altgr
+quotedbl 0x03 shift
+at 0x03 altgr
+twosuperior 0x03 shift altgr
+numbersign 0x04 shift
+sterling 0x04 altgr
+threesuperior 0x04 shift altgr
+currency 0x05 shift
+dollar 0x05 altgr
+onequarter 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+cent 0x06 shift altgr
+ampersand 0x07 shift
+yen 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+division 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+guillemotleft 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+guillemotright 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+plus 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+dead_acute 0x0d
+dead_grave 0x0d shift
+plusminus 0x0d altgr
+notsign 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+registered 0x13 altgr
+thorn 0x14 altgr
+THORN 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oe 0x18 altgr
+OE 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+aring 0x1a
+Aring 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+dead_diaeresis 0x1b
+dead_circumflex 0x1b shift
+dead_tilde 0x1b altgr
+dead_caron 0x1b shift altgr
+ordfeminine 0x1e altgr
+masculine 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+ampersand 0x25 shift altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+odiaeresis 0x27
+Odiaeresis 0x27 shift
+oslash 0x27 altgr
+Ooblique 0x27 shift altgr
+adiaeresis 0x28
+Adiaeresis 0x28 shift
+ae 0x28 altgr
+AE 0x28 shift altgr
+section 0x29
+onehalf 0x29 shift
+paragraph 0x29 altgr
+threequarters 0x29 shift altgr
+apostrophe 0x2b
+asterisk 0x2b shift
+acute 0x2b altgr
+multiply 0x2b shift altgr
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+copyright 0x2e altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+apostrophe 0x30 shift altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+dead_cedilla 0x33 altgr
+dead_ogonek 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+dead_abovedot 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+hyphen 0x35 altgr
+macron 0x35 shift altgr
+nobreakspace 0x39 altgr
diff --git a/qemu/share/qemu/keymaps/fo b/qemu/share/qemu/keymaps/fo
new file mode 100644
index 0000000..c00d9d4
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fo
@@ -0,0 +1,76 @@
+map 0x438
+include common
+
+#
+# Top row
+#
+onehalf 0x29
+section 0x29 shift
+
+# 1
+exclam 0x2 shift
+
+# 2
+quotedbl 0x3 shift
+at 0x3 altgr
+
+# 3
+numbersign 0x4 shift
+sterling 0x4 altgr
+# 4
+currency 0x5 shift
+dollar 0x5 altgr
+# 5
+percent 0x6 shift
+# 6
+ampersand 0x7 shift
+# 7
+slash 0x8 shift
+braceleft 0x8 altgr
+# 8
+parenleft 0x9 shift
+bracketleft 0x9 altgr
+# 9
+parenright 0xa shift
+bracketright 0xa altgr
+# 0
+equal 0xb shift
+braceright 0xb altgr
+
+plus 0xc
+question 0xc shift
+plusminus 0xc altgr
+
+bar 0xd altgr
+dead_acute 0xd
+
+#
+# QWERTY first row
+#
+EuroSign 0x12 altgr
+aring 0x1a
+Aring 0x1a shift
+eth 0x1b addupper
+asciitilde 0x1b altgr
+
+#
+# QWERTY second row
+#
+ae 0x27 addupper
+oslash 0x28
+Ooblique 0x28 shift
+apostrophe 0x2b
+asterisk 0x2b shift
+
+#
+# QWERTY third row
+#
+less 0x56
+greater 0x56 shift
+backslash 0x56 altgr
+comma 0x33
+semicolon 0x33 shift
+period 0x34
+colon 0x34 shift
+minus 0x35
+underscore 0x35 shift
diff --git a/qemu/share/qemu/keymaps/fr b/qemu/share/qemu/keymaps/fr
new file mode 100644
index 0000000..ba5a176
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fr
@@ -0,0 +1,181 @@
+include common
+map 0x40c
+#
+# Top row
+#
+twosuperior 0x29
+notsign 0x29 altgr
+
+ampersand 0x02
+1 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+
+eacute 0x03
+2 0x03 shift
+asciitilde 0x03 altgr
+oneeighth 0x03 shift altgr
+
+quotedbl 0x04
+3 0x04 shift
+numbersign 0x04 altgr
+
+apostrophe 0x05
+4 0x05 shift
+braceleft 0x05 altgr
+
+parenleft 0x06
+5 0x06 shift
+bracketleft 0x06 altgr
+threeeighths 0x06 shift altgr
+
+minus 0x07
+6 0x07 shift
+bar 0x07 altgr
+fiveeighths 0x07 shift altgr
+
+egrave 0x08
+7 0x08 shift
+grave 0x08 altgr
+seveneighths 0x08 shift altgr
+
+underscore 0x09
+8 0x09 shift
+backslash 0x09 altgr
+trademark 0x09 shift altgr
+
+ccedilla 0x0a
+9 0x0a shift
+asciicircum 0x0a altgr
+plusminus 0x0a shift altgr
+
+agrave 0x0b
+0 0x0b shift
+at 0x0b altgr
+
+parenright 0x0c
+degree 0x0c shift
+bracketright 0x0c altgr
+questiondown 0x0c shift altgr
+
+equal 0x0d
+plus 0x0d shift
+braceright 0x0d altgr
+dead_ogonek 0x0d shift altgr
+
+#
+# AZERTY first row
+#
+
+a 0x10 addupper
+ae 0x10 altgr
+AE 0x10 shift altgr
+
+z 0x11 addupper
+guillemotleft 0x11 altgr
+
+EuroSign 0x12 altgr
+
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+
+dead_circumflex 0x1a
+dead_diaeresis 0x1a shift
+dead_abovering 0x1a shift altgr
+
+dollar 0x1b
+sterling 0x1b shift
+currency 0x1b altgr
+dead_macron 0x1b shift altgr
+
+#
+# AZERTY second row
+#
+q 0x1e addupper
+Greek_OMEGA 0x1e shift altgr
+
+ssharp 0x1f altgr
+
+eth 0x20 altgr
+ETH 0x20 shift altgr
+
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+
+eng 0x22 altgr
+ENG 0x22 shift altgr
+
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+
+kra 0x25 altgr
+
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+
+m 0x27 addupper
+masculine 0x27 shift altgr
+
+ugrave 0x28
+percent 0x28 shift
+dead_caron 0x28 shift altgr
+
+asterisk 0x2b
+mu 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+
+#
+# AZERTY third row
+#
+less 0x56
+greater 0x56 shift
+
+w 0x2c addupper
+
+guillemotright 0x2d altgr
+
+cent 0x2e altgr
+copyright 0x2e shift altgr
+
+leftdoublequotemark 0x2f altgr
+
+rightdoublequotemark 0x30 altgr
+
+comma 0x32
+question 0x32 shift
+dead_acute 0x32 altgr
+dead_doubleacute 0x32 shift altgr
+
+semicolon 0x33
+period 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+
+colon 0x34
+slash 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+
+exclam 0x35
+section 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/fr-be b/qemu/share/qemu/keymaps/fr-be
new file mode 100644
index 0000000..62f7128
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fr-be
@@ -0,0 +1,134 @@
+# generated from XKB map be
+include common
+map 0x80c
+ampersand 0x02
+1 0x02 shift
+bar 0x02 altgr
+exclamdown 0x02 shift altgr
+eacute 0x03
+2 0x03 shift
+at 0x03 altgr
+oneeighth 0x03 shift altgr
+quotedbl 0x04
+3 0x04 shift
+numbersign 0x04 altgr
+sterling 0x04 shift altgr
+apostrophe 0x05
+4 0x05 shift
+onequarter 0x05 altgr
+dollar 0x05 shift altgr
+parenleft 0x06
+5 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+section 0x07
+6 0x07 shift
+asciicircum 0x07 altgr
+fiveeighths 0x07 shift altgr
+egrave 0x08
+7 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+exclam 0x09
+8 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+ccedilla 0x0a
+9 0x0a shift
+braceleft 0x0a altgr
+plusminus 0x0a shift altgr
+agrave 0x0b
+0 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+parenright 0x0c
+degree 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+minus 0x0d
+underscore 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+a 0x10 addupper
+Greek_OMEGA 0x10 shift altgr
+z 0x11 addupper
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+dead_circumflex 0x1a
+dead_diaeresis 0x1a shift
+bracketleft 0x1a altgr
+dead_abovering 0x1a shift altgr
+dollar 0x1b
+asterisk 0x1b shift
+bracketright 0x1b altgr
+dead_macron 0x1b shift altgr
+q 0x1e addupper
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+m 0x27 addupper
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+ugrave 0x28
+percent 0x28 shift
+dead_acute 0x28 altgr
+dead_caron 0x28 shift altgr
+twosuperior 0x29
+threesuperior 0x29 shift
+notsign 0x29 altgr
+mu 0x2b
+sterling 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+w 0x2c addupper
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+comma 0x32
+question 0x32 shift
+dead_cedilla 0x32 altgr
+masculine 0x32 shift altgr
+semicolon 0x33
+period 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+colon 0x34
+slash 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+equal 0x35
+plus 0x35 shift
+dead_tilde 0x35 altgr
+dead_abovedot 0x35 shift altgr
+backslash 0x56 altgr
diff --git a/qemu/share/qemu/keymaps/fr-ca b/qemu/share/qemu/keymaps/fr-ca
new file mode 100644
index 0000000..b645208
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fr-ca
@@ -0,0 +1,50 @@
+# Canadian French
+# By Simon Germain
+include common
+map 0xc0c
+
+backslash 0x29 altgr
+plusminus 0x2 altgr
+at 0x3 altgr
+sterling 0x4 altgr
+cent 0x5 altgr
+currency 0x6 altgr
+notsign 0x7 altgr
+bar 0x29 shift
+twosuperior 0x9 altgr
+threesuperior 0xa altgr
+onequarter 0xb altgr
+onehalf 0xc altgr
+threequarters 0xd altgr
+section 0x18 altgr
+paragraph 0x19 altgr
+bracketleft 0x1a altgr
+bracketright 0x1b altgr
+asciitilde 0x27 altgr
+braceleft 0x28 altgr
+braceright 0x2b altgr
+less 0x2b
+greater 0x2b shift
+guillemotleft 0x56
+guillemotright 0x56 shift
+degree 0x56 altgr
+mu 0x32 altgr
+eacute 0x35
+dead_acute 0x35 altgr
+dead_grave 0x28
+dead_circumflex 0x1a
+dead_circumflex 0x1a shift
+dead_cedilla 0x1b
+dead_diaeresis 0x1b shift
+exclam 0x2 shift
+quotedbl 0x3 shift
+slash 0x4 shift
+dollar 0x5 shift
+percent 0x6 shift
+question 0x7 shift
+ampersand 0x8 shift
+asterisk 0x9 shift
+parenleft 0xa shift
+parenright 0xb shift
+underscore 0xc shift
+plus 0xd shift
diff --git a/qemu/share/qemu/keymaps/fr-ch b/qemu/share/qemu/keymaps/fr-ch
new file mode 100644
index 0000000..4620d20
--- /dev/null
+++ b/qemu/share/qemu/keymaps/fr-ch
@@ -0,0 +1,114 @@
+# generated from XKB map fr_CH
+include common
+map 0x100c
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+section 0x04 shift
+threesuperior 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+currency 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+ssharp 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+acute 0x0d
+dead_acute 0x0d
+grave 0x0d shift
+dead_grave 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+z 0x15 addupper
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+udiaeresis 0x1a
+Udiaeresis 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+plus 0x1b
+asterisk 0x1b shift
+asciitilde 0x1b altgr
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+odiaeresis 0x27
+Odiaeresis 0x27 shift
+dead_doubleacute 0x27 altgr
+adiaeresis 0x28
+Adiaeresis 0x28 shift
+dead_caron 0x28 shift altgr
+asciicircum 0x29
+dead_circumflex 0x29
+degree 0x29 shift
+notsign 0x29 altgr
+numbersign 0x2b
+apostrophe 0x2b shift
+dead_breve 0x2b shift altgr
+y 0x2c addupper
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/hr b/qemu/share/qemu/keymaps/hr
new file mode 100644
index 0000000..613aa69
--- /dev/null
+++ b/qemu/share/qemu/keymaps/hr
@@ -0,0 +1,125 @@
+# generated from XKB map hr
+include common
+map 0x41a
+exclam 0x02 shift
+asciitilde 0x02 altgr
+dead_tilde 0x02 shift altgr
+quotedbl 0x03 shift
+dead_caron 0x03 altgr
+caron 0x03 shift altgr
+numbersign 0x04 shift
+asciicircum 0x04 altgr
+dead_circumflex 0x04 shift altgr
+dollar 0x05 shift
+dead_breve 0x05 altgr
+breve 0x05 shift altgr
+percent 0x06 shift
+degree 0x06 altgr
+dead_abovering 0x06 shift altgr
+ampersand 0x07 shift
+dead_ogonek 0x07 altgr
+ogonek 0x07 shift altgr
+slash 0x08 shift
+grave 0x08 altgr
+dead_grave 0x08 shift altgr
+parenleft 0x09 shift
+dead_abovedot 0x09 altgr
+abovedot 0x09 shift altgr
+parenright 0x0a shift
+dead_acute 0x0a altgr
+apostrophe 0x0a shift altgr
+equal 0x0b shift
+dead_doubleacute 0x0b altgr
+doubleacute 0x0b shift altgr
+apostrophe 0x0c
+question 0x0c shift
+dead_diaeresis 0x0c altgr
+diaeresis 0x0c shift altgr
+plus 0x0d
+asterisk 0x0d shift
+dead_cedilla 0x0d altgr
+cedilla 0x0d shift altgr
+backslash 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+bar 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+z 0x15 addupper
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+scaron 0x1a
+Scaron 0x1a shift
+division 0x1a altgr
+dead_abovering 0x1a shift altgr
+dstroke 0x1b
+Dstroke 0x1b shift
+multiply 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+bracketleft 0x21 altgr
+ordfeminine 0x21 shift altgr
+bracketright 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+lstroke 0x25 altgr
+ampersand 0x25 shift altgr
+Lstroke 0x26 altgr
+ccaron 0x27
+Ccaron 0x27 shift
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+cacute 0x28
+Cacute 0x28 shift
+ssharp 0x28 altgr
+dead_caron 0x28 shift altgr
+dead_cedilla 0x29
+dead_diaeresis 0x29 shift
+notsign 0x29 altgr
+zcaron 0x2b
+Zcaron 0x2b shift
+currency 0x2b altgr
+dead_breve 0x2b shift altgr
+y 0x2c addupper
+guillemotleft 0x2c altgr
+less 0x2c shift altgr
+guillemotright 0x2d altgr
+greater 0x2d shift altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+at 0x2f altgr
+grave 0x2f shift altgr
+braceleft 0x30 altgr
+apostrophe 0x30 shift altgr
+braceright 0x31 altgr
+section 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/hu b/qemu/share/qemu/keymaps/hu
new file mode 100644
index 0000000..8aba444
--- /dev/null
+++ b/qemu/share/qemu/keymaps/hu
@@ -0,0 +1,115 @@
+# Hungarian keyboard layout (QWERTZ)
+# Created by: The NeverGone <never@delfin.klte.hu>
+
+include common
+map 0x40e
+
+
+# AltGr keys:
+notsign 0x29 altgr
+asciitilde 0x02 altgr
+caron 0x03 altgr
+asciicircum 0x04 altgr
+breve 0x05 altgr
+degree 0x06 altgr
+ogonek 0x07 altgr
+grave 0x08 altgr
+abovedot 0x09 altgr
+acute 0x0a altgr
+doubleacute 0x0b altgr
+diaeresis 0x0c altgr
+cedilla 0x0d altgr
+backslash 0x10 altgr
+bar 0x11 altgr
+EuroSign 0x12 altgr
+Iacute 0x17 altgr
+division 0x1a altgr
+multiply 0x1b altgr
+dstroke 0x1f altgr
+Dstroke 0x20 altgr
+bracketleft 0x21 altgr
+bracketright 0x22 altgr
+iacute 0x24 altgr
+lstroke 0x25 altgr
+Lstroke 0x26 altgr
+dollar 0x27 altgr
+ssharp 0x28 altgr
+currency 0x2b altgr
+less 0x56 altgr
+greater 0x2c altgr
+numbersign 0x2d altgr
+ampersand 0x2e altgr
+at 0x2f altgr
+braceleft 0x30 altgr
+braceright 0x31 altgr
+semicolon 0x33 altgr
+asterisk 0x35 altgr
+
+
+# Shift keys:
+section 0x29 shift
+apostrophe 0x02 shift
+quotedbl 0x03 shift
+plus 0x04 shift
+exclam 0x05 shift
+percent 0x06 shift
+slash 0x07 shift
+equal 0x08 shift
+parenleft 0x09 shift
+parenright 0x0a shift
+Odiaeresis 0x0b shift
+Udiaeresis 0x0c shift
+Oacute 0x0d shift
+Z 0x15 shift
+Odoubleacute 0x1a shift
+Uacute 0x1b shift
+Eacute 0x27 shift
+Aacute 0x28 shift
+Udoubleacute 0x2b shift
+Y 0x2c shift
+question 0x33 shift
+colon 0x34 shift
+underscore 0x35 shift
+F13 0x3b shift
+F14 0x3c shift
+F15 0x3d shift
+F16 0x3e shift
+F17 0x3f shift
+F18 0x40 shift
+F19 0x41 shift
+F20 0x42 shift
+F21 0x43 shift
+F22 0x44 shift
+F23 0x57 shift
+F24 0x58 shift
+
+
+# Ctrl keys:
+F25 0x3b ctrl
+F26 0x3c ctrl
+F27 0x3d ctrl
+F28 0x3e ctrl
+F29 0x3f ctrl
+F30 0x40 ctrl
+F31 0x41 ctrl
+F32 0x42 ctrl
+F33 0x43 ctrl
+F34 0x44 ctrl
+F35 0x57 ctrl
+#NoSymbol 0x58 ctrl
+
+
+0 0x29
+odiaeresis 0x0b
+udiaeresis 0x0c
+oacute 0x0d
+z 0x15
+odoubleacute 0x1a
+uacute 0x1b
+eacute 0x27
+aacute 0x28
+udoubleacute 0x2b
+y 0x2c
+comma 0x33
+period 0x34
+minus 0x35
diff --git a/qemu/share/qemu/keymaps/is b/qemu/share/qemu/keymaps/is
new file mode 100644
index 0000000..935ac1d
--- /dev/null
+++ b/qemu/share/qemu/keymaps/is
@@ -0,0 +1,139 @@
+# 2004-03-16 Halldór Guðmundsson and Morten Lange
+# Keyboard definition file for the Icelandic keyboard
+# to be used in rdesktop 1.3.x ( See rdesktop.org)
+# generated from XKB map de, and changed manually
+# Location for example /usr/local/share/rdesktop/keymaps/is
+include common
+map 0x40f
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+#section 0x04 shift
+numbersign 0x04 shift
+threesuperior 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+currency 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+#ssharp 0x0c
+odiaeresis 0x0c
+#question 0x0c shift
+Odiaeresis 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+#acute 0x0d
+minus  0x0d
+#dead_acute 0x0d
+#grave 0x0d shift
+#dead_grave 0x0d shift
+underscore 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+#z 0x15 addupper
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+#thorn 0x19 altgr
+#THORN 0x19 shift altgr
+#udiaeresis 0x1a
+#Udiaeresis 0x1a shift
+#dead_diaeresis 0x1a altgr
+#dead_abovering 0x1a shift altgr
+eth 0x1a
+ETH 0x1a shift
+apostrophe 0x1b
+question 0x1b shift
+#plus 0x1b
+#asterisk 0x1b shift
+asciitilde 0x1b altgr
+#grave 0x1b altgr
+#dead_tilde 0x1b altgr
+#dead_macron 0x1b shift altgr
+#ae 0x1e altgr
+#AE 0x1e shift altgr
+#eth 0x20 altgr
+#eth 0x20
+#ETH 0x20 shift altgr
+#ETH 0x20 shift
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+#adiaeresis 0x27
+#Adiaeresis 0x27 shift
+ae 0x27
+AE 0x27 shift
+dead_doubleacute 0x27 altgr
+#adiaeresis 0x28
+#Adiaeresis 0x28 shift
+#dead_caron 0x28 shift altgr
+#asciicircum 0x29
+acute  0x28
+dead_acute 0x28
+#dead_circumflex 0x29
+#degree 0x29 shift
+#notsign 0x29 altgr
+plus 0x2b
+asterisk 0x2b shift
+grave 0x2b altgr
+#numbersign 0x2b
+#apostrophe 0x2b shift
+#dead_breve 0x2b shift altgr
+#y 0x2c addupper
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+#minus 0x35
+#underscore 0x35 shift
+thorn 0x35
+THORN 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/it b/qemu/share/qemu/keymaps/it
new file mode 100644
index 0000000..00ca73a
--- /dev/null
+++ b/qemu/share/qemu/keymaps/it
@@ -0,0 +1,115 @@
+# generated from XKB map it
+include common
+map 0x410
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+sterling 0x04 shift
+threesuperior 0x04 altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+trademark 0x09 shift altgr
+parenright 0x0a shift
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+apostrophe 0x0c
+question 0x0c shift
+grave 0x0c altgr
+questiondown 0x0c shift altgr
+igrave 0x0d
+asciicircum 0x0d shift
+asciitilde 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+egrave 0x1a
+eacute 0x1a shift
+bracketleft 0x1a altgr
+dead_abovering 0x1a shift altgr
+plus 0x1b
+asterisk 0x1b shift
+bracketright 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+ograve 0x27
+ccedilla 0x27 shift
+at 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+agrave 0x28
+degree 0x28 shift
+numbersign 0x28 altgr
+backslash 0x29
+bar 0x29 shift
+notsign 0x29 altgr
+ugrave 0x2b
+section 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/ja b/qemu/share/qemu/keymaps/ja
new file mode 100644
index 0000000..9d90a78
--- /dev/null
+++ b/qemu/share/qemu/keymaps/ja
@@ -0,0 +1,109 @@
+# generated from XKB map jp106
+include common
+map 0x411
+exclam 0x02 shift
+kana_NU 0x02 altgr
+quotedbl 0x03 shift
+kana_FU 0x03 altgr
+numbersign 0x04 shift
+kana_A 0x04 altgr
+kana_a 0x04 shift altgr
+dollar 0x05 shift
+kana_U 0x05 altgr
+kana_u 0x05 shift altgr
+percent 0x06 shift
+kana_E 0x06 altgr
+kana_e 0x06 shift altgr
+ampersand 0x07 shift
+kana_O 0x07 altgr
+kana_o 0x07 shift altgr
+apostrophe 0x08 shift
+kana_YA 0x08 altgr
+kana_ya 0x08 shift altgr
+parenleft 0x09 shift
+kana_YU 0x09 altgr
+kana_yu 0x09 shift altgr
+parenright 0x0a shift
+kana_YO 0x0a altgr
+kana_yo 0x0a shift altgr
+asciitilde 0x0b shift
+kana_WA 0x0b altgr
+kana_WO 0x0b shift altgr
+minus 0x0c
+equal 0x0c shift
+kana_HO 0x0c altgr
+asciicircum 0x0d
+asciitilde 0x0d shift
+kana_HE 0x0d altgr
+kana_TA 0x10 altgr
+kana_TE 0x11 altgr
+kana_I 0x12 altgr
+kana_i 0x12 shift altgr
+kana_SU 0x13 altgr
+kana_KA 0x14 altgr
+kana_N 0x15 altgr
+kana_NA 0x16 altgr
+kana_NI 0x17 altgr
+kana_RA 0x18 altgr
+kana_SE 0x19 altgr
+at 0x1a
+grave 0x1a shift
+voicedsound 0x1a altgr
+bracketleft 0x1b
+braceleft 0x1b shift
+semivoicedsound 0x1b altgr
+kana_openingbracket 0x1b shift altgr
+kana_CHI 0x1e altgr
+kana_TO 0x1f altgr
+kana_SHI 0x20 altgr
+kana_HA 0x21 altgr
+kana_KI 0x22 altgr
+kana_KU 0x23 altgr
+kana_MA 0x24 altgr
+kana_NO 0x25 altgr
+kana_RI 0x26 altgr
+semicolon 0x27
+plus 0x27 shift
+kana_RE 0x27 altgr
+colon 0x28
+asterisk 0x28 shift
+kana_KE 0x28 altgr
+Zenkaku_Hankaku 0x29
+bracketright 0x2b
+braceright 0x2b shift
+kana_MU 0x2b altgr
+kana_closingbracket 0x2b shift altgr
+kana_TSU 0x2c altgr
+kana_tsu 0x2c shift altgr
+kana_SA 0x2d altgr
+kana_SO 0x2e altgr
+kana_HI 0x2f altgr
+kana_KO 0x30 altgr
+kana_MI 0x31 altgr
+kana_MO 0x32 altgr
+comma 0x33
+less 0x33 shift
+kana_NE 0x33 altgr
+kana_comma 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+kana_RU 0x34 altgr
+kana_fullstop 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+kana_ME 0x35 altgr
+kana_conjunctive 0x35 shift altgr
+Eisu_toggle 0x3a shift
+Execute 0x54 shift
+Kanji 0x70
+backslash 0x73
+yen 0x7d
+bar 0x7d shift
+underscore 0x73 shift
+Henkan_Mode 0x79
+Katakana_Real 0x70
+Katakana 0x70
+Muhenkan 0x7b
+Henkan_Mode_Real 0x79
+Henkan_Mode_Ultra 0x79
+backslash_ja 0x73
diff --git a/qemu/share/qemu/keymaps/lt b/qemu/share/qemu/keymaps/lt
new file mode 100644
index 0000000..3d9d619
--- /dev/null
+++ b/qemu/share/qemu/keymaps/lt
@@ -0,0 +1,57 @@
+# generated from XKB map lt
+include common
+map 0x427
+exclam 0x02 shift
+aogonek 0x02 altgr
+Aogonek 0x02 shift altgr
+at 0x03 shift
+ccaron 0x03 altgr
+Ccaron 0x03 shift altgr
+numbersign 0x04 shift
+eogonek 0x04 altgr
+Eogonek 0x04 shift altgr
+dollar 0x05 shift
+eabovedot 0x05 altgr
+Eabovedot 0x05 shift altgr
+percent 0x06 shift
+iogonek 0x06 altgr
+Iogonek 0x06 shift altgr
+asciicircum 0x07 shift
+scaron 0x07 altgr
+Scaron 0x07 shift altgr
+ampersand 0x08 shift
+uogonek 0x08 altgr
+Uogonek 0x08 shift altgr
+asterisk 0x09 shift
+umacron 0x09 altgr
+Umacron 0x09 shift altgr
+parenleft 0x0a shift
+doublelowquotemark 0x0a altgr
+parenright 0x0b shift
+leftdoublequotemark 0x0b altgr
+minus 0x0c
+underscore 0x0c shift
+equal 0x0d
+plus 0x0d shift
+zcaron 0x0d altgr
+Zcaron 0x0d shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+bracketright 0x1b
+braceright 0x1b shift
+semicolon 0x27
+colon 0x27 shift
+apostrophe 0x28
+quotedbl 0x28 shift
+grave 0x29
+asciitilde 0x29 shift
+backslash 0x2b
+bar 0x2b shift
+comma 0x33
+less 0x33 shift
+period 0x34
+greater 0x34 shift
+slash 0x35
+question 0x35 shift
+endash 0x56
+EuroSign 0x56 shift
diff --git a/qemu/share/qemu/keymaps/lv b/qemu/share/qemu/keymaps/lv
new file mode 100644
index 0000000..1d91727
--- /dev/null
+++ b/qemu/share/qemu/keymaps/lv
@@ -0,0 +1,128 @@
+# generated from XKB map lv
+include common
+map 0x426
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+at 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+numbersign 0x04 shift
+threesuperior 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+EuroSign 0x05 altgr
+cent 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+asciicircum 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+ampersand 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+asterisk 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenleft 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+parenright 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+minus 0x0c
+underscore 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+equal 0x0d
+plus 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+emacron 0x12 altgr
+Emacron 0x12 shift altgr
+rcedilla 0x13 altgr
+Rcedilla 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+umacron 0x16 altgr
+Umacron 0x16 shift altgr
+imacron 0x17 altgr
+Imacron 0x17 shift altgr
+omacron 0x18 altgr
+Omacron 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ISO_Next_Group 0x1c shift
+amacron 0x1e altgr
+Amacron 0x1e shift altgr
+scaron 0x1f altgr
+Scaron 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+gcedilla 0x22 altgr
+Gcedilla 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kcedilla 0x25 altgr
+Kcedilla 0x25 shift altgr
+lcedilla 0x26 altgr
+Lcedilla 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+leftdoublequotemark 0x28 altgr
+doublelowquotemark 0x28 shift altgr
+grave 0x29
+asciitilde 0x29 shift
+notsign 0x29 altgr
+backslash 0x2b
+bar 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+zcaron 0x2c altgr
+Zcaron 0x2c shift altgr
+guillemotright 0x2d altgr
+greater 0x2d shift altgr
+ccaron 0x2e altgr
+Ccaron 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+apostrophe 0x30 shift altgr
+ncedilla 0x31 altgr
+Ncedilla 0x31 shift altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
+nobreakspace 0x39 altgr
diff --git a/qemu/share/qemu/keymaps/mk b/qemu/share/qemu/keymaps/mk
new file mode 100644
index 0000000..18c1504
--- /dev/null
+++ b/qemu/share/qemu/keymaps/mk
@@ -0,0 +1,101 @@
+# generated from XKB map mk
+include common
+map 0x42f
+exclam 0x02 shift
+at 0x03 shift
+doublelowquotemark 0x03 shift altgr
+numbersign 0x04 shift
+leftdoublequotemark 0x04 shift altgr
+dollar 0x05 shift
+percent 0x06 shift
+asciicircum 0x07 shift
+ampersand 0x08 shift
+asterisk 0x09 shift
+parenleft 0x0a shift
+parenright 0x0b shift
+minus 0x0c
+underscore 0x0c shift
+equal 0x0d
+plus 0x0d shift
+Cyrillic_lje 0x10 altgr
+Cyrillic_LJE 0x10 shift altgr
+Cyrillic_nje 0x11 altgr
+Cyrillic_NJE 0x11 shift altgr
+Cyrillic_ie 0x12 altgr
+Cyrillic_IE 0x12 shift altgr
+Cyrillic_er 0x13 altgr
+Cyrillic_ER 0x13 shift altgr
+Cyrillic_te 0x14 altgr
+Cyrillic_TE 0x14 shift altgr
+Macedonia_dse 0x15 altgr
+Macedonia_DSE 0x15 shift altgr
+Cyrillic_u 0x16 altgr
+Cyrillic_U 0x16 shift altgr
+Cyrillic_i 0x17 altgr
+Cyrillic_I 0x17 shift altgr
+Cyrillic_o 0x18 altgr
+Cyrillic_O 0x18 shift altgr
+Cyrillic_pe 0x19 altgr
+Cyrillic_PE 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+Cyrillic_sha 0x1a altgr
+Cyrillic_SHA 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+Macedonia_gje 0x1b altgr
+Macedonia_GJE 0x1b shift altgr
+Cyrillic_a 0x1e altgr
+Cyrillic_A 0x1e shift altgr
+Cyrillic_es 0x1f altgr
+Cyrillic_ES 0x1f shift altgr
+Cyrillic_de 0x20 altgr
+Cyrillic_DE 0x20 shift altgr
+Cyrillic_ef 0x21 altgr
+Cyrillic_EF 0x21 shift altgr
+Cyrillic_ghe 0x22 altgr
+Cyrillic_GHE 0x22 shift altgr
+Cyrillic_ha 0x23 altgr
+Cyrillic_HA 0x23 shift altgr
+Cyrillic_je 0x24 altgr
+Cyrillic_JE 0x24 shift altgr
+Cyrillic_ka 0x25 altgr
+Cyrillic_KA 0x25 shift altgr
+Cyrillic_el 0x26 altgr
+Cyrillic_EL 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+Cyrillic_che 0x27 altgr
+Cyrillic_CHE 0x27 shift altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+Macedonia_kje 0x28 altgr
+Macedonia_KJE 0x28 shift altgr
+grave 0x29
+asciitilde 0x29 shift
+backslash 0x2b
+bar 0x2b shift
+Cyrillic_zhe 0x2b altgr
+Cyrillic_ZHE 0x2b shift altgr
+Cyrillic_ze 0x2c altgr
+Cyrillic_ZE 0x2c shift altgr
+Cyrillic_dzhe 0x2d altgr
+Cyrillic_DZHE 0x2d shift altgr
+Cyrillic_tse 0x2e altgr
+Cyrillic_TSE 0x2e shift altgr
+Cyrillic_ve 0x2f altgr
+Cyrillic_VE 0x2f shift altgr
+Cyrillic_be 0x30 altgr
+Cyrillic_BE 0x30 shift altgr
+Cyrillic_en 0x31 altgr
+Cyrillic_EN 0x31 shift altgr
+Cyrillic_em 0x32 altgr
+Cyrillic_EM 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+semicolon 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+colon 0x34 shift altgr
+slash 0x35
+question 0x35 shift
diff --git a/qemu/share/qemu/keymaps/modifiers b/qemu/share/qemu/keymaps/modifiers
new file mode 100644
index 0000000..d73b7a6
--- /dev/null
+++ b/qemu/share/qemu/keymaps/modifiers
@@ -0,0 +1,18 @@
+Shift_R 0x36
+Shift_L 0x2a
+
+Alt_R 0xb8
+Mode_switch 0xb8
+ISO_Level3_Shift 0xb8
+Alt_L 0x38
+
+Control_R 0x9d
+Control_L 0x1d
+
+# Translate Super to Windows keys.
+# This is hardcoded. See documentation for details.
+Super_R 0xdc
+Super_L 0xdb
+
+# Translate Menu to the Windows Application key.
+Menu 0xdd
diff --git a/qemu/share/qemu/keymaps/nl b/qemu/share/qemu/keymaps/nl
new file mode 100644
index 0000000..b4892f9
--- /dev/null
+++ b/qemu/share/qemu/keymaps/nl
@@ -0,0 +1,59 @@
+# Dutch (Netherlands)
+include common
+map 0x413
+
+exclam 0x02 shift
+onesuperior 0x02 altgr
+quotebl 0x03 shift
+twosuperior 0x03 altgr
+numbersign 0x04 shift
+threesuperior 0x04 altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+underscore 0x08 shift
+sterling 0x08 altgr
+parenleft 0x09 shift
+braceleft 0x09 altgr
+parenright 0x0a shift
+braceright 0x0a altgr
+apostrophe 0x0b shift
+slash 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+degree 0x0d
+dead_tilde 0x0d shift
+dead_cedilla 0x0d altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+dead_diaeresis 0x1a
+dead_circumflex 0x1a shift
+asterisk 0x1b
+bar 0x1b shift
+ssharp 0x1f altgr
+plus 0x27
+plusminus 0x27 shift
+dead_acute 0x28
+dead_grave 0x28 shift
+at 0x29
+section 0x29 shift
+notsign 0x29 altgr
+less 0x2b
+greater 0x2b shift
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+copyright 0x2e altgr
+mu 0x32 altgr
+comma 0x33
+semicolon 0x33 shift
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+hyphen 0x35
+equal 0x35 shift
+bracketright 0x56
+bracketleft 0x56 shift
+brokenbar 0x56 altgr
diff --git a/qemu/share/qemu/keymaps/nl-be b/qemu/share/qemu/keymaps/nl-be
new file mode 100644
index 0000000..34fc881
--- /dev/null
+++ b/qemu/share/qemu/keymaps/nl-be
@@ -0,0 +1,3 @@
+# Dutch (Belgium)
+map 0x813
+include common
diff --git a/qemu/share/qemu/keymaps/no b/qemu/share/qemu/keymaps/no
new file mode 100644
index 0000000..40a6479
--- /dev/null
+++ b/qemu/share/qemu/keymaps/no
@@ -0,0 +1,119 @@
+# generated from XKB map no
+include common
+map 0x414
+exclam 0x02 shift
+exclamdown 0x02 altgr
+onesuperior 0x02 shift altgr
+quotedbl 0x03 shift
+at 0x03 altgr
+twosuperior 0x03 shift altgr
+numbersign 0x04 shift
+sterling 0x04 altgr
+threesuperior 0x04 shift altgr
+currency 0x05 shift
+dollar 0x05 altgr
+onequarter 0x05 shift altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+cent 0x06 shift altgr
+ampersand 0x07 shift
+yen 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+division 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+guillemotleft 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+guillemotright 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+plus 0x0c
+question 0x0c shift
+plusminus 0x0c altgr
+questiondown 0x0c shift altgr
+backslash 0x0d
+dead_grave 0x0d shift
+dead_acute 0x0d altgr
+notsign 0x0d shift altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+registered 0x13 altgr
+thorn 0x14 altgr
+THORN 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oe 0x18 altgr
+OE 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+aring 0x1a
+Aring 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+dead_diaeresis 0x1b
+dead_circumflex 0x1b shift
+asciicircum 0x01b shift
+dead_tilde 0x1b altgr
+asciitilde 0x1b altgr
+dead_caron 0x1b shift altgr
+ordfeminine 0x1e altgr
+masculine 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+oslash 0x27
+Ooblique 0x27 shift
+dead_doubleacute 0x27 shift altgr
+ae 0x28
+AE 0x28 shift
+dead_caron 0x28 shift altgr
+bar 0x29
+section 0x29 shift
+brokenbar 0x29 altgr
+paragraph 0x29 shift altgr
+apostrophe 0x2b
+asterisk 0x2b shift
+multiply 0x2b shift altgr
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+copyright 0x2e altgr
+leftdoublequotemark 0x2f altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+dead_cedilla 0x33 altgr
+dead_ogonek 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+dead_abovedot 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+hyphen 0x35 altgr
+macron 0x35 shift altgr
+nobreakspace 0x39 altgr
+onehalf 0x56 altgr
+threequarters 0x56 shift altgr
diff --git a/qemu/share/qemu/keymaps/pl b/qemu/share/qemu/keymaps/pl
new file mode 100644
index 0000000..09c600d
--- /dev/null
+++ b/qemu/share/qemu/keymaps/pl
@@ -0,0 +1,122 @@
+# generated from XKB map pl
+include common
+map 0x415
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+at 0x03 shift
+twosuperior 0x03 altgr
+oneeighth 0x03 shift altgr
+numbersign 0x04 shift
+threesuperior 0x04 altgr
+sterling 0x04 shift altgr
+dollar 0x05 shift
+onequarter 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+asciicircum 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+ampersand 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+asterisk 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenleft 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+parenright 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+minus 0x0c
+underscore 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+equal 0x0d
+plus 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+eogonek 0x12 altgr
+Eogonek 0x12 shift altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+EuroSign 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oacute 0x18 altgr
+Oacute 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+aogonek 0x1e altgr
+Aogonek 0x1e shift altgr
+sacute 0x1f altgr
+Sacute 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+dead_circumflex 0x28 altgr
+dead_caron 0x28 shift altgr
+grave 0x29
+asciitilde 0x29 shift
+notsign 0x29 altgr
+backslash 0x2b
+bar 0x2b shift
+dead_grave 0x2b altgr
+dead_breve 0x2b shift altgr
+zabovedot 0x2c altgr
+Zabovedot 0x2c shift altgr
+zacute 0x2d altgr
+Zacute 0x2d shift altgr
+cacute 0x2e altgr
+Cacute 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+nacute 0x31 altgr
+Nacute 0x31 shift altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/pt b/qemu/share/qemu/keymaps/pt
new file mode 100644
index 0000000..c6941f6
--- /dev/null
+++ b/qemu/share/qemu/keymaps/pt
@@ -0,0 +1,113 @@
+# generated from XKB map pt
+include common
+map 0x816
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+quotedbl 0x03 shift
+at 0x03 altgr
+oneeighth 0x03 shift altgr
+numbersign 0x04 shift
+sterling 0x04 altgr
+dollar 0x05 shift
+section 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+threequarters 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+apostrophe 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+guillemotleft 0x0d
+guillemotright 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+cent 0x12 shift altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+plus 0x1a
+asterisk 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+dead_acute 0x1b
+dead_grave 0x1b shift
+dead_tilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+ccedilla 0x27
+Ccedilla 0x27 shift
+dead_doubleacute 0x27 shift altgr
+masculine 0x28
+ordfeminine 0x28 shift
+dead_circumflex 0x28 altgr
+dead_caron 0x28 shift altgr
+backslash 0x29
+bar 0x29 shift
+notsign 0x29 altgr
+dead_tilde 0x2b
+dead_circumflex 0x2b shift
+dead_breve 0x2b shift altgr
+less 0x56
+greater 0x56 shift
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+mu 0x32 altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+multiply 0x33 shift altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+division 0x34 shift altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/keymaps/pt-br b/qemu/share/qemu/keymaps/pt-br
new file mode 100644
index 0000000..54bafc5
--- /dev/null
+++ b/qemu/share/qemu/keymaps/pt-br
@@ -0,0 +1,69 @@
+# generated from XKB map br
+include common
+map 0x416
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+at 0x03 shift
+twosuperior 0x03 altgr
+onehalf 0x03 shift altgr
+numbersign 0x04 shift
+threesuperior 0x04 altgr
+threequarters 0x04 shift altgr
+dollar 0x05 shift
+sterling 0x05 altgr
+onequarter 0x05 shift altgr
+percent 0x06 shift
+cent 0x06 altgr
+dead_diaeresis 0x07 shift
+notsign 0x07 altgr
+diaeresis 0x07 shift altgr
+ampersand 0x08 shift
+braceleft 0x08 altgr
+asterisk 0x09 shift
+bracketleft 0x09 altgr
+parenleft 0x0a shift
+bracketright 0x0a altgr
+parenright 0x0b shift
+braceright 0x0b altgr
+minus 0x0c
+underscore 0x0c shift
+backslash 0x0c altgr
+equal 0x0d
+plus 0x0d shift
+section 0x0d altgr
+EuroSign 0x12 altgr
+registered 0x13 altgr
+dead_acute 0x1a
+dead_grave 0x1a shift
+acute 0x1a altgr
+grave 0x1a shift altgr
+bracketleft 0x1b
+braceleft 0x1b shift
+ordfeminine 0x1b altgr
+ccedilla 0x27
+Ccedilla 0x27 shift
+dead_tilde 0x28
+dead_circumflex 0x28 shift
+asciitilde 0x28 altgr
+asciicircum 0x28 shift altgr
+apostrophe 0x29
+quotedbl 0x29 shift
+bracketright 0x2b
+braceright 0x2b shift
+masculine 0x2b altgr
+copyright 0x2e altgr
+mu 0x32 altgr
+comma 0x33
+less 0x33 shift
+period 0x34
+greater 0x34 shift
+semicolon 0x35
+colon 0x35 shift
+comma 0x53 numlock
+backslash 0x56
+bar 0x56 shift
+slash 0x73
+question 0x73 shift
+degree 0x73 altgr
+KP_Decimal 0x34
diff --git a/qemu/share/qemu/keymaps/ru b/qemu/share/qemu/keymaps/ru
new file mode 100644
index 0000000..8f652d5
--- /dev/null
+++ b/qemu/share/qemu/keymaps/ru
@@ -0,0 +1,109 @@
+# generated from XKB map ru
+include common
+map 0x419
+exclam 0x02 shift
+at 0x03 shift
+quotedbl 0x03 shift altgr
+numerosign 0x04 shift
+dollar 0x05 shift
+asterisk 0x05 shift altgr
+percent 0x06 shift
+colon 0x06 shift altgr
+asciicircum 0x07 shift
+comma 0x07 shift altgr
+ampersand 0x08 shift
+period 0x08 shift altgr
+asterisk 0x09 shift
+semicolon 0x09 shift altgr
+parenleft 0x0a shift
+parenright 0x0b shift
+minus 0x0c
+underscore 0x0c shift
+equal 0x0d
+plus 0x0d shift
+Cyrillic_shorti 0x10 altgr
+Cyrillic_SHORTI 0x10 shift altgr
+Cyrillic_tse 0x11 altgr
+Cyrillic_TSE 0x11 shift altgr
+Cyrillic_u 0x12 altgr
+Cyrillic_U 0x12 shift altgr
+Cyrillic_ka 0x13 altgr
+Cyrillic_KA 0x13 shift altgr
+Cyrillic_ie 0x14 altgr
+Cyrillic_IE 0x14 shift altgr
+Cyrillic_en 0x15 altgr
+Cyrillic_EN 0x15 shift altgr
+Cyrillic_ghe 0x16 altgr
+Cyrillic_GHE 0x16 shift altgr
+Cyrillic_sha 0x17 altgr
+Cyrillic_SHA 0x17 shift altgr
+Cyrillic_shcha 0x18 altgr
+Cyrillic_SHCHA 0x18 shift altgr
+Cyrillic_ze 0x19 altgr
+Cyrillic_ZE 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+Cyrillic_ha 0x1a altgr
+Cyrillic_HA 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+Cyrillic_hardsign 0x1b altgr
+Cyrillic_HARDSIGN 0x1b shift altgr
+Cyrillic_ef 0x1e altgr
+Cyrillic_EF 0x1e shift altgr
+Cyrillic_yeru 0x1f altgr
+Cyrillic_YERU 0x1f shift altgr
+Cyrillic_ve 0x20 altgr
+Cyrillic_VE 0x20 shift altgr
+Cyrillic_a 0x21 altgr
+Cyrillic_A 0x21 shift altgr
+Cyrillic_pe 0x22 altgr
+Cyrillic_PE 0x22 shift altgr
+Cyrillic_er 0x23 altgr
+Cyrillic_ER 0x23 shift altgr
+Cyrillic_o 0x24 altgr
+Cyrillic_O 0x24 shift altgr
+Cyrillic_el 0x25 altgr
+Cyrillic_EL 0x25 shift altgr
+Cyrillic_de 0x26 altgr
+Cyrillic_DE 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+Cyrillic_zhe 0x27 altgr
+Cyrillic_ZHE 0x27 shift altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+Cyrillic_e 0x28 altgr
+Cyrillic_E 0x28 shift altgr
+grave 0x29
+asciitilde 0x29 shift
+Cyrillic_io 0x29 altgr
+Cyrillic_IO 0x29 shift altgr
+backslash 0x2b
+bar 0x2b shift
+Cyrillic_ya 0x2c altgr
+Cyrillic_YA 0x2c shift altgr
+Cyrillic_che 0x2d altgr
+Cyrillic_CHE 0x2d shift altgr
+Cyrillic_es 0x2e altgr
+Cyrillic_ES 0x2e shift altgr
+Cyrillic_em 0x2f altgr
+Cyrillic_EM 0x2f shift altgr
+Cyrillic_i 0x30 altgr
+Cyrillic_I 0x30 shift altgr
+Cyrillic_te 0x31 altgr
+Cyrillic_TE 0x31 shift altgr
+Cyrillic_softsign 0x32 altgr
+Cyrillic_SOFTSIGN 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+Cyrillic_be 0x33 altgr
+Cyrillic_BE 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+Cyrillic_yu 0x34 altgr
+Cyrillic_YU 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+slash 0x56 altgr
+bar 0x56 shift altgr
diff --git a/qemu/share/qemu/keymaps/sl b/qemu/share/qemu/keymaps/sl
new file mode 100644
index 0000000..56835a9
--- /dev/null
+++ b/qemu/share/qemu/keymaps/sl
@@ -0,0 +1,110 @@
+# generated from XKB map sl
+include common
+map 0x424
+exclam 0x02 shift
+asciitilde 0x02 altgr
+dead_tilde 0x02 shift altgr
+quotedbl 0x03 shift
+dead_caron 0x03 altgr
+caron 0x03 shift altgr
+numbersign 0x04 shift
+asciicircum 0x04 altgr
+dead_circumflex 0x04 shift altgr
+dollar 0x05 shift
+dead_breve 0x05 altgr
+breve 0x05 shift altgr
+percent 0x06 shift
+degree 0x06 altgr
+dead_abovering 0x06 shift altgr
+ampersand 0x07 shift
+dead_ogonek 0x07 altgr
+ogonek 0x07 shift altgr
+slash 0x08 shift
+grave 0x08 altgr
+dead_grave 0x08 shift altgr
+parenleft 0x09 shift
+dead_abovedot 0x09 altgr
+abovedot 0x09 shift altgr
+parenright 0x0a shift
+dead_acute 0x0a altgr
+equal 0x0b shift
+dead_doubleacute 0x0b altgr
+doubleacute 0x0b shift altgr
+apostrophe 0x0c
+question 0x0c shift
+dead_diaeresis 0x0c altgr
+diaeresis 0x0c shift altgr
+plus 0x0d
+asterisk 0x0d shift
+dead_cedilla 0x0d altgr
+cedilla 0x0d shift altgr
+backslash 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+bar 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+z 0x15 addupper
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+rightarrow 0x17 altgr
+idotless 0x17 shift altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+scaron 0x1a
+Scaron 0x1a shift
+division 0x1a altgr
+dstroke 0x1b
+Dstroke 0x1b shift
+multiply 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+bracketleft 0x21 altgr
+ordfeminine 0x21 shift altgr
+bracketright 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+lstroke 0x25 altgr
+Lstroke 0x26 altgr
+ccaron 0x27
+Ccaron 0x27 shift
+cacute 0x28
+Cacute 0x28 shift
+ssharp 0x28 altgr
+dead_cedilla 0x29
+notsign 0x29 altgr
+zcaron 0x2b
+Zcaron 0x2b shift
+currency 0x2b altgr
+y 0x2c addupper
+guillemotleft 0x2c altgr
+guillemotright 0x2d altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+at 0x2f altgr
+braceleft 0x30 altgr
+braceright 0x31 altgr
+section 0x32 altgr
+masculine 0x32 shift altgr
+comma 0x33
+semicolon 0x33 shift
+horizconnector 0x33 altgr
+period 0x34
+colon 0x34 shift
+periodcentered 0x34 altgr
+minus 0x35
+underscore 0x35 shift
+dead_belowdot 0x35 altgr
diff --git a/qemu/share/qemu/keymaps/sv b/qemu/share/qemu/keymaps/sv
new file mode 100644
index 0000000..5d9080e
--- /dev/null
+++ b/qemu/share/qemu/keymaps/sv
@@ -0,0 +1,81 @@
+map 0x0000041d
+include common
+
+#
+# Top row
+#
+section 0x29
+onehalf 0x29 shift
+
+# 1
+exclam 0x2 shift
+
+# 2
+quotedbl 0x3 shift
+at 0x3 altgr
+
+# 3
+numbersign 0x4 shift
+sterling 0x4 altgr
+# 4
+currency 0x5 shift
+dollar 0x5 altgr
+# 5
+percent 0x6 shift
+# 6
+ampersand 0x7 shift
+# 7
+slash 0x8 shift
+braceleft 0x8 altgr
+# 8
+parenleft 0x9 shift
+bracketleft 0x9 altgr
+# 9
+parenright 0xa shift
+bracketright 0xa altgr
+# 0
+equal 0xb shift
+braceright 0xb altgr
+
+plus 0xc
+question 0xc shift
+backslash 0xc altgr
+
+acute 0xd
+dead_acute 0xd
+grave 0xd shift
+dead_grave 0xd shift
+
+#
+# QWERTY first row
+#
+EuroSign 0x12 altgr
+aring 0x1a
+Aring 0x1a shift
+dead_diaeresis 0x1b
+dead_circumflex 0x1b shift
+dead_tilde 0x1b altgr
+
+#
+# QWERTY second row
+#
+odiaeresis 0x27
+Odiaeresis 0x27 shift
+adiaeresis 0x28
+Adiaeresis 0x28 shift
+apostrophe 0x2b
+asterisk 0x2b shift
+
+#
+# QWERTY third row
+#
+less 0x56
+greater 0x56 shift
+bar 0x56 altgr
+mu 0x32 altgr
+comma 0x33
+semicolon 0x33 shift
+period 0x34
+colon 0x34 shift
+minus 0x35
+underscore 0x35 shift
diff --git a/qemu/share/qemu/keymaps/th b/qemu/share/qemu/keymaps/th
new file mode 100644
index 0000000..b65b6da
--- /dev/null
+++ b/qemu/share/qemu/keymaps/th
@@ -0,0 +1,131 @@
+# generated from XKB map th
+include common
+map 0x41e
+exclam 0x02 shift
+Thai_lakkhangyao 0x02 altgr
+plus 0x02 shift altgr
+at 0x03 shift
+slash 0x03 altgr
+Thai_leknung 0x03 shift altgr
+numbersign 0x04 shift
+minus 0x04 altgr
+Thai_leksong 0x04 shift altgr
+dollar 0x05 shift
+Thai_phosamphao 0x05 altgr
+Thai_leksam 0x05 shift altgr
+percent 0x06 shift
+Thai_thothung 0x06 altgr
+Thai_leksi 0x06 shift altgr
+asciicircum 0x07 shift
+Thai_sarau 0x07 altgr
+Thai_sarauu 0x07 shift altgr
+ampersand 0x08 shift
+Thai_saraue 0x08 altgr
+Thai_baht 0x08 shift altgr
+asterisk 0x09 shift
+Thai_khokhwai 0x09 altgr
+Thai_lekha 0x09 shift altgr
+parenleft 0x0a shift
+Thai_totao 0x0a altgr
+Thai_lekhok 0x0a shift altgr
+parenright 0x0b shift
+Thai_chochan 0x0b altgr
+Thai_lekchet 0x0b shift altgr
+minus 0x0c
+underscore 0x0c shift
+Thai_khokhai 0x0c altgr
+Thai_lekpaet 0x0c shift altgr
+equal 0x0d
+plus 0x0d shift
+Thai_chochang 0x0d altgr
+Thai_lekkao 0x0d shift altgr
+Thai_maiyamok 0x10 altgr
+Thai_leksun 0x10 shift altgr
+Thai_saraaimaimalai 0x11 altgr
+quotedbl 0x11 shift altgr
+Thai_saraam 0x12 altgr
+Thai_dochada 0x12 shift altgr
+Thai_phophan 0x13 altgr
+Thai_thonangmontho 0x13 shift altgr
+Thai_saraa 0x14 altgr
+Thai_thothong 0x14 shift altgr
+Thai_maihanakat 0x15 altgr
+Thai_nikhahit 0x15 shift altgr
+Thai_saraii 0x16 altgr
+Thai_maitri 0x16 shift altgr
+Thai_rorua 0x17 altgr
+Thai_nonen 0x17 shift altgr
+Thai_nonu 0x18 altgr
+Thai_paiyannoi 0x18 shift altgr
+Thai_yoyak 0x19 altgr
+Thai_yoying 0x19 shift altgr
+bracketleft 0x1a
+braceleft 0x1a shift
+Thai_bobaimai 0x1a altgr
+Thai_thothan 0x1a shift altgr
+bracketright 0x1b
+braceright 0x1b shift
+Thai_loling 0x1b altgr
+comma 0x1b shift altgr
+Thai_fofan 0x1e altgr
+Thai_ru 0x1e shift altgr
+Thai_hohip 0x1f altgr
+Thai_khorakhang 0x1f shift altgr
+Thai_kokai 0x20 altgr
+Thai_topatak 0x20 shift altgr
+Thai_dodek 0x21 altgr
+Thai_sarao 0x21 shift altgr
+Thai_sarae 0x22 altgr
+Thai_chochoe 0x22 shift altgr
+Thai_maitho 0x23 altgr
+Thai_maitaikhu 0x23 shift altgr
+Thai_maiek 0x24 altgr
+Thai_maichattawa 0x24 shift altgr
+Thai_saraaa 0x25 altgr
+Thai_sorusi 0x25 shift altgr
+Thai_sosua 0x26 altgr
+Thai_sosala 0x26 shift altgr
+semicolon 0x27
+colon 0x27 shift
+Thai_wowaen 0x27 altgr
+Thai_soso 0x27 shift altgr
+apostrophe 0x28
+quotedbl 0x28 shift
+Thai_ngongu 0x28 altgr
+period 0x28 shift altgr
+grave 0x29
+asciitilde 0x29 shift
+underscore 0x29 altgr
+percent 0x29 shift altgr
+ISO_First_Group 0x2a shift
+backslash 0x2b
+bar 0x2b shift
+Thai_khokhuat 0x2b altgr
+Thai_khokhon 0x2b shift altgr
+Thai_phophung 0x2c altgr
+parenleft 0x2c shift altgr
+Thai_popla 0x2d altgr
+parenright 0x2d shift altgr
+Thai_saraae 0x2e altgr
+Thai_choching 0x2e shift altgr
+Thai_oang 0x2f altgr
+Thai_honokhuk 0x2f shift altgr
+Thai_sarai 0x30 altgr
+Thai_phinthu 0x30 shift altgr
+Thai_sarauee 0x31 altgr
+Thai_thanthakhat 0x31 shift altgr
+Thai_thothahan 0x32 altgr
+question 0x32 shift altgr
+comma 0x33
+less 0x33 shift
+Thai_moma 0x33 altgr
+Thai_thophuthao 0x33 shift altgr
+period 0x34
+greater 0x34 shift
+Thai_saraaimaimuan 0x34 altgr
+Thai_lochula 0x34 shift altgr
+slash 0x35
+question 0x35 shift
+Thai_fofa 0x35 altgr
+Thai_lu 0x35 shift altgr
+ISO_Last_Group 0x36 shift
diff --git a/qemu/share/qemu/keymaps/tr b/qemu/share/qemu/keymaps/tr
new file mode 100644
index 0000000..5650e1e
--- /dev/null
+++ b/qemu/share/qemu/keymaps/tr
@@ -0,0 +1,123 @@
+# generated from XKB map tr
+include common
+map 0x41f
+exclam 0x02 shift
+onesuperior 0x02 altgr
+exclamdown 0x02 shift altgr
+apostrophe 0x03 shift
+at 0x03 altgr
+oneeighth 0x03 shift altgr
+dead_circumflex 0x04 shift
+numbersign 0x04 altgr
+sterling 0x04 shift altgr
+plus 0x05 shift
+dollar 0x05 altgr
+percent 0x06 shift
+onehalf 0x06 altgr
+threeeighths 0x06 shift altgr
+ampersand 0x07 shift
+asciicircum 0x07 altgr
+fiveeighths 0x07 shift altgr
+slash 0x08 shift
+braceleft 0x08 altgr
+seveneighths 0x08 shift altgr
+parenleft 0x09 shift
+bracketleft 0x09 altgr
+trademark 0x09 shift altgr
+parenright 0x0a shift
+bracketright 0x0a altgr
+plusminus 0x0a shift altgr
+equal 0x0b shift
+braceright 0x0b altgr
+degree 0x0b shift altgr
+asterisk 0x0c
+question 0x0c shift
+backslash 0x0c altgr
+questiondown 0x0c shift altgr
+minus 0x0d
+underscore 0x0d shift
+dead_cedilla 0x0d altgr
+dead_ogonek 0x0d shift altgr
+at 0x10 altgr
+Greek_OMEGA 0x10 shift altgr
+lstroke 0x11 altgr
+Lstroke 0x11 shift altgr
+EuroSign 0x12 altgr
+paragraph 0x13 altgr
+registered 0x13 shift altgr
+tslash 0x14 altgr
+Tslash 0x14 shift altgr
+leftarrow 0x15 altgr
+yen 0x15 shift altgr
+downarrow 0x16 altgr
+uparrow 0x16 shift altgr
+idotless 0x17
+I 0x17 shift
+rightarrow 0x17 altgr
+oslash 0x18 altgr
+Ooblique 0x18 shift altgr
+thorn 0x19 altgr
+THORN 0x19 shift altgr
+gbreve 0x1a
+Gbreve 0x1a shift
+dead_diaeresis 0x1a altgr
+dead_abovering 0x1a shift altgr
+udiaeresis 0x1b
+Udiaeresis 0x1b shift
+asciitilde 0x1b altgr
+dead_macron 0x1b shift altgr
+ae 0x1e altgr
+AE 0x1e shift altgr
+ssharp 0x1f altgr
+section 0x1f shift altgr
+eth 0x20 altgr
+ETH 0x20 shift altgr
+dstroke 0x21 altgr
+ordfeminine 0x21 shift altgr
+eng 0x22 altgr
+ENG 0x22 shift altgr
+hstroke 0x23 altgr
+Hstroke 0x23 shift altgr
+kra 0x25 altgr
+ampersand 0x25 shift altgr
+lstroke 0x26 altgr
+Lstroke 0x26 shift altgr
+scedilla 0x27
+Scedilla 0x27 shift
+dead_acute 0x27 altgr
+dead_doubleacute 0x27 shift altgr
+i 0x28
+Iabovedot 0x28 shift
+dead_circumflex 0x28 altgr
+dead_caron 0x28 shift altgr
+backslash 0x29
+quotedbl 0x29 shift
+asciitilde 0x29 altgr
+comma 0x2b
+semicolon 0x2b shift
+bar 0x2b altgr
+dead_breve 0x2b shift altgr
+guillemotleft 0x2c altgr
+less 0x2c shift altgr
+guillemotright 0x2d altgr
+greater 0x2d shift altgr
+cent 0x2e altgr
+copyright 0x2e shift altgr
+leftdoublequotemark 0x2f altgr
+grave 0x2f shift altgr
+rightdoublequotemark 0x30 altgr
+apostrophe 0x30 shift altgr
+mu 0x32 altgr
+masculine 0x32 shift altgr
+odiaeresis 0x33
+Odiaeresis 0x33 shift
+less 0x33 altgr
+multiply 0x33 shift altgr
+ccedilla 0x34
+Ccedilla 0x34 shift
+greater 0x34 altgr
+division 0x34 shift altgr
+period 0x35
+colon 0x35 shift
+dead_belowdot 0x35 altgr
+dead_abovedot 0x35 shift altgr
diff --git a/qemu/share/qemu/kvmvapic.bin b/qemu/share/qemu/kvmvapic.bin
new file mode 100644
index 0000000..045f5c2
Binary files /dev/null and b/qemu/share/qemu/kvmvapic.bin differ
diff --git a/qemu/share/qemu/linuxboot.bin b/qemu/share/qemu/linuxboot.bin
new file mode 100644
index 0000000..923d179
Binary files /dev/null and b/qemu/share/qemu/linuxboot.bin differ
diff --git a/qemu/share/qemu/multiboot.bin b/qemu/share/qemu/multiboot.bin
new file mode 100644
index 0000000..e772713
Binary files /dev/null and b/qemu/share/qemu/multiboot.bin differ
diff --git a/qemu/share/qemu/openbios-ppc b/qemu/share/qemu/openbios-ppc
new file mode 100644
index 0000000..d83347a
Binary files /dev/null and b/qemu/share/qemu/openbios-ppc differ
diff --git a/qemu/share/qemu/openbios-sparc32 b/qemu/share/qemu/openbios-sparc32
new file mode 100644
index 0000000..e2bc9aa
Binary files /dev/null and b/qemu/share/qemu/openbios-sparc32 differ
diff --git a/qemu/share/qemu/openbios-sparc64 b/qemu/share/qemu/openbios-sparc64
new file mode 100644
index 0000000..7a0cdbe
Binary files /dev/null and b/qemu/share/qemu/openbios-sparc64 differ
diff --git a/qemu/share/qemu/palcode-clipper b/qemu/share/qemu/palcode-clipper
new file mode 100644
index 0000000..9956340
Binary files /dev/null and b/qemu/share/qemu/palcode-clipper differ
diff --git a/qemu/share/qemu/petalogix-ml605.dtb b/qemu/share/qemu/petalogix-ml605.dtb
new file mode 100644
index 0000000..fbbd45f
Binary files /dev/null and b/qemu/share/qemu/petalogix-ml605.dtb differ
diff --git a/qemu/share/qemu/petalogix-s3adsp1800.dtb b/qemu/share/qemu/petalogix-s3adsp1800.dtb
new file mode 100644
index 0000000..8ac80f2
Binary files /dev/null and b/qemu/share/qemu/petalogix-s3adsp1800.dtb differ
diff --git a/qemu/share/qemu/ppc_rom.bin b/qemu/share/qemu/ppc_rom.bin
new file mode 100644
index 0000000..174a247
Binary files /dev/null and b/qemu/share/qemu/ppc_rom.bin differ
diff --git a/qemu/share/qemu/pxe-e1000.rom b/qemu/share/qemu/pxe-e1000.rom
new file mode 100644
index 0000000..2e5f8b2
Binary files /dev/null and b/qemu/share/qemu/pxe-e1000.rom differ
diff --git a/qemu/share/qemu/pxe-eepro100.rom b/qemu/share/qemu/pxe-eepro100.rom
new file mode 100644
index 0000000..d292e8f
Binary files /dev/null and b/qemu/share/qemu/pxe-eepro100.rom differ
diff --git a/qemu/share/qemu/pxe-ne2k_pci.rom b/qemu/share/qemu/pxe-ne2k_pci.rom
new file mode 100644
index 0000000..62010cb
Binary files /dev/null and b/qemu/share/qemu/pxe-ne2k_pci.rom differ
diff --git a/qemu/share/qemu/pxe-pcnet.rom b/qemu/share/qemu/pxe-pcnet.rom
new file mode 100644
index 0000000..512d6d4
Binary files /dev/null and b/qemu/share/qemu/pxe-pcnet.rom differ
diff --git a/qemu/share/qemu/pxe-rtl8139.rom b/qemu/share/qemu/pxe-rtl8139.rom
new file mode 100644
index 0000000..67c77fb
Binary files /dev/null and b/qemu/share/qemu/pxe-rtl8139.rom differ
diff --git a/qemu/share/qemu/pxe-virtio.rom b/qemu/share/qemu/pxe-virtio.rom
new file mode 100644
index 0000000..b1ec909
Binary files /dev/null and b/qemu/share/qemu/pxe-virtio.rom differ
diff --git a/qemu/share/qemu/q35-acpi-dsdt.aml b/qemu/share/qemu/q35-acpi-dsdt.aml
new file mode 100644
index 0000000..d71b3a3
Binary files /dev/null and b/qemu/share/qemu/q35-acpi-dsdt.aml differ
diff --git a/qemu/share/qemu/qemu-icon.bmp b/qemu/share/qemu/qemu-icon.bmp
new file mode 100644
index 0000000..72d9a2f
Binary files /dev/null and b/qemu/share/qemu/qemu-icon.bmp differ
diff --git a/qemu/share/qemu/qemu_logo_no_text.svg b/qemu/share/qemu/qemu_logo_no_text.svg
new file mode 100644
index 0000000..24ca23a
--- /dev/null
+++ b/qemu/share/qemu/qemu_logo_no_text.svg
@@ -0,0 +1,976 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="111.71874"
+   height="111.12498"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.2 r9819"
+   sodipodi:docname="qemu_logo_no_text.svg">
+  <defs
+     id="defs4">
+    <linearGradient
+       id="linearGradient4686">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4688" />
+      <stop
+         id="stop3956"
+         offset="0.75"
+         style="stop-color:#000000;stop-opacity:0.87843138;" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.43921569;"
+         offset="0.75"
+         id="stop3958" />
+      <stop
+         id="stop3960"
+         offset="0.88"
+         style="stop-color:#181818;stop-opacity:1;" />
+      <stop
+         style="stop-color:#242424;stop-opacity:1;"
+         offset="0.88"
+         id="stop3962" />
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="1"
+         id="stop4690" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4467">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4469" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0.8974359;"
+         offset="1"
+         id="stop4471" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4431">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4433" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4435" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4466">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4468" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4470" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4321">
+      <stop
+         style="stop-color:#ff6702;stop-opacity:1;"
+         offset="0"
+         id="stop4323" />
+      <stop
+         style="stop-color:#ff9a55;stop-opacity:1;"
+         offset="1"
+         id="stop4325" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4283">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4285" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4287" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4251">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4253" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4255" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4007">
+      <stop
+         style="stop-color:#ff6600;stop-opacity:1;"
+         offset="0"
+         id="stop4009" />
+      <stop
+         style="stop-color:#ff9148;stop-opacity:1;"
+         offset="1"
+         id="stop4011" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3999">
+      <stop
+         style="stop-color:#fff7f2;stop-opacity:1;"
+         offset="0"
+         id="stop4001" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4003" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3890">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop3892" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3894" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3880">
+      <stop
+         style="stop-color:#eb7400;stop-opacity:1;"
+         offset="0"
+         id="stop3882" />
+      <stop
+         style="stop-color:#f7b06a;stop-opacity:1;"
+         offset="1"
+         id="stop3884" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4011">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3879">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.90598291;"
+         offset="0"
+         id="stop3881" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3869">
+      <stop
+         style="stop-color:#c95000;stop-opacity:1;"
+         offset="0"
+         id="stop3871" />
+      <stop
+         style="stop-color:#ff9e5e;stop-opacity:1;"
+         offset="1"
+         id="stop3873" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3861">
+      <stop
+         style="stop-color:#f06000;stop-opacity:1;"
+         offset="0"
+         id="stop3863" />
+      <stop
+         style="stop-color:#ffccaa;stop-opacity:1;"
+         offset="1"
+         id="stop3865" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3826">
+      <stop
+         style="stop-color:#ff6600;stop-opacity:1;"
+         offset="0"
+         id="stop3828" />
+      <stop
+         style="stop-color:#ff893b;stop-opacity:1;"
+         offset="1"
+         id="stop3830" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3879-6">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.90598291;"
+         offset="0"
+         id="stop3881-4" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-7" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3869-5">
+      <stop
+         style="stop-color:#c95000;stop-opacity:1;"
+         offset="0"
+         id="stop3871-9" />
+      <stop
+         style="stop-color:#ff9e5e;stop-opacity:1;"
+         offset="1"
+         id="stop3873-4" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4"
+       id="linearGradient3885-6"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3869-2">
+      <stop
+         style="stop-color:#c95000;stop-opacity:1;"
+         offset="0"
+         id="stop3871-99" />
+      <stop
+         style="stop-color:#ff9e5e;stop-opacity:1;"
+         offset="1"
+         id="stop3873-6" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011"
+       id="radialGradient4017"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.23244854,1.600893,-1.0124495,0.14700695,145.40424,-26.300303)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4-7"
+       id="linearGradient3885-6-2"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4-7">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-5"
+       id="radialGradient4017-7"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.99779178,6.8718773,-4.3459674,0.6310314,452.75975,-225.98471)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4011-5">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4-75"
+       id="linearGradient3885-6-8"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4-75">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-1" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-4" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-0"
+       id="radialGradient4017-5"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.23244854,1.600893,-1.0124495,0.14700695,146.34996,53.681728)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4011-0">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013-4" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-0" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-0"
+       id="linearGradient4117"
+       x1="107.03001"
+       y1="189.72537"
+       x2="107.18476"
+       y2="173.47537"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4-7-2"
+       id="linearGradient3885-6-2-8"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4-7-2">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7-9" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6-9" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-5-1"
+       id="radialGradient4017-7-9"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.99779178,6.8718773,-4.3459674,0.6310314,448.94742,-406.99277)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4011-5-1">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1-9" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3-8" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4-7-2-7"
+       id="linearGradient3885-6-2-8-0"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4-7-2-7">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7-9-3" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6-9-6" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-5-1-5"
+       id="radialGradient4017-7-9-5"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.55965334,3.8543806,-2.4376181,0.3539404,454.75182,-145.44353)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4011-5-1-5">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1-9-6" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3-8-9" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3879-4-7-2-4"
+       id="linearGradient3885-6-2-8-4"
+       x1="76.025352"
+       y1="124.8497"
+       x2="75.874107"
+       y2="143.03978"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient3879-4-7-2-4">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7-9-9" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6-9-3" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4011-5-1-7"
+       id="radialGradient4017-7-9-7"
+       cx="66.639"
+       cy="93.096375"
+       fx="66.639"
+       fy="93.096375"
+       r="11.515625"
+       gradientTransform="matrix(0.26837158,1.8482981,-1.1689154,0.16972569,466.57614,26.180822)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4011-5-1-7">
+      <stop
+         style="stop-color:#042dc8;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1-9-1" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3-8-5" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3879-4-7-2-0">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7-9-7" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6-9-8" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4011-5-1-55">
+      <stop
+         style="stop-color:#000a30;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1-9-8" />
+      <stop
+         style="stop-color:#4260d5;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3-8-3" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3890-9">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop3892-0" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3894-9" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3880-4">
+      <stop
+         style="stop-color:#eb7400;stop-opacity:1;"
+         offset="0"
+         id="stop3882-5" />
+      <stop
+         style="stop-color:#f7b06a;stop-opacity:1;"
+         offset="1"
+         id="stop3884-1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3999-7">
+      <stop
+         style="stop-color:#fff7f2;stop-opacity:1;"
+         offset="0"
+         id="stop4001-9" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4003-4" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4007-9">
+      <stop
+         style="stop-color:#ff6600;stop-opacity:1;"
+         offset="0"
+         id="stop4009-1" />
+      <stop
+         style="stop-color:#ff9148;stop-opacity:1;"
+         offset="1"
+         id="stop4011-9" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4007-9-5">
+      <stop
+         style="stop-color:#ff6600;stop-opacity:1;"
+         offset="0"
+         id="stop4009-1-9" />
+      <stop
+         style="stop-color:#ff9148;stop-opacity:1;"
+         offset="1"
+         id="stop4011-9-5" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3999-7-1">
+      <stop
+         style="stop-color:#fff7f2;stop-opacity:1;"
+         offset="0"
+         id="stop4001-9-1" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4003-4-4" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4007-9-5-3">
+      <stop
+         style="stop-color:#ff6600;stop-opacity:1;"
+         offset="0"
+         id="stop4009-1-9-3" />
+      <stop
+         style="stop-color:#ff9148;stop-opacity:1;"
+         offset="1"
+         id="stop4011-9-5-9" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3999-7-1-4">
+      <stop
+         style="stop-color:#fff7f2;stop-opacity:1;"
+         offset="0"
+         id="stop4001-9-1-4" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4003-4-4-4" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3879-4-7-2-3">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.93162394;"
+         offset="0"
+         id="stop3881-6-7-9-1" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop3883-74-6-9-87" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4011-5-1-1">
+      <stop
+         style="stop-color:#fde8a1;stop-opacity:1;"
+         offset="0"
+         id="stop4013-1-9-63" />
+      <stop
+         style="stop-color:#2947b9;stop-opacity:1;"
+         offset="1"
+         id="stop4015-3-8-8" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4466"
+       id="linearGradient4472"
+       x1="161.7561"
+       y1="540.72662"
+       x2="161.7561"
+       y2="579.80206"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4321"
+       id="radialGradient4474"
+       cx="130.8242"
+       cy="575.27838"
+       fx="130.8242"
+       fy="575.27838"
+       r="49.498173"
+       gradientTransform="matrix(0.95670828,0.96684666,-0.72623533,0.71862001,423.45109,35.05138)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4466-5"
+       id="linearGradient4472-9"
+       x1="161.7561"
+       y1="540.72662"
+       x2="161.7561"
+       y2="579.80206"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4466-5">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4468-2" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4470-3" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4321-0"
+       id="radialGradient4474-6"
+       cx="130.8242"
+       cy="575.27838"
+       fx="130.8242"
+       fy="575.27838"
+       r="49.498173"
+       gradientTransform="matrix(0.95670828,0.96684666,-0.72623533,0.71862001,442.64399,170.9169)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4321-0">
+      <stop
+         style="stop-color:#ff6702;stop-opacity:1;"
+         offset="0"
+         id="stop4323-3" />
+      <stop
+         style="stop-color:#ff9a55;stop-opacity:1;"
+         offset="1"
+         id="stop4325-1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4466-5-5">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4468-2-9" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4470-3-4" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4321-0-0">
+      <stop
+         style="stop-color:#ff6702;stop-opacity:1;"
+         offset="0"
+         id="stop4323-3-9" />
+      <stop
+         style="stop-color:#ff9a55;stop-opacity:1;"
+         offset="1"
+         id="stop4325-1-1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4466-5-9">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4468-2-7" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4470-3-7" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4321-0-7">
+      <stop
+         style="stop-color:#ff6702;stop-opacity:1;"
+         offset="0"
+         id="stop4323-3-3" />
+      <stop
+         style="stop-color:#ff9a55;stop-opacity:1;"
+         offset="1"
+         id="stop4325-1-6" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4431"
+       id="linearGradient4437"
+       x1="142.81854"
+       y1="831.52283"
+       x2="142.81854"
+       y2="878.90735"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4467"
+       id="radialGradient4475"
+       cx="116.51958"
+       cy="98.282051"
+       fx="116.51958"
+       fy="98.282051"
+       r="55.859375"
+       gradientTransform="matrix(0.97442557,1.5088911,-0.83559154,0.53961599,79.641615,-130.28522)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4431-3"
+       id="linearGradient4437-6"
+       x1="142.81854"
+       y1="831.52283"
+       x2="142.81854"
+       y2="878.90735"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4431-3">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4433-0" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4435-2" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4467-7"
+       id="radialGradient4475-0"
+       cx="116.51958"
+       cy="98.282051"
+       fx="116.51958"
+       fy="98.282051"
+       r="55.859375"
+       gradientTransform="matrix(0.97442557,1.5088911,-0.83559154,0.53961599,225.10358,63.664066)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       id="linearGradient4467-7">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4469-4" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0.8974359;"
+         offset="1"
+         id="stop4471-7" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4467"
+       id="radialGradient3262"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.97442557,1.5088911,-0.83559154,0.53961599,59.641615,-150.28522)"
+       cx="116.51958"
+       cy="98.282051"
+       fx="116.51958"
+       fy="98.282051"
+       r="55.859375" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4431"
+       id="linearGradient3264"
+       gradientUnits="userSpaceOnUse"
+       x1="142.81854"
+       y1="831.52283"
+       x2="142.81854"
+       y2="878.90735" />
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="5.6"
+     inkscape:cx="31.144191"
+     inkscape:cy="38.335716"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     showguides="false"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1056"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1"
+     fit-margin-top="0"
+     fit-margin-right="0"
+     fit-margin-bottom="0"
+     fit-margin-left="0">
+    <sodipodi:guide
+       orientation="0,1"
+       position="72.563745,37.346999"
+       id="guide2989" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="74.584055,7.2949693"
+       id="guide2991" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="71.048515,20.426949"
+       id="guide2993" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="97.817565,20.174409"
+       id="guide2995" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="71.048515,20.426949"
+       id="guide3017" />
+    <inkscape:grid
+       type="xygrid"
+       id="grid3019"
+       empspacing="5"
+       visible="true"
+       enabled="true"
+       snapvisiblegridlinesonly="true" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="105.6589,-12.377861"
+       id="guide3021" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="126.6589,-16.377861"
+       id="guide3023" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="110.6589,-3.3778607"
+       id="guide3025" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="110.6589,-27.377861"
+       id="guide3027" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="19.658895,-35.37786"
+       id="guide3810" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="21.658895,-70.377861"
+       id="guide3814" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="2.301752,-9.4850007"
+       id="guide3856" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="26.601806,-9.4850007"
+       id="guide3887" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="44.658283,37.346999"
+       id="guide4019" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="126.6589,-27.377861"
+       id="guide4481" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="159.08747,-213.94929"
+       id="guide4483" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(-42.341105,-35.859333)">
+    <path
+       inkscape:connector-curvature="0"
+       style="fill:url(#radialGradient3262);fill-opacity:1;stroke:none"
+       d="m 98.2161,35.859333 c -30.850815,0 -55.874995,24.87043 -55.874995,55.562497 0,30.69207 25.02418,55.56249 55.874995,55.56249 10.09496,0 19.54625,-2.6525 27.71875,-7.3125 l 2.90625,7.3125 2.40625,0 20,0 0.125,0 -8.8125,-21.78124 c 7.21537,-9.3622 11.5,-21.07236 11.5,-33.78125 0,-30.692067 -24.99293,-55.562497 -55.84375,-55.562497 z"
+       id="path3834-7-7-2-5-5-0-5-4" />
+    <path
+       sodipodi:type="arc"
+       style="fill:url(#linearGradient3264);fill-opacity:1;stroke:none"
+       id="path3661"
+       sodipodi:cx="142.5"
+       sodipodi:cy="856.29077"
+       sodipodi:rx="35.357143"
+       sodipodi:ry="24.642857"
+       d="m 177.85714,856.29077 c 0,13.60988 -15.82993,24.64286 -35.35714,24.64286 -19.52721,0 -35.35714,-11.03298 -35.35714,-24.64286 0,-13.60987 15.82993,-24.64286 35.35714,-24.64286 19.52721,0 35.35714,11.03299 35.35714,24.64286 z"
+       transform="matrix(1.0465082,0,0,1.2920463,-51.641235,-1036.8612)" />
+    <path
+       sodipodi:type="arc"
+       style="fill:#000000;fill-opacity:1;stroke:none"
+       id="path4442"
+       sodipodi:cx="115.66247"
+       sodipodi:cy="856.39258"
+       sodipodi:rx="6.5659914"
+       sodipodi:ry="6.5659914"
+       d="m 122.22846,856.39258 c 0,3.6263 -2.9397,6.56599 -6.56599,6.56599 -3.6263,0 -6.56599,-2.93969 -6.56599,-6.56599 0,-3.6263 2.93969,-6.56599 6.56599,-6.56599 3.62629,0 6.56599,2.93969 6.56599,6.56599 z"
+       transform="translate(-12.329975,-797.60351)" />
+    <rect
+       style="fill:#000000;fill-opacity:1;stroke:none"
+       id="rect4444"
+       width="37.643608"
+       height="5.5005069"
+       x="101.55376"
+       y="48.297417"
+       transform="matrix(0.98974903,0.14281759,-0.18972639,0.981837,0,0)" />
+    <rect
+       style="fill:#000000;fill-opacity:1;stroke:none"
+       id="rect4446"
+       width="6.5659914"
+       height="2.9041886"
+       x="124.92451"
+       y="69.016899" />
+    <path
+       style="fill:#ff6600;fill-opacity:1"
+       d="m 83.38797,45.010543 c -0.057,2.18531 -3.865755,0.28296 -4.031245,2.78125 -4.22387,-1.88052 0.32884,2.87188 -0.0937,3.3125 l -0.0312,0 -0.3125,-0.0312 c -0.20386,-0.0728 -0.49977,-0.19904 -0.9375,-0.46875 -2.9499,2.35025 -3.02157,7.23369 -6.0625,9.9375 -1.99467,4.30504 -2.47977,8.98337 -3.9375,13.46875 -0.71796,4.30292 -1.34881,8.597857 -0.28125,12.906247 0.32053,3.50159 -0.68919,8.25865 2.5,10.71875 4.72728,3.88304 8.65575,8.79543 12.624995,13.46875 6.21914,7.65333 11.72948,15.86251 16.59375,24.4375 0.32431,-2.11756 1.10954,4.26459 2.53125,4.6875 -0.49161,-3.19231 -1.13213,-8.26328 -1.4375,-12.1875 -1.5814,-10.2909 -6.65305,-19.64903 -8.5625,-29.84375 -0.0587,-0.43037 -0.12809,-0.87203 -0.1875,-1.3125 l 0,-1.28125 -0.15625,0 c -0.62551,-5.04297 -0.8504,-10.46546 2.8125,-14.40625 3.73968,-3.772097 9.30633,-4.722447 13.8125,-7.343747 1.00194,-0.59119 2.04921,-1.07174 3.125,-1.40625 0.009,-0.003 0.0228,0.003 0.0312,0 3.11701,-0.96341 6.44862,-0.93323 9.6875,-0.40625 0.0479,0.008 0.10841,0.0233 0.15625,0.0312 0.29455,0.0493 0.61389,0.099 0.90625,0.15625 2.37136,0.21133 7.14463,1.13687 8,-0.5 -3.27225,-2.78631 -7.98526,-2.59211 -11.96875,-3.6875 -0.63059,-0.11469 -1.41182,-0.24041 -2.1875,-0.3125 l -3.90625,-0.875 -0.96875,-0.25 0,0.0312 -13.96875,-2.71875 c -0.22212,-0.20226 -0.46434,-0.40933 -0.6875,-0.5625 l 13.625,1.6875 0,-0.0625 c 0.48011,0.10699 0.95576,0.19361 1.4375,0.25 l 0,0.0312 9.625,1.78125 c 1.66103,0.61952 3.4322,1.08374 5.09375,1.1875 2.74263,0.39907 6.22526,4.49092 7.125,4.6875 -0.44096,-4.307 -4.7422,-6.23586 -8.3125,-7.5 -4.1712,-2.02803 -10.4023,-1.95417 -11.0625,-7.5625 -0.1756,-0.39076 -0.34902,-0.78118 -0.5625,-1.15625 l -1.625,-2.15625 0.0625,-0.0312 c -2.21724,-2.61691 -5.34011,-4.52196 -8.65625,-5.25 -3.2914,-1.13611 -6.98773,-2.2671 -10.46875,-2.71875 -1.18132,3.47826 -2.5031,-2.75561 -5.34375,-0.90625 -2.48996,0.29488 -2.14614,0.95256 -4,-0.625 z m 17.90625,10.15625 c 0.90187,-0.0238 1.93277,0.14208 2.96875,0.5 2.76259,0.95447 4.56151,2.96523 4.03125,4.5 -0.53026,1.53477 -3.20616,1.98572 -5.96875,1.03125 -2.76259,-0.95447 -4.5615,-2.93398 -4.03125,-4.46875 0.33141,-0.95923 1.49689,-1.52281 3,-1.5625 z"
+       id="path3499-9-7"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
diff --git a/qemu/share/qemu/s390-ccw.img b/qemu/share/qemu/s390-ccw.img
new file mode 100644
index 0000000..3c6b01f
Binary files /dev/null and b/qemu/share/qemu/s390-ccw.img differ
diff --git a/qemu/share/qemu/s390-zipl.rom b/qemu/share/qemu/s390-zipl.rom
new file mode 100644
index 0000000..3115128
Binary files /dev/null and b/qemu/share/qemu/s390-zipl.rom differ
diff --git a/qemu/share/qemu/sgabios.bin b/qemu/share/qemu/sgabios.bin
new file mode 100644
index 0000000..c3da4c3
Binary files /dev/null and b/qemu/share/qemu/sgabios.bin differ
diff --git a/qemu/share/qemu/slof.bin b/qemu/share/qemu/slof.bin
new file mode 100644
index 0000000..ab72cba
Binary files /dev/null and b/qemu/share/qemu/slof.bin differ
diff --git a/qemu/share/qemu/spapr-rtas.bin b/qemu/share/qemu/spapr-rtas.bin
new file mode 100644
index 0000000..fc24c8e
Binary files /dev/null and b/qemu/share/qemu/spapr-rtas.bin differ
diff --git a/qemu/share/qemu/trace-events b/qemu/share/qemu/trace-events
new file mode 100644
index 0000000..30eba92
--- /dev/null
+++ b/qemu/share/qemu/trace-events
@@ -0,0 +1,1592 @@
+# Trace events for debugging and performance instrumentation
+#
+# This file is processed by the tracetool script during the build.
+#
+# To add a new trace event:
+#
+# 1. Choose a name for the trace event.  Declare its arguments and format
+#    string.
+#
+# 2. Call the trace event from code using trace_##name, e.g. multiwrite_cb() ->
+#    trace_multiwrite_cb().  The source file must #include "trace.h".
+#
+# Format of a trace event:
+#
+# [disable] <name>(<type1> <arg1>[, <type2> <arg2>] ...) "<format-string>"
+#
+# Example: g_malloc(size_t size) "size %zu"
+#
+# The "disable" keyword will build without the trace event.
+#
+# The <name> must be a valid as a C function name.
+#
+# Types should be standard C types.  Use void * for pointers because the trace
+# system may not have the necessary headers included.
+#
+# The <format-string> should be a sprintf()-compatible format string.
+
+# util/oslib-win32.c
+# util/oslib-posix.c
+qemu_memalign(size_t alignment, size_t size, void *ptr) "alignment %zu size %zu ptr %p"
+qemu_anon_ram_alloc(size_t size, void *ptr) "size %zu ptr %p"
+qemu_vfree(void *ptr) "ptr %p"
+qemu_anon_ram_free(void *ptr, size_t size) "ptr %p size %zu"
+
+# hw/virtio/virtio.c
+virtqueue_fill(void *vq, const void *elem, unsigned int len, unsigned int idx) "vq %p elem %p len %u idx %u"
+virtqueue_flush(void *vq, unsigned int count) "vq %p count %u"
+virtqueue_pop(void *vq, void *elem, unsigned int in_num, unsigned int out_num) "vq %p elem %p in_num %u out_num %u"
+virtio_queue_notify(void *vdev, int n, void *vq) "vdev %p n %d vq %p"
+virtio_irq(void *vq) "vq %p"
+virtio_notify(void *vdev, void *vq) "vdev %p vq %p"
+virtio_set_status(void *vdev, uint8_t val) "vdev %p val %u"
+
+# hw/virtio/virtio-rng.c
+virtio_rng_guest_not_ready(void *rng) "rng %p: guest not ready"
+virtio_rng_pushed(void *rng, size_t len) "rng %p: %zd bytes pushed"
+virtio_rng_request(void *rng, size_t size, unsigned quota) "rng %p: %zd bytes requested, %u bytes quota left"
+
+# hw/char/virtio-serial-bus.c
+virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value) "port %u, event %u, value %u"
+virtio_serial_throttle_port(unsigned int port, bool throttle) "port %u, throttle %d"
+virtio_serial_handle_control_message(uint16_t event, uint16_t value) "event %u, value %u"
+virtio_serial_handle_control_message_port(unsigned int port) "port %u"
+
+# hw/char/virtio-console.c
+virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret) "port %u, in_len %zu, out_len %zd"
+virtio_console_chr_read(unsigned int port, int size) "port %u, size %d"
+virtio_console_chr_event(unsigned int port, int event) "port %u, event %d"
+
+# block.c
+bdrv_open_common(void *bs, const char *filename, int flags, const char *format_name) "bs %p filename \"%s\" flags %#x format_name \"%s\""
+multiwrite_cb(void *mcb, int ret) "mcb %p ret %d"
+bdrv_aio_multiwrite(void *mcb, int num_callbacks, int num_reqs) "mcb %p num_callbacks %d num_reqs %d"
+bdrv_aio_discard(void *bs, int64_t sector_num, int nb_sectors, void *opaque) "bs %p sector_num %"PRId64" nb_sectors %d opaque %p"
+bdrv_aio_flush(void *bs, void *opaque) "bs %p opaque %p"
+bdrv_aio_readv(void *bs, int64_t sector_num, int nb_sectors, void *opaque) "bs %p sector_num %"PRId64" nb_sectors %d opaque %p"
+bdrv_aio_writev(void *bs, int64_t sector_num, int nb_sectors, void *opaque) "bs %p sector_num %"PRId64" nb_sectors %d opaque %p"
+bdrv_aio_write_zeroes(void *bs, int64_t sector_num, int nb_sectors, int flags, void *opaque) "bs %p sector_num %"PRId64" nb_sectors %d flags %#x opaque %p"
+bdrv_lock_medium(void *bs, bool locked) "bs %p locked %d"
+bdrv_co_readv(void *bs, int64_t sector_num, int nb_sector) "bs %p sector_num %"PRId64" nb_sectors %d"
+bdrv_co_copy_on_readv(void *bs, int64_t sector_num, int nb_sector) "bs %p sector_num %"PRId64" nb_sectors %d"
+bdrv_co_writev(void *bs, int64_t sector_num, int nb_sector) "bs %p sector_num %"PRId64" nb_sectors %d"
+bdrv_co_write_zeroes(void *bs, int64_t sector_num, int nb_sector, int flags) "bs %p sector_num %"PRId64" nb_sectors %d flags %#x"
+bdrv_co_io_em(void *bs, int64_t sector_num, int nb_sectors, int is_write, void *acb) "bs %p sector_num %"PRId64" nb_sectors %d is_write %d acb %p"
+bdrv_co_do_copy_on_readv(void *bs, int64_t sector_num, int nb_sectors, int64_t cluster_sector_num, int cluster_nb_sectors) "bs %p sector_num %"PRId64" nb_sectors %d cluster_sector_num %"PRId64" cluster_nb_sectors %d"
+
+# block/stream.c
+stream_one_iteration(void *s, int64_t sector_num, int nb_sectors, int is_allocated) "s %p sector_num %"PRId64" nb_sectors %d is_allocated %d"
+stream_start(void *bs, void *base, void *s, void *co, void *opaque) "bs %p base %p s %p co %p opaque %p"
+
+# block/commit.c
+commit_one_iteration(void *s, int64_t sector_num, int nb_sectors, int is_allocated) "s %p sector_num %"PRId64" nb_sectors %d is_allocated %d"
+commit_start(void *bs, void *base, void *top, void *s, void *co, void *opaque) "bs %p base %p top %p s %p co %p opaque %p"
+
+# block/mirror.c
+mirror_start(void *bs, void *s, void *co, void *opaque) "bs %p s %p co %p opaque %p"
+mirror_restart_iter(void *s, int64_t cnt) "s %p dirty count %"PRId64
+mirror_before_flush(void *s) "s %p"
+mirror_before_drain(void *s, int64_t cnt) "s %p dirty count %"PRId64
+mirror_before_sleep(void *s, int64_t cnt, int synced, uint64_t delay_ns) "s %p dirty count %"PRId64" synced %d delay %"PRIu64"ns"
+mirror_one_iteration(void *s, int64_t sector_num, int nb_sectors) "s %p sector_num %"PRId64" nb_sectors %d"
+mirror_iteration_done(void *s, int64_t sector_num, int nb_sectors, int ret) "s %p sector_num %"PRId64" nb_sectors %d ret %d"
+mirror_yield(void *s, int64_t cnt, int buf_free_count, int in_flight) "s %p dirty count %"PRId64" free buffers %d in_flight %d"
+mirror_yield_in_flight(void *s, int64_t sector_num, int in_flight) "s %p sector_num %"PRId64" in_flight %d"
+mirror_yield_buf_busy(void *s, int nb_chunks, int in_flight) "s %p requested chunks %d in_flight %d"
+mirror_break_buf_busy(void *s, int nb_chunks, int in_flight) "s %p requested chunks %d in_flight %d"
+
+# block/backup.c
+backup_do_cow_enter(void *job, int64_t start, int64_t sector_num, int nb_sectors) "job %p start %"PRId64" sector_num %"PRId64" nb_sectors %d"
+backup_do_cow_return(void *job, int64_t sector_num, int nb_sectors, int ret) "job %p sector_num %"PRId64" nb_sectors %d ret %d"
+backup_do_cow_skip(void *job, int64_t start) "job %p start %"PRId64
+backup_do_cow_process(void *job, int64_t start) "job %p start %"PRId64
+backup_do_cow_read_fail(void *job, int64_t start, int ret) "job %p start %"PRId64" ret %d"
+backup_do_cow_write_fail(void *job, int64_t start, int ret) "job %p start %"PRId64" ret %d"
+
+# blockdev.c
+qmp_block_job_cancel(void *job) "job %p"
+qmp_block_job_pause(void *job) "job %p"
+qmp_block_job_resume(void *job) "job %p"
+qmp_block_job_complete(void *job) "job %p"
+block_job_cb(void *bs, void *job, int ret) "bs %p job %p ret %d"
+qmp_block_stream(void *bs, void *job) "bs %p job %p"
+
+# hw/block/virtio-blk.c
+virtio_blk_req_complete(void *req, int status) "req %p status %d"
+virtio_blk_rw_complete(void *req, int ret) "req %p ret %d"
+virtio_blk_handle_write(void *req, uint64_t sector, size_t nsectors) "req %p sector %"PRIu64" nsectors %zu"
+virtio_blk_handle_read(void *req, uint64_t sector, size_t nsectors) "req %p sector %"PRIu64" nsectors %zu"
+virtio_blk_submit_multireq(void *mrb, int start, int num_reqs, uint64_t sector, size_t nsectors, bool is_write) "mrb %p start %d num_reqs %d sector %"PRIu64" nsectors %zu is_write %d"
+
+# hw/block/dataplane/virtio-blk.c
+virtio_blk_data_plane_start(void *s) "dataplane %p"
+virtio_blk_data_plane_stop(void *s) "dataplane %p"
+virtio_blk_data_plane_process_request(void *s, unsigned int out_num, unsigned int in_num, unsigned int head) "dataplane %p out_num %u in_num %u head %u"
+
+# hw/virtio/dataplane/vring.c
+vring_setup(uint64_t physical, void *desc, void *avail, void *used) "vring physical %#"PRIx64" desc %p avail %p used %p"
+
+# thread-pool.c
+thread_pool_submit(void *pool, void *req, void *opaque) "pool %p req %p opaque %p"
+thread_pool_complete(void *pool, void *req, void *opaque, int ret) "pool %p req %p opaque %p ret %d"
+thread_pool_cancel(void *req, void *opaque) "req %p opaque %p"
+
+# block/raw-win32.c
+# block/raw-posix.c
+paio_submit_co(int64_t sector_num, int nb_sectors, int type) "sector_num %"PRId64" nb_sectors %d type %d"
+paio_submit(void *acb, void *opaque, int64_t sector_num, int nb_sectors, int type) "acb %p opaque %p sector_num %"PRId64" nb_sectors %d type %d"
+
+# ioport.c
+cpu_in(unsigned int addr, unsigned int val) "addr %#x value %u"
+cpu_out(unsigned int addr, unsigned int val) "addr %#x value %u"
+
+# balloon.c
+# Since requests are raised via monitor, not many tracepoints are needed.
+balloon_event(void *opaque, unsigned long addr) "opaque %p addr %lu"
+virtio_balloon_handle_output(const char *name, uint64_t gpa) "setion name: %s gpa: %"PRIx64""
+virtio_balloon_get_config(uint32_t num_pages, uint32_t acutal) "num_pages: %d acutal: %d"
+virtio_balloon_set_config(uint32_t acutal, uint32_t oldacutal) "acutal: %d oldacutal: %d"
+virtio_balloon_to_target(uint64_t target, uint32_t num_pages) "balloon target: %"PRIx64" num_pages: %d"
+
+# hw/intc/apic_common.c
+cpu_set_apic_base(uint64_t val) "%016"PRIx64
+cpu_get_apic_base(uint64_t val) "%016"PRIx64
+# coalescing
+apic_report_irq_delivered(int apic_irq_delivered) "coalescing %d"
+apic_reset_irq_delivered(int apic_irq_delivered) "old coalescing %d"
+apic_get_irq_delivered(int apic_irq_delivered) "returning coalescing %d"
+
+# hw/intc/apic.c
+apic_local_deliver(int vector, uint32_t lvt) "vector %d delivery mode %d"
+apic_deliver_irq(uint8_t dest, uint8_t dest_mode, uint8_t delivery_mode, uint8_t vector_num, uint8_t trigger_mode) "dest %d dest_mode %d delivery_mode %d vector %d trigger_mode %d"
+apic_mem_readl(uint64_t addr, uint32_t val)  "%"PRIx64" = %08x"
+apic_mem_writel(uint64_t addr, uint32_t val) "%"PRIx64" = %08x"
+
+# hw/audio/cs4231.c
+cs4231_mem_readl_dreg(uint32_t reg, uint32_t ret) "read dreg %d: 0x%02x"
+cs4231_mem_readl_reg(uint32_t reg, uint32_t ret) "read reg %d: 0x%08x"
+cs4231_mem_writel_reg(uint32_t reg, uint32_t old, uint32_t val) "write reg %d: 0x%08x -> 0x%08x"
+cs4231_mem_writel_dreg(uint32_t reg, uint32_t old, uint32_t val) "write dreg %d: 0x%02x -> 0x%02x"
+
+# hw/nvram/ds1225y.c
+nvram_read(uint32_t addr, uint32_t ret) "read addr %d: 0x%02x"
+nvram_write(uint32_t addr, uint32_t old, uint32_t val) "write addr %d: 0x%02x -> 0x%02x"
+
+# hw/misc/eccmemctl.c
+ecc_mem_writel_mer(uint32_t val) "Write memory enable %08x"
+ecc_mem_writel_mdr(uint32_t val) "Write memory delay %08x"
+ecc_mem_writel_mfsr(uint32_t val) "Write memory fault status %08x"
+ecc_mem_writel_vcr(uint32_t val) "Write slot configuration %08x"
+ecc_mem_writel_dr(uint32_t val) "Write diagnostic %08x"
+ecc_mem_writel_ecr0(uint32_t val) "Write event count 1 %08x"
+ecc_mem_writel_ecr1(uint32_t val) "Write event count 2 %08x"
+ecc_mem_readl_mer(uint32_t ret) "Read memory enable %08x"
+ecc_mem_readl_mdr(uint32_t ret) "Read memory delay %08x"
+ecc_mem_readl_mfsr(uint32_t ret) "Read memory fault status %08x"
+ecc_mem_readl_vcr(uint32_t ret) "Read slot configuration %08x"
+ecc_mem_readl_mfar0(uint32_t ret) "Read memory fault address 0 %08x"
+ecc_mem_readl_mfar1(uint32_t ret) "Read memory fault address 1 %08x"
+ecc_mem_readl_dr(uint32_t ret) "Read diagnostic %08x"
+ecc_mem_readl_ecr0(uint32_t ret) "Read event count 1 %08x"
+ecc_mem_readl_ecr1(uint32_t ret) "Read event count 2 %08x"
+ecc_diag_mem_writeb(uint64_t addr, uint32_t val) "Write diagnostic %"PRId64" = %02x"
+ecc_diag_mem_readb(uint64_t addr, uint32_t ret) "Read diagnostic %"PRId64"= %02x"
+
+# hw/nvram/fw_cfg.c
+fw_cfg_write(void *s, uint8_t value) "%p %d"
+fw_cfg_select(void *s, uint16_t key, int ret) "%p key %d = %d"
+fw_cfg_read(void *s, uint8_t ret) "%p = %d"
+fw_cfg_add_file_dupe(void *s, char *name) "%p %s"
+fw_cfg_add_file(void *s, int index, char *name, size_t len) "%p #%d: %s (%zd bytes)"
+
+# hw/block/hd-geometry.c
+hd_geometry_lchs_guess(void *blk, int cyls, int heads, int secs) "blk %p LCHS %d %d %d"
+hd_geometry_guess(void *blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans) "blk %p CHS %u %u %u trans %d"
+
+# hw/display/jazz_led.c
+jazz_led_read(uint64_t addr, uint8_t val) "read addr=0x%"PRIx64": 0x%x"
+jazz_led_write(uint64_t addr, uint8_t new) "write addr=0x%"PRIx64": 0x%x"
+
+# hw/display/xenfb.c
+xenfb_mouse_event(void *opaque, int dx, int dy, int dz, int button_state, int abs_pointer_wanted) "%p x %d y %d z %d bs %#x abs %d"
+xenfb_input_connected(void *xendev, int abs_pointer_wanted) "%p abs %d"
+
+# hw/net/lance.c
+lance_mem_readw(uint64_t addr, uint32_t ret) "addr=%"PRIx64"val=0x%04x"
+lance_mem_writew(uint64_t addr, uint32_t val) "addr=%"PRIx64"val=0x%04x"
+
+# hw/intc/slavio_intctl.c
+slavio_intctl_mem_readl(uint32_t cpu, uint64_t addr, uint32_t ret) "read cpu %d reg 0x%"PRIx64" = %x"
+slavio_intctl_mem_writel(uint32_t cpu, uint64_t addr, uint32_t val) "write cpu %d reg 0x%"PRIx64" = %x"
+slavio_intctl_mem_writel_clear(uint32_t cpu, uint32_t val, uint32_t intreg_pending) "Cleared cpu %d irq mask %x, curmask %x"
+slavio_intctl_mem_writel_set(uint32_t cpu, uint32_t val, uint32_t intreg_pending) "Set cpu %d irq mask %x, curmask %x"
+slavio_intctlm_mem_readl(uint64_t addr, uint32_t ret) "read system reg 0x%"PRIx64" = %x"
+slavio_intctlm_mem_writel(uint64_t addr, uint32_t val) "write system reg 0x%"PRIx64" = %x"
+slavio_intctlm_mem_writel_enable(uint32_t val, uint32_t intregm_disabled) "Enabled master irq mask %x, curmask %x"
+slavio_intctlm_mem_writel_disable(uint32_t val, uint32_t intregm_disabled) "Disabled master irq mask %x, curmask %x"
+slavio_intctlm_mem_writel_target(uint32_t cpu) "Set master irq cpu %d"
+slavio_check_interrupts(uint32_t pending, uint32_t intregm_disabled) "pending %x disabled %x"
+slavio_set_irq(uint32_t target_cpu, int irq, uint32_t pil, int level) "Set cpu %d irq %d -> pil %d level %d"
+slavio_set_timer_irq_cpu(int cpu, int level) "Set cpu %d local timer level %d"
+
+# hw/input/ps2.c
+ps2_put_keycode(void *opaque, int keycode) "%p keycode %d"
+ps2_read_data(void *opaque) "%p"
+ps2_set_ledstate(void *s, int ledstate) "%p ledstate %d"
+ps2_reset_keyboard(void *s) "%p"
+ps2_write_keyboard(void *opaque, int val) "%p val %d"
+ps2_keyboard_set_translation(void *opaque, int mode) "%p mode %d"
+ps2_mouse_send_packet(void *s, int dx1, int dy1, int dz1, int b) "%p x %d y %d z %d bs %#x"
+ps2_mouse_event_disabled(void *opaque, int dx, int dy, int dz, int buttons_state, int mouse_dx, int mouse_dy, int mouse_dz) "%p x %d y %d z %d bs %#x mx %d my %d mz %d "
+ps2_mouse_event(void *opaque, int dx, int dy, int dz, int buttons_state, int mouse_dx, int mouse_dy, int mouse_dz) "%p x %d y %d z %d bs %#x mx %d my %d mz %d "
+ps2_mouse_fake_event(void *opaque) "%p"
+ps2_write_mouse(void *opaque, int val) "%p val %d"
+ps2_kbd_reset(void *opaque) "%p"
+ps2_mouse_reset(void *opaque) "%p"
+ps2_kbd_init(void *s) "%p"
+ps2_mouse_init(void *s) "%p"
+
+# hw/misc/slavio_misc.c
+slavio_misc_update_irq_raise(void) "Raise IRQ"
+slavio_misc_update_irq_lower(void) "Lower IRQ"
+slavio_set_power_fail(int power_failing, uint8_t config) "Power fail: %d, config: %d"
+slavio_cfg_mem_writeb(uint32_t val) "Write config %02x"
+slavio_cfg_mem_readb(uint32_t ret) "Read config %02x"
+slavio_diag_mem_writeb(uint32_t val) "Write diag %02x"
+slavio_diag_mem_readb(uint32_t ret) "Read diag %02x"
+slavio_mdm_mem_writeb(uint32_t val) "Write modem control %02x"
+slavio_mdm_mem_readb(uint32_t ret) "Read modem control %02x"
+slavio_aux1_mem_writeb(uint32_t val) "Write aux1 %02x"
+slavio_aux1_mem_readb(uint32_t ret) "Read aux1 %02x"
+slavio_aux2_mem_writeb(uint32_t val) "Write aux2 %02x"
+slavio_aux2_mem_readb(uint32_t ret) "Read aux2 %02x"
+apc_mem_writeb(uint32_t val) "Write power management %02x"
+apc_mem_readb(uint32_t ret) "Read power management %02x"
+slavio_sysctrl_mem_writel(uint32_t val) "Write system control %08x"
+slavio_sysctrl_mem_readl(uint32_t ret) "Read system control %08x"
+slavio_led_mem_writew(uint32_t val) "Write diagnostic LED %04x"
+slavio_led_mem_readw(uint32_t ret) "Read diagnostic LED %04x"
+
+# hw/timer/slavio_timer.c
+slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count) "limit %"PRIx64" count %x%08x"
+slavio_timer_irq(uint32_t counthigh, uint32_t count) "callback: count %x%08x"
+slavio_timer_mem_readl_invalid(uint64_t addr) "invalid read address %"PRIx64
+slavio_timer_mem_readl(uint64_t addr, uint32_t ret) "read %"PRIx64" = %08x"
+slavio_timer_mem_writel(uint64_t addr, uint32_t val) "write %"PRIx64" = %08x"
+slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count) "processor %d user timer set to %016"PRIx64
+slavio_timer_mem_writel_counter_invalid(void) "not user timer"
+slavio_timer_mem_writel_status_start(unsigned int timer_index) "processor %d user timer started"
+slavio_timer_mem_writel_status_stop(unsigned int timer_index) "processor %d user timer stopped"
+slavio_timer_mem_writel_mode_user(unsigned int timer_index) "processor %d changed from counter to user timer"
+slavio_timer_mem_writel_mode_counter(unsigned int timer_index) "processor %d changed from user timer to counter"
+slavio_timer_mem_writel_mode_invalid(void) "not system timer"
+slavio_timer_mem_writel_invalid(uint64_t addr) "invalid write address %"PRIx64
+
+# hw/dma/sparc32_dma.c
+ledma_memory_read(uint64_t addr) "DMA read addr 0x%"PRIx64
+ledma_memory_write(uint64_t addr) "DMA write addr 0x%"PRIx64
+sparc32_dma_set_irq_raise(void) "Raise IRQ"
+sparc32_dma_set_irq_lower(void) "Lower IRQ"
+espdma_memory_read(uint32_t addr) "DMA read addr 0x%08x"
+espdma_memory_write(uint32_t addr) "DMA write addr 0x%08x"
+sparc32_dma_mem_readl(uint64_t addr, uint32_t ret) "read dmareg %"PRIx64": 0x%08x"
+sparc32_dma_mem_writel(uint64_t addr, uint32_t old, uint32_t val) "write dmareg %"PRIx64": 0x%08x -> 0x%08x"
+sparc32_dma_enable_raise(void) "Raise DMA enable"
+sparc32_dma_enable_lower(void) "Lower DMA enable"
+
+# hw/sparc/sun4m.c
+sun4m_cpu_interrupt(unsigned int level) "Set CPU IRQ %d"
+sun4m_cpu_reset_interrupt(unsigned int level) "Reset CPU IRQ %d"
+sun4m_cpu_set_irq_raise(int level) "Raise CPU IRQ %d"
+sun4m_cpu_set_irq_lower(int level) "Lower CPU IRQ %d"
+
+# hw/dma/sun4m_iommu.c
+sun4m_iommu_mem_readl(uint64_t addr, uint32_t ret) "read reg[%"PRIx64"] = %x"
+sun4m_iommu_mem_writel(uint64_t addr, uint32_t val) "write reg[%"PRIx64"] = %x"
+sun4m_iommu_mem_writel_ctrl(uint64_t iostart) "iostart = %"PRIx64
+sun4m_iommu_mem_writel_tlbflush(uint32_t val) "tlb flush %x"
+sun4m_iommu_mem_writel_pgflush(uint32_t val) "page flush %x"
+sun4m_iommu_page_get_flags(uint64_t pa, uint64_t iopte, uint32_t ret) "get flags addr %"PRIx64" => pte %"PRIx64", *pte = %x"
+sun4m_iommu_translate_pa(uint64_t addr, uint64_t pa, uint32_t iopte) "xlate dva %"PRIx64" => pa %"PRIx64" iopte = %x"
+sun4m_iommu_bad_addr(uint64_t addr) "bad addr %"PRIx64
+
+# hw/usb/core.c
+usb_packet_state_change(int bus, const char *port, int ep, void *p, const char *o, const char *n) "bus %d, port %s, ep %d, packet %p, state %s -> %s"
+usb_packet_state_fault(int bus, const char *port, int ep, void *p, const char *o, const char *n) "bus %d, port %s, ep %d, packet %p, state %s, expected %s"
+
+# hw/usb/bus.c
+usb_port_claim(int bus, const char *port) "bus %d, port %s"
+usb_port_attach(int bus, const char *port, const char *devspeed, const char *portspeed) "bus %d, port %s, devspeed %s, portspeed %s"
+usb_port_detach(int bus, const char *port) "bus %d, port %s"
+usb_port_release(int bus, const char *port) "bus %d, port %s"
+
+# hw/usb/hcd-ohci.c
+usb_ohci_iso_td_read_failed(uint32_t addr) "ISO_TD read error at %x"
+usb_ohci_iso_td_head(uint32_t head, uint32_t tail, uint32_t flags, uint32_t bp, uint32_t next, uint32_t be, uint32_t framenum, uint32_t startframe, uint32_t framecount, int rel_frame_num) "ISO_TD ED head 0x%.8x tailp 0x%.8x\n0x%.8x 0x%.8x 0x%.8x 0x%.8x\nframe_number 0x%.8x starting_frame 0x%.8x\nframe_count  0x%.8x relative %d"
+usb_ohci_iso_td_head_offset(uint32_t o0, uint32_t o1, uint32_t o2, uint32_t o3, uint32_t o4, uint32_t o5, uint32_t o6, uint32_t o7) "0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x"
+usb_ohci_iso_td_relative_frame_number_neg(int rel) "ISO_TD R=%d < 0"
+usb_ohci_iso_td_relative_frame_number_big(int rel, int count) "ISO_TD R=%d > FC=%d"
+usb_ohci_iso_td_bad_direction(int dir) "Bad direction %d"
+usb_ohci_iso_td_bad_bp_be(uint32_t bp, uint32_t be) "ISO_TD bp 0x%.8x be 0x%.8x"
+usb_ohci_iso_td_bad_cc_not_accessed(uint32_t start, uint32_t next) "ISO_TD cc != not accessed 0x%.8x 0x%.8x"
+usb_ohci_iso_td_bad_cc_overrun(uint32_t start, uint32_t next) "ISO_TD start_offset=0x%.8x > next_offset=0x%.8x"
+usb_ohci_iso_td_so(uint32_t so, uint32_t eo, uint32_t s, uint32_t e, const char *str, ssize_t len, int ret) "0x%.8x eo 0x%.8x\nsa 0x%.8x ea 0x%.8x\ndir %s len %zu ret %d"
+usb_ohci_iso_td_data_overrun(int ret, ssize_t len) "DataOverrun %d > %zu"
+usb_ohci_iso_td_data_underrun(int ret) "DataUnderrun %d"
+usb_ohci_iso_td_nak(int ret) "got NAK/STALL %d"
+usb_ohci_iso_td_bad_response(int ret) "Bad device response %d"
+usb_ohci_port_attach(int index) "port #%d"
+usb_ohci_port_detach(int index) "port #%d"
+usb_ohci_port_wakeup(int index) "port #%d"
+usb_ohci_port_suspend(int index) "port #%d"
+usb_ohci_port_reset(int index) "port #%d"
+usb_ohci_remote_wakeup(const char *s) "%s: SUSPEND->RESUME"
+usb_ohci_reset(const char *s) "%s"
+usb_ohci_start(const char *s) "%s: USB Operational"
+usb_ohci_resume(const char *s) "%s: USB Resume"
+usb_ohci_stop(const char *s) "%s: USB Suspended"
+usb_ohci_exit(const char *s) "%s"
+usb_ohci_set_ctl(const char *s, uint32_t new_state) "%s: new state 0x%x"
+usb_ohci_td_underrun(void) ""
+usb_ohci_td_dev_error(void) ""
+usb_ohci_td_nak(void) ""
+usb_ohci_td_stall(void) ""
+usb_ohci_td_babble(void) ""
+usb_ohci_td_bad_device_response(int rc) "%d"
+usb_ohci_td_read_error(uint32_t addr) "TD read error at %x"
+usb_ohci_td_bad_direction(int dir) "Bad direction %d"
+usb_ohci_td_skip_async(void) ""
+usb_ohci_td_pkt_hdr(uint32_t addr, int64_t pktlen, int64_t len, const char *s, int flag_r, uint32_t cbp, uint32_t be) " TD @ 0x%.8x %" PRId64 " of %" PRId64 " bytes %s r=%d cbp=0x%.8x be=0x%.8x"
+usb_ohci_td_pkt_short(const char *dir, const char *buf) "%s data: %s"
+usb_ohci_td_pkt_full(const char *dir, const char *buf) "%s data: %s"
+usb_ohci_td_too_many_pending(void) ""
+usb_ohci_td_packet_status(int status) "status=%d"
+usb_ohci_ed_read_error(uint32_t addr) "ED read error at %x"
+usb_ohci_ed_pkt(uint32_t cur, int h, int c, uint32_t head, uint32_t tail, uint32_t next) "ED @ 0x%.8x h=%u c=%u\n  head=0x%.8x tailp=0x%.8x next=0x%.8x"
+usb_ohci_ed_pkt_flags(uint32_t fa, uint32_t en, uint32_t d, int s, int k, int f, uint32_t mps) "fa=%u en=%u d=%u s=%u k=%u f=%u mps=%u"
+usb_ohci_hcca_read_error(uint32_t addr) "HCCA read error at %x"
+usb_ohci_mem_read_unaligned(uint32_t addr) "at %x"
+usb_ohci_mem_read_bad_offset(uint32_t addr) "%x"
+usb_ohci_mem_write_unaligned(uint32_t addr) "at %x"
+usb_ohci_mem_write_bad_offset(uint32_t addr) "%x"
+usb_ohci_process_lists(uint32_t head, uint32_t cur) "head %x, cur %x"
+usb_ohci_bus_eof_timer_failed(const char *name) "%s: timer_new_ns failed"
+usb_ohci_set_frame_interval(const char *name, uint16_t fi_x, uint16_t fi_u) "%s: FrameInterval = 0x%x (%u)"
+usb_ohci_hub_power_up(void) "powered up all ports"
+usb_ohci_hub_power_down(void) "powered down all ports"
+usb_ohci_init_time(int64_t frametime, int64_t bittime) "usb_bit_time=%" PRId64 " usb_frame_time=%" PRId64
+usb_ohci_die(void) ""
+usb_ohci_async_complete(void) ""
+
+# hw/usb/hcd-ehci.c
+usb_ehci_reset(void) "=== RESET ==="
+usb_ehci_unrealize(void) "=== UNREALIZE ==="
+usb_ehci_opreg_read(uint32_t addr, const char *str, uint32_t val) "rd mmio %04x [%s] = %x"
+usb_ehci_opreg_write(uint32_t addr, const char *str, uint32_t val) "wr mmio %04x [%s] = %x"
+usb_ehci_opreg_change(uint32_t addr, const char *str, uint32_t new, uint32_t old) "ch mmio %04x [%s] = %x (old: %x)"
+usb_ehci_portsc_read(uint32_t addr, uint32_t port, uint32_t val) "rd mmio %04x [port %d] = %x"
+usb_ehci_portsc_write(uint32_t addr, uint32_t port, uint32_t val) "wr mmio %04x [port %d] = %x"
+usb_ehci_portsc_change(uint32_t addr, uint32_t port, uint32_t new, uint32_t old) "ch mmio %04x [port %d] = %x (old: %x)"
+usb_ehci_usbsts(const char *sts, int state) "usbsts %s %d"
+usb_ehci_state(const char *schedule, const char *state) "%s schedule %s"
+usb_ehci_qh_ptrs(void *q, uint32_t addr, uint32_t nxt, uint32_t c_qtd, uint32_t n_qtd, uint32_t a_qtd) "q %p - QH @ %08x: next %08x qtds %08x,%08x,%08x"
+usb_ehci_qh_fields(uint32_t addr, int rl, int mplen, int eps, int ep, int devaddr) "QH @ %08x - rl %d, mplen %d, eps %d, ep %d, dev %d"
+usb_ehci_qh_bits(uint32_t addr, int c, int h, int dtc, int i) "QH @ %08x - c %d, h %d, dtc %d, i %d"
+usb_ehci_qtd_ptrs(void *q, uint32_t addr, uint32_t nxt, uint32_t altnext) "q %p - QTD @ %08x: next %08x altnext %08x"
+usb_ehci_qtd_fields(uint32_t addr, int tbytes, int cpage, int cerr, int pid) "QTD @ %08x - tbytes %d, cpage %d, cerr %d, pid %d"
+usb_ehci_qtd_bits(uint32_t addr, int ioc, int active, int halt, int babble, int xacterr) "QTD @ %08x - ioc %d, active %d, halt %d, babble %d, xacterr %d"
+usb_ehci_itd(uint32_t addr, uint32_t nxt, uint32_t mplen, uint32_t mult, uint32_t ep, uint32_t devaddr) "ITD @ %08x: next %08x - mplen %d, mult %d, ep %d, dev %d"
+usb_ehci_sitd(uint32_t addr, uint32_t nxt, uint32_t active) "ITD @ %08x: next %08x - active %d"
+usb_ehci_port_attach(uint32_t port, const char *owner, const char *device) "attach port #%d, owner %s, device %s"
+usb_ehci_port_detach(uint32_t port, const char *owner) "detach port #%d, owner %s"
+usb_ehci_port_reset(uint32_t port, int enable) "reset port #%d - %d"
+usb_ehci_port_suspend(uint32_t port) "port #%d"
+usb_ehci_port_wakeup(uint32_t port) "port #%d"
+usb_ehci_port_resume(uint32_t port) "port #%d"
+usb_ehci_queue_action(void *q, const char *action) "q %p: %s"
+usb_ehci_packet_action(void *q, void *p, const char *action) "q %p p %p: %s"
+usb_ehci_irq(uint32_t level, uint32_t frindex, uint32_t sts, uint32_t mask) "level %d, frindex 0x%04x, sts 0x%x, mask 0x%x"
+usb_ehci_guest_bug(const char *reason) "%s"
+usb_ehci_doorbell_ring(void) ""
+usb_ehci_doorbell_ack(void) ""
+usb_ehci_dma_error(void) ""
+
+# hw/usb/hcd-uhci.c
+usb_uhci_reset(void) "=== RESET ==="
+usb_uhci_exit(void) "=== EXIT ==="
+usb_uhci_schedule_start(void) ""
+usb_uhci_schedule_stop(void) ""
+usb_uhci_frame_start(uint32_t num) "nr %d"
+usb_uhci_frame_stop_bandwidth(void) ""
+usb_uhci_frame_loop_stop_idle(void) ""
+usb_uhci_frame_loop_continue(void) ""
+usb_uhci_mmio_readw(uint32_t addr, uint32_t val) "addr 0x%04x, ret 0x%04x"
+usb_uhci_mmio_writew(uint32_t addr, uint32_t val) "addr 0x%04x, val 0x%04x"
+usb_uhci_queue_add(uint32_t token) "token 0x%x"
+usb_uhci_queue_del(uint32_t token, const char *reason) "token 0x%x: %s"
+usb_uhci_packet_add(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_link_async(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_unlink_async(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_cancel(uint32_t token, uint32_t addr, int done) "token 0x%x, td 0x%x, done %d"
+usb_uhci_packet_complete_success(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_complete_shortxfer(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_complete_stall(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_complete_babble(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_complete_error(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_packet_del(uint32_t token, uint32_t addr) "token 0x%x, td 0x%x"
+usb_uhci_qh_load(uint32_t qh) "qh 0x%x"
+usb_uhci_td_load(uint32_t qh, uint32_t td, uint32_t ctrl, uint32_t token) "qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x"
+usb_uhci_td_queue(uint32_t td, uint32_t ctrl, uint32_t token) "td 0x%x, ctrl 0x%x, token 0x%x"
+usb_uhci_td_nextqh(uint32_t qh, uint32_t td) "qh 0x%x, td 0x%x"
+usb_uhci_td_async(uint32_t qh, uint32_t td) "qh 0x%x, td 0x%x"
+usb_uhci_td_complete(uint32_t qh, uint32_t td) "qh 0x%x, td 0x%x"
+
+# hw/usb/hcd-xhci.c
+usb_xhci_reset(void) "=== RESET ==="
+usb_xhci_exit(void) "=== EXIT ==="
+usb_xhci_run(void) ""
+usb_xhci_stop(void) ""
+usb_xhci_cap_read(uint32_t off, uint32_t val) "off 0x%04x, ret 0x%08x"
+usb_xhci_oper_read(uint32_t off, uint32_t val) "off 0x%04x, ret 0x%08x"
+usb_xhci_port_read(uint32_t port, uint32_t off, uint32_t val) "port %d, off 0x%04x, ret 0x%08x"
+usb_xhci_runtime_read(uint32_t off, uint32_t val) "off 0x%04x, ret 0x%08x"
+usb_xhci_doorbell_read(uint32_t off, uint32_t val) "off 0x%04x, ret 0x%08x"
+usb_xhci_oper_write(uint32_t off, uint32_t val) "off 0x%04x, val 0x%08x"
+usb_xhci_port_write(uint32_t port, uint32_t off, uint32_t val) "port %d, off 0x%04x, val 0x%08x"
+usb_xhci_runtime_write(uint32_t off, uint32_t val) "off 0x%04x, val 0x%08x"
+usb_xhci_doorbell_write(uint32_t off, uint32_t val) "off 0x%04x, val 0x%08x"
+usb_xhci_irq_intx(uint32_t level) "level %d"
+usb_xhci_irq_msi(uint32_t nr) "nr %d"
+usb_xhci_irq_msix(uint32_t nr) "nr %d"
+usb_xhci_irq_msix_use(uint32_t nr) "nr %d"
+usb_xhci_irq_msix_unuse(uint32_t nr) "nr %d"
+usb_xhci_queue_event(uint32_t vector, uint32_t idx, const char *trb, const char *evt, uint64_t param, uint32_t status, uint32_t control) "v %d, idx %d, %s, %s, p %016" PRIx64 ", s %08x, c 0x%08x"
+usb_xhci_fetch_trb(uint64_t addr, const char *name, uint64_t param, uint32_t status, uint32_t control) "addr %016" PRIx64 ", %s, p %016" PRIx64 ", s %08x, c 0x%08x"
+usb_xhci_port_reset(uint32_t port, bool warm) "port %d, warm %d"
+usb_xhci_port_link(uint32_t port, uint32_t pls) "port %d, pls %d"
+usb_xhci_port_notify(uint32_t port, uint32_t pls) "port %d, bits %x"
+usb_xhci_slot_enable(uint32_t slotid) "slotid %d"
+usb_xhci_slot_disable(uint32_t slotid) "slotid %d"
+usb_xhci_slot_address(uint32_t slotid, const char *port) "slotid %d, port %s"
+usb_xhci_slot_configure(uint32_t slotid) "slotid %d"
+usb_xhci_slot_evaluate(uint32_t slotid) "slotid %d"
+usb_xhci_slot_reset(uint32_t slotid) "slotid %d"
+usb_xhci_ep_enable(uint32_t slotid, uint32_t epid) "slotid %d, epid %d"
+usb_xhci_ep_disable(uint32_t slotid, uint32_t epid) "slotid %d, epid %d"
+usb_xhci_ep_set_dequeue(uint32_t slotid, uint32_t epid, uint32_t streamid, uint64_t param) "slotid %d, epid %d, streamid %d, ptr %016" PRIx64
+usb_xhci_ep_kick(uint32_t slotid, uint32_t epid, uint32_t streamid) "slotid %d, epid %d, streamid %d"
+usb_xhci_ep_stop(uint32_t slotid, uint32_t epid) "slotid %d, epid %d"
+usb_xhci_ep_reset(uint32_t slotid, uint32_t epid) "slotid %d, epid %d"
+usb_xhci_ep_state(uint32_t slotid, uint32_t epid, const char *os, const char *ns) "slotid %d, epid %d, %s -> %s"
+usb_xhci_xfer_start(void *xfer, uint32_t slotid, uint32_t epid, uint32_t streamid) "%p: slotid %d, epid %d, streamid %d"
+usb_xhci_xfer_async(void *xfer) "%p"
+usb_xhci_xfer_nak(void *xfer) "%p"
+usb_xhci_xfer_retry(void *xfer) "%p"
+usb_xhci_xfer_success(void *xfer, uint32_t bytes) "%p: len %d"
+usb_xhci_xfer_error(void *xfer, uint32_t ret) "%p: ret %d"
+usb_xhci_unimplemented(const char *item, int nr) "%s (0x%x)"
+
+# hw/usb/desc.c
+usb_desc_device(int addr, int len, int ret) "dev %d query device, len %d, ret %d"
+usb_desc_device_qualifier(int addr, int len, int ret) "dev %d query device qualifier, len %d, ret %d"
+usb_desc_config(int addr, int index, int len, int ret) "dev %d query config %d, len %d, ret %d"
+usb_desc_other_speed_config(int addr, int index, int len, int ret) "dev %d query config %d, len %d, ret %d"
+usb_desc_string(int addr, int index, int len, int ret) "dev %d query string %d, len %d, ret %d"
+usb_desc_bos(int addr, int len, int ret) "dev %d bos, len %d, ret %d"
+usb_desc_msos(int addr, int index, int len, int ret) "dev %d msos, index 0x%x, len %d, ret %d"
+usb_set_addr(int addr) "dev %d"
+usb_set_config(int addr, int config, int ret) "dev %d, config %d, ret %d"
+usb_set_interface(int addr, int iface, int alt, int ret) "dev %d, interface %d, altsetting %d, ret %d"
+usb_clear_device_feature(int addr, int feature, int ret) "dev %d, feature %d, ret %d"
+usb_set_device_feature(int addr, int feature, int ret) "dev %d, feature %d, ret %d"
+
+# hw/usb/dev-hub.c
+usb_hub_reset(int addr) "dev %d"
+usb_hub_control(int addr, int request, int value, int index, int length) "dev %d, req 0x%x, value %d, index %d, langth %d"
+usb_hub_get_port_status(int addr, int nr, int status, int changed) "dev %d, port %d, status 0x%x, changed 0x%x"
+usb_hub_set_port_feature(int addr, int nr, const char *f) "dev %d, port %d, feature %s"
+usb_hub_clear_port_feature(int addr, int nr, const char *f) "dev %d, port %d, feature %s"
+usb_hub_attach(int addr, int nr) "dev %d, port %d"
+usb_hub_detach(int addr, int nr) "dev %d, port %d"
+usb_hub_status_report(int addr, int status) "dev %d, status 0x%x"
+
+# hw/usb/dev-uas.c
+usb_uas_reset(int addr) "dev %d"
+usb_uas_command(int addr, uint16_t tag, int lun, uint32_t lun64_1, uint32_t lun64_2) "dev %d, tag 0x%x, lun %d, lun64 %08x-%08x"
+usb_uas_response(int addr, uint16_t tag, uint8_t code) "dev %d, tag 0x%x, code 0x%x"
+usb_uas_sense(int addr, uint16_t tag, uint8_t status) "dev %d, tag 0x%x, status 0x%x"
+usb_uas_read_ready(int addr, uint16_t tag) "dev %d, tag 0x%x"
+usb_uas_write_ready(int addr, uint16_t tag) "dev %d, tag 0x%x"
+usb_uas_xfer_data(int addr, uint16_t tag, uint32_t copy, uint32_t uoff, uint32_t usize, uint32_t soff, uint32_t ssize) "dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d"
+usb_uas_scsi_data(int addr, uint16_t tag, uint32_t bytes) "dev %d, tag 0x%x, bytes %d"
+usb_uas_scsi_complete(int addr, uint16_t tag, uint32_t status, uint32_t resid) "dev %d, tag 0x%x, status 0x%x, residue %d"
+usb_uas_tmf_abort_task(int addr, uint16_t tag, uint16_t task_tag) "dev %d, tag 0x%x, task-tag 0x%x"
+usb_uas_tmf_logical_unit_reset(int addr, uint16_t tag, int lun) "dev %d, tag 0x%x, lun %d"
+usb_uas_tmf_unsupported(int addr, uint16_t tag, uint32_t function) "dev %d, tag 0x%x, function 0x%x"
+
+# hw/usb/dev-mtp.c
+usb_mtp_reset(int addr) "dev %d"
+usb_mtp_command(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4) "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
+usb_mtp_success(int dev, uint32_t trans, uint32_t arg0, uint32_t arg1) "dev %d, trans 0x%x, args 0x%x, 0x%x"
+usb_mtp_error(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1) "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x"
+usb_mtp_data_in(int dev, uint32_t trans, uint32_t len) "dev %d, trans 0x%x, len %d"
+usb_mtp_xfer(int dev, uint32_t ep, uint32_t dlen, uint32_t plen) "dev %d, ep %d, %d/%d"
+usb_mtp_nak(int dev, uint32_t ep) "dev %d, ep %d"
+usb_mtp_stall(int dev, const char *reason) "dev %d, reason: %s"
+usb_mtp_op_get_device_info(int dev) "dev %d"
+usb_mtp_op_open_session(int dev) "dev %d"
+usb_mtp_op_close_session(int dev) "dev %d"
+usb_mtp_op_get_storage_ids(int dev) "dev %d"
+usb_mtp_op_get_storage_info(int dev) "dev %d"
+usb_mtp_op_get_num_objects(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+usb_mtp_op_get_object_handles(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+usb_mtp_op_get_object_info(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+usb_mtp_op_get_object(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+usb_mtp_op_get_partial_object(int dev, uint32_t handle, const char *path, uint32_t offset, uint32_t length) "dev %d, handle 0x%x, path %s, off %d, len %d"
+usb_mtp_op_unknown(int dev, uint32_t code) "dev %d, command code 0x%x"
+usb_mtp_object_alloc(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+usb_mtp_object_free(int dev, uint32_t handle, const char *path) "dev %d, handle 0x%x, path %s"
+
+# hw/usb/host-libusb.c
+usb_host_open_started(int bus, int addr) "dev %d:%d"
+usb_host_open_success(int bus, int addr) "dev %d:%d"
+usb_host_open_failure(int bus, int addr) "dev %d:%d"
+usb_host_close(int bus, int addr) "dev %d:%d"
+usb_host_attach_kernel(int bus, int addr, int interface) "dev %d:%d, if %d"
+usb_host_detach_kernel(int bus, int addr, int interface) "dev %d:%d, if %d"
+usb_host_set_address(int bus, int addr, int config) "dev %d:%d, address %d"
+usb_host_set_config(int bus, int addr, int config) "dev %d:%d, config %d"
+usb_host_set_interface(int bus, int addr, int interface, int alt) "dev %d:%d, interface %d, alt %d"
+usb_host_claim_interface(int bus, int addr, int config, int interface) "dev %d:%d, config %d, if %d"
+usb_host_release_interface(int bus, int addr, int interface) "dev %d:%d, if %d"
+usb_host_req_control(int bus, int addr, void *p, int req, int value, int index) "dev %d:%d, packet %p, req 0x%x, value %d, index %d"
+usb_host_req_data(int bus, int addr, void *p, int in, int ep, int size) "dev %d:%d, packet %p, in %d, ep %d, size %d"
+usb_host_req_complete(int bus, int addr, void *p, int status, int length) "dev %d:%d, packet %p, status %d, length %d"
+usb_host_req_emulated(int bus, int addr, void *p, int status) "dev %d:%d, packet %p, status %d"
+usb_host_req_canceled(int bus, int addr, void *p) "dev %d:%d, packet %p"
+usb_host_iso_start(int bus, int addr, int ep) "dev %d:%d, ep %d"
+usb_host_iso_stop(int bus, int addr, int ep) "dev %d:%d, ep %d"
+usb_host_iso_out_of_bufs(int bus, int addr, int ep) "dev %d:%d, ep %d"
+usb_host_reset(int bus, int addr) "dev %d:%d"
+usb_host_auto_scan_enabled(void)
+usb_host_auto_scan_disabled(void)
+usb_host_parse_config(int bus, int addr, int value, int active) "dev %d:%d, value %d, active %d"
+usb_host_parse_interface(int bus, int addr, int num, int alt, int active) "dev %d:%d, num %d, alt %d, active %d"
+usb_host_parse_endpoint(int bus, int addr, int ep, const char *dir, const char *type, int active) "dev %d:%d, ep %d, %s, %s, active %d"
+usb_host_parse_error(int bus, int addr, const char *errmsg) "dev %d:%d, msg %s"
+
+# hw/scsi/scsi-bus.c
+scsi_req_alloc(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_req_cancel(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_req_data(int target, int lun, int tag, int len) "target %d lun %d tag %d len %d"
+scsi_req_data_canceled(int target, int lun, int tag, int len) "target %d lun %d tag %d len %d"
+scsi_req_dequeue(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_req_continue(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_req_continue_canceled(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_req_parsed(int target, int lun, int tag, int cmd, int mode, int xfer) "target %d lun %d tag %d command %d dir %d length %d"
+scsi_req_parsed_lba(int target, int lun, int tag, int cmd, uint64_t lba) "target %d lun %d tag %d command %d lba %"PRIu64
+scsi_req_parse_bad(int target, int lun, int tag, int cmd) "target %d lun %d tag %d command %d"
+scsi_req_build_sense(int target, int lun, int tag, int key, int asc, int ascq) "target %d lun %d tag %d key %#02x asc %#02x ascq %#02x"
+scsi_device_set_ua(int target, int lun, int key, int asc, int ascq) "target %d lun %d key %#02x asc %#02x ascq %#02x"
+scsi_report_luns(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_inquiry(int target, int lun, int tag, int cdb1, int cdb2) "target %d lun %d tag %d page %#02x/%#02x"
+scsi_test_unit_ready(int target, int lun, int tag) "target %d lun %d tag %d"
+scsi_request_sense(int target, int lun, int tag) "target %d lun %d tag %d"
+
+# vl.c
+vm_state_notify(int running, int reason) "running %d reason %d"
+load_file(const char *name, const char *path) "name %s location %s"
+runstate_set(int new_state) "new state %d"
+g_malloc(size_t size, void *ptr) "size %zu ptr %p"
+g_realloc(void *ptr, size_t size, void *newptr) "ptr %p size %zu newptr %p"
+g_free(void *ptr) "ptr %p"
+system_wakeup_request(int reason) "reason=%d"
+qemu_system_shutdown_request(void) ""
+qemu_system_powerdown_request(void) ""
+
+# block/qcow2.c
+qcow2_writev_start_req(void *co, int64_t sector, int nb_sectors) "co %p sector %" PRIx64 " nb_sectors %d"
+qcow2_writev_done_req(void *co, int ret) "co %p ret %d"
+qcow2_writev_start_part(void *co) "co %p"
+qcow2_writev_done_part(void *co, int cur_nr_sectors) "co %p cur_nr_sectors %d"
+qcow2_writev_data(void *co, uint64_t offset) "co %p offset %" PRIx64
+
+# block/qcow2-cluster.c
+qcow2_alloc_clusters_offset(void *co, uint64_t offset, int num) "co %p offset %" PRIx64 " num %d"
+qcow2_handle_copied(void *co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes) "co %p guest_offset %" PRIx64 " host_offset %" PRIx64 " bytes %" PRIx64
+qcow2_handle_alloc(void *co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes) "co %p guest_offset %" PRIx64 " host_offset %" PRIx64 " bytes %" PRIx64
+qcow2_do_alloc_clusters_offset(void *co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters) "co %p guest_offset %" PRIx64 " host_offset %" PRIx64 " nb_clusters %d"
+qcow2_cluster_alloc_phys(void *co) "co %p"
+qcow2_cluster_link_l2(void *co, int nb_clusters) "co %p nb_clusters %d"
+
+qcow2_l2_allocate(void *bs, int l1_index) "bs %p l1_index %d"
+qcow2_l2_allocate_get_empty(void *bs, int l1_index) "bs %p l1_index %d"
+qcow2_l2_allocate_write_l2(void *bs, int l1_index) "bs %p l1_index %d"
+qcow2_l2_allocate_write_l1(void *bs, int l1_index) "bs %p l1_index %d"
+qcow2_l2_allocate_done(void *bs, int l1_index, int ret) "bs %p l1_index %d ret %d"
+
+# block/qcow2-cache.c
+qcow2_cache_get(void *co, int c, uint64_t offset, bool read_from_disk) "co %p is_l2_cache %d offset %" PRIx64 " read_from_disk %d"
+qcow2_cache_get_replace_entry(void *co, int c, int i) "co %p is_l2_cache %d index %d"
+qcow2_cache_get_read(void *co, int c, int i) "co %p is_l2_cache %d index %d"
+qcow2_cache_get_done(void *co, int c, int i) "co %p is_l2_cache %d index %d"
+qcow2_cache_flush(void *co, int c) "co %p is_l2_cache %d"
+qcow2_cache_entry_flush(void *co, int c, int i) "co %p is_l2_cache %d index %d"
+
+# block/qed-l2-cache.c
+qed_alloc_l2_cache_entry(void *l2_cache, void *entry) "l2_cache %p entry %p"
+qed_unref_l2_cache_entry(void *entry, int ref) "entry %p ref %d"
+qed_find_l2_cache_entry(void *l2_cache, void *entry, uint64_t offset, int ref) "l2_cache %p entry %p offset %"PRIu64" ref %d"
+
+# block/qed-table.c
+qed_read_table(void *s, uint64_t offset, void *table) "s %p offset %"PRIu64" table %p"
+qed_read_table_cb(void *s, void *table, int ret) "s %p table %p ret %d"
+qed_write_table(void *s, uint64_t offset, void *table, unsigned int index, unsigned int n) "s %p offset %"PRIu64" table %p index %u n %u"
+qed_write_table_cb(void *s, void *table, int flush, int ret) "s %p table %p flush %d ret %d"
+
+# block/qed.c
+qed_need_check_timer_cb(void *s) "s %p"
+qed_start_need_check_timer(void *s) "s %p"
+qed_cancel_need_check_timer(void *s) "s %p"
+qed_aio_complete(void *s, void *acb, int ret) "s %p acb %p ret %d"
+qed_aio_setup(void *s, void *acb, int64_t sector_num, int nb_sectors, void *opaque, int flags) "s %p acb %p sector_num %"PRId64" nb_sectors %d opaque %p flags %#x"
+qed_aio_next_io(void *s, void *acb, int ret, uint64_t cur_pos) "s %p acb %p ret %d cur_pos %"PRIu64
+qed_aio_read_data(void *s, void *acb, int ret, uint64_t offset, size_t len) "s %p acb %p ret %d offset %"PRIu64" len %zu"
+qed_aio_write_data(void *s, void *acb, int ret, uint64_t offset, size_t len) "s %p acb %p ret %d offset %"PRIu64" len %zu"
+qed_aio_write_prefill(void *s, void *acb, uint64_t start, size_t len, uint64_t offset) "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64
+qed_aio_write_postfill(void *s, void *acb, uint64_t start, size_t len, uint64_t offset) "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64
+qed_aio_write_main(void *s, void *acb, int ret, uint64_t offset, size_t len) "s %p acb %p ret %d offset %"PRIu64" len %zu"
+
+# hw/display/g364fb.c
+g364fb_read(uint64_t addr, uint32_t val) "read addr=0x%"PRIx64": 0x%x"
+g364fb_write(uint64_t addr, uint32_t new) "write addr=0x%"PRIx64": 0x%x"
+
+# hw/timer/grlib_gptimer.c
+grlib_gptimer_enable(int id, uint32_t count) "timer:%d set count 0x%x and run"
+grlib_gptimer_disabled(int id, uint32_t config) "timer:%d Timer disable config 0x%x"
+grlib_gptimer_restart(int id, uint32_t reload) "timer:%d reload val: 0x%x"
+grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq) "scaler:0x%x freq: 0x%x"
+grlib_gptimer_hit(int id) "timer:%d HIT"
+grlib_gptimer_readl(int id, uint64_t addr, uint32_t val) "timer:%d addr 0x%"PRIx64" 0x%x"
+grlib_gptimer_writel(int id, uint64_t addr, uint32_t val) "timer:%d addr 0x%"PRIx64" 0x%x"
+
+# hw/intc/grlib_irqmp.c
+grlib_irqmp_check_irqs(uint32_t pend, uint32_t force, uint32_t mask, uint32_t lvl1, uint32_t lvl2) "pend:0x%04x force:0x%04x mask:0x%04x lvl1:0x%04x lvl0:0x%04x"
+grlib_irqmp_ack(int intno) "interrupt:%d"
+grlib_irqmp_set_irq(int irq) "Raise CPU IRQ %d"
+grlib_irqmp_readl_unknown(uint64_t addr) "addr 0x%"PRIx64
+grlib_irqmp_writel_unknown(uint64_t addr, uint32_t value) "addr 0x%"PRIx64" value 0x%x"
+
+# hw/char/grlib_apbuart.c
+grlib_apbuart_event(int event) "event:%d"
+grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value) "addr 0x%"PRIx64" value 0x%x"
+grlib_apbuart_readl_unknown(uint64_t addr) "addr 0x%"PRIx64""
+
+# hw/sparc/leon3.c
+leon3_set_irq(int intno) "Set CPU IRQ %d"
+leon3_reset_irq(int intno) "Reset CPU IRQ %d"
+
+# spice-qemu-char.c
+spice_vmc_write(ssize_t out, int len) "spice wrottn %zd of requested %d"
+spice_vmc_read(int bytes, int len) "spice read %d of requested %d"
+spice_vmc_register_interface(void *scd) "spice vmc registered interface %p"
+spice_vmc_unregister_interface(void *scd) "spice vmc unregistered interface %p"
+spice_vmc_event(int event) "spice vmc event %d"
+
+# hw/intc/lm32_pic.c
+lm32_pic_raise_irq(void) "Raise CPU interrupt"
+lm32_pic_lower_irq(void) "Lower CPU interrupt"
+lm32_pic_interrupt(int irq, int level) "Set IRQ%d %d"
+lm32_pic_set_im(uint32_t im) "im 0x%08x"
+lm32_pic_set_ip(uint32_t ip) "ip 0x%08x"
+lm32_pic_get_im(uint32_t im) "im 0x%08x"
+lm32_pic_get_ip(uint32_t ip) "ip 0x%08x"
+
+# hw/char/lm32_juart.c
+lm32_juart_get_jtx(uint32_t value) "jtx 0x%08x"
+lm32_juart_set_jtx(uint32_t value) "jtx 0x%08x"
+lm32_juart_get_jrx(uint32_t value) "jrx 0x%08x"
+lm32_juart_set_jrx(uint32_t value) "jrx 0x%08x"
+
+# hw/timer/lm32_timer.c
+lm32_timer_memory_write(uint32_t addr, uint32_t value) "addr 0x%08x value 0x%08x"
+lm32_timer_memory_read(uint32_t addr, uint32_t value) "addr 0x%08x value 0x%08x"
+lm32_timer_hit(void) "timer hit"
+lm32_timer_irq_state(int level) "irq state %d"
+
+# hw/char/lm32_uart.c
+lm32_uart_memory_write(uint32_t addr, uint32_t value) "addr 0x%08x value 0x%08x"
+lm32_uart_memory_read(uint32_t addr, uint32_t value) "addr 0x%08x value 0x%08x"
+lm32_uart_irq_state(int level) "irq state %d"
+
+# hw/scsi/megasas.c
+megasas_init_firmware(uint64_t pa) "pa %" PRIx64 " "
+megasas_init_queue(uint64_t queue_pa, int queue_len, uint64_t head, uint64_t tail, uint32_t flags) "queue at %" PRIx64 " len %d head %" PRIx64 " tail %" PRIx64 " flags %x"
+megasas_initq_map_failed(int frame) "scmd %d: failed to map queue"
+megasas_initq_mapped(uint64_t pa) "queue already mapped at %" PRIx64 ""
+megasas_initq_mismatch(int queue_len, int fw_cmds) "queue size %d max fw cmds %d"
+megasas_qf_mapped(unsigned int index) "skip mapped frame %x"
+megasas_qf_new(unsigned int index, uint64_t frame) "frame %x addr %" PRIx64 ""
+megasas_qf_busy(unsigned long pa) "all frames busy for frame %lx"
+megasas_qf_enqueue(unsigned int index, unsigned int count, uint64_t context, unsigned int head, unsigned int tail, int busy) "frame %x count %d context %" PRIx64 " head %x tail %x busy %d"
+megasas_qf_update(unsigned int head, unsigned int tail, unsigned int busy) "head %x tail %x busy %d"
+megasas_qf_map_failed(int cmd, unsigned long frame) "scmd %d: frame %lu"
+megasas_qf_complete_noirq(uint64_t context) "context %" PRIx64 " "
+megasas_qf_complete(uint64_t context, unsigned int head, unsigned int tail, int busy) "context %" PRIx64 " head %x tail %x busy %d"
+megasas_frame_busy(uint64_t addr) "frame %" PRIx64 " busy"
+megasas_unhandled_frame_cmd(int cmd, uint8_t frame_cmd) "scmd %d: MFI cmd %x"
+megasas_handle_scsi(const char *frame, int bus, int dev, int lun, void *sdev, unsigned long size) "%s dev %x/%x/%x sdev %p xfer %lu"
+megasas_scsi_target_not_present(const char *frame, int bus, int dev, int lun) "%s dev %x/%x/%x"
+megasas_scsi_invalid_cdb_len(const char *frame, int bus, int dev, int lun, int len) "%s dev %x/%x/%x invalid cdb len %d"
+megasas_iov_read_overflow(int cmd, int bytes, int len) "scmd %d: %d/%d bytes"
+megasas_iov_write_overflow(int cmd, int bytes, int len) "scmd %d: %d/%d bytes"
+megasas_iov_read_underflow(int cmd, int bytes, int len) "scmd %d: %d/%d bytes"
+megasas_iov_write_underflow(int cmd, int bytes, int len) "scmd %d: %d/%d bytes"
+megasas_scsi_req_alloc_failed(const char *frame, int dev, int lun) "%s dev %x/%x"
+megasas_scsi_read_start(int cmd, int len) "scmd %d: transfer %d bytes of data"
+megasas_scsi_write_start(int cmd, int len) "scmd %d: transfer %d bytes of data"
+megasas_scsi_nodata(int cmd) "scmd %d: no data to be transferred"
+megasas_scsi_complete(int cmd, uint32_t status, int len, int xfer) "scmd %d: status %x, len %u/%u"
+megasas_command_complete(int cmd, uint32_t status, uint32_t resid) "scmd %d: status %x, residual %d"
+megasas_handle_io(int cmd, const char *frame, int dev, int lun, unsigned long lba, unsigned long count) "scmd %d: %s dev %x/%x lba %lx count %lu"
+megasas_io_target_not_present(int cmd, const char *frame, int dev, int lun) "scmd %d: %s dev 1/%x/%x LUN not present"
+megasas_io_read_start(int cmd, unsigned long lba, unsigned long count, unsigned long len) "scmd %d: start LBA %lx %lu blocks (%lu bytes)"
+megasas_io_write_start(int cmd, unsigned long lba, unsigned long count, unsigned long len) "scmd %d: start LBA %lx %lu blocks (%lu bytes)"
+megasas_io_complete(int cmd, uint32_t len) "scmd %d: %d bytes"
+megasas_iovec_sgl_overflow(int cmd, int index, int limit) "scmd %d: iovec count %d limit %d"
+megasas_iovec_sgl_underflow(int cmd, int index) "scmd %d: iovec count %d"
+megasas_iovec_sgl_invalid(int cmd, int index, uint64_t pa, uint32_t len) "scmd %d: element %d pa %" PRIx64 " len %u"
+megasas_iovec_overflow(int cmd, int len, int limit) "scmd %d: len %d limit %d"
+megasas_iovec_underflow(int cmd, int len, int limit) "scmd %d: len %d limit %d"
+megasas_handle_dcmd(int cmd, int opcode) "scmd %d: MFI DCMD opcode %x"
+megasas_finish_dcmd(int cmd, int size) "scmd %d: MFI DCMD wrote %d bytes"
+megasas_dcmd_req_alloc_failed(int cmd, const char *desc) "scmd %d: %s"
+megasas_dcmd_internal_submit(int cmd, const char *desc, int dev) "scmd %d: %s to dev %d"
+megasas_dcmd_internal_finish(int cmd, int opcode, int lun) "scmd %d: cmd %x lun %d"
+megasas_dcmd_internal_invalid(int cmd, int opcode) "scmd %d: DCMD %x"
+megasas_dcmd_unhandled(int cmd, int opcode, int len) "scmd %d: opcode %x, len %d"
+megasas_dcmd_zero_sge(int cmd) "scmd %d: zero DCMD sge count"
+megasas_dcmd_invalid_sge(int cmd, int count) "scmd %d: DCMD sge count %d"
+megasas_dcmd_invalid_xfer_len(int cmd, unsigned long size, unsigned long max) "scmd %d: xfer len %ld, max %ld"
+megasas_dcmd_enter(int cmd, const char *dcmd, int len) "scmd %d: DCMD %s len %d"
+megasas_dcmd_dummy(int cmd, unsigned long size) "scmd %d: xfer len %ld"
+megasas_dcmd_set_fw_time(int cmd, unsigned long time) "scmd %d: Set FW time %lx"
+megasas_dcmd_pd_get_list(int cmd, int num, int max, int offset) "scmd %d: DCMD PD get list: %d / %d PDs, size %d"
+megasas_dcmd_ld_get_list(int cmd, int num, int max) "scmd %d: DCMD LD get list: found %d / %d LDs"
+megasas_dcmd_ld_get_info(int cmd, int ld_id) "scmd %d: dev %d"
+megasas_dcmd_ld_list_query(int cmd, int flags) "scmd %d: query flags %x"
+megasas_dcmd_pd_get_info(int cmd, int pd_id) "scmd %d: dev %d"
+megasas_dcmd_pd_list_query(int cmd, int flags) "scmd %d: query flags %x"
+megasas_dcmd_reset_ld(int cmd, int target_id) "scmd %d: dev %d"
+megasas_dcmd_unsupported(int cmd, unsigned long size) "scmd %d: set properties len %ld"
+megasas_abort_frame(int cmd, int abort_cmd) "scmd %d: frame %x"
+megasas_abort_no_cmd(int cmd, uint64_t context) "scmd %d: no active command for frame context %" PRIx64 ""
+megasas_abort_invalid_context(int cmd, uint64_t context, int abort_cmd) "scmd %d: invalid frame context %" PRIx64 " for abort frame %x"
+megasas_reset(int fw_state) "firmware state %x"
+megasas_init(int sges, int cmds, const char *mode) "Using %d sges, %d cmds, %s mode"
+megasas_msix_raise(int vector) "vector %d"
+megasas_msi_raise(int vector) "vector %d"
+megasas_irq_lower(void) "INTx"
+megasas_irq_raise(void) "INTx"
+megasas_intr_enabled(void) "Interrupts enabled"
+megasas_intr_disabled(void) "Interrupts disabled"
+megasas_msix_enabled(int vector) "vector %d"
+megasas_msi_enabled(int vector) "vector %d"
+megasas_mmio_readl(const char *reg, uint32_t val) "reg %s: 0x%x"
+megasas_mmio_invalid_readl(unsigned long addr) "addr 0x%lx"
+megasas_mmio_writel(const char *reg, uint32_t val) "reg %s: 0x%x"
+megasas_mmio_invalid_writel(uint32_t addr, uint32_t val) "addr 0x%x: 0x%x"
+
+# hw/audio/milkymist-ac97.c
+milkymist_ac97_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_ac97_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_ac97_pulse_irq_crrequest(void) "Pulse IRQ CR request"
+milkymist_ac97_pulse_irq_crreply(void) "Pulse IRQ CR reply"
+milkymist_ac97_pulse_irq_dmaw(void) "Pulse IRQ DMA write"
+milkymist_ac97_pulse_irq_dmar(void) "Pulse IRQ DMA read"
+milkymist_ac97_in_cb(int avail, uint32_t remaining) "avail %d remaining %u"
+milkymist_ac97_in_cb_transferred(int transferred) "transferred %d"
+milkymist_ac97_out_cb(int free, uint32_t remaining) "free %d remaining %u"
+milkymist_ac97_out_cb_transferred(int transferred) "transferred %d"
+
+# hw/misc/milkymist-hpdmc.c
+milkymist_hpdmc_memory_read(uint32_t addr, uint32_t value) "addr=%08x value=%08x"
+milkymist_hpdmc_memory_write(uint32_t addr, uint32_t value) "addr=%08x value=%08x"
+
+# hw/sd/milkymist-memcard.c
+milkymist_memcard_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_memcard_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+
+# hw/net/milkymist-minimac2.c
+milkymist_minimac2_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_minimac2_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_minimac2_mdio_write(uint8_t phy_addr, uint8_t addr, uint16_t value) "phy_addr %02x addr %02x value %04x"
+milkymist_minimac2_mdio_read(uint8_t phy_addr, uint8_t addr, uint16_t value) "phy_addr %02x addr %02x value %04x"
+milkymist_minimac2_tx_frame(uint32_t length) "length %u"
+milkymist_minimac2_rx_frame(const void *buf, uint32_t length) "buf %p length %u"
+milkymist_minimac2_drop_rx_frame(const void *buf) "buf %p"
+milkymist_minimac2_rx_transfer(const void *buf, uint32_t length) "buf %p length %d"
+milkymist_minimac2_raise_irq_rx(void) "Raise IRQ RX"
+milkymist_minimac2_lower_irq_rx(void) "Lower IRQ RX"
+milkymist_minimac2_pulse_irq_tx(void) "Pulse IRQ TX"
+
+# hw/misc/milkymist-pfpu.c
+milkymist_pfpu_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_pfpu_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_pfpu_vectout(uint32_t a, uint32_t b, uint32_t dma_ptr) "a %08x b %08x dma_ptr %08x"
+milkymist_pfpu_pulse_irq(void) "Pulse IRQ"
+
+# hw/input/milkymist-softusb.c
+milkymist_softusb_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_softusb_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_softusb_mevt(uint8_t m) "m %d"
+milkymist_softusb_kevt(uint8_t m) "m %d"
+milkymist_softusb_pulse_irq(void) "Pulse IRQ"
+
+# hw/timer/milkymist-sysctl.c
+milkymist_sysctl_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_sysctl_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_sysctl_icap_write(uint32_t value) "value %08x"
+milkymist_sysctl_start_timer0(void) "Start timer0"
+milkymist_sysctl_stop_timer0(void) "Stop timer0"
+milkymist_sysctl_start_timer1(void) "Start timer1"
+milkymist_sysctl_stop_timer1(void) "Stop timer1"
+milkymist_sysctl_pulse_irq_timer0(void) "Pulse IRQ Timer0"
+milkymist_sysctl_pulse_irq_timer1(void) "Pulse IRQ Timer1"
+
+# hw/display/milkymist-tmu2.c
+milkymist_tmu2_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_tmu2_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_tmu2_start(void) "Start TMU"
+milkymist_tmu2_pulse_irq(void) "Pulse IRQ"
+
+# hw/char/milkymist-uart.c
+milkymist_uart_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_uart_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_uart_raise_irq(void) "Raise IRQ"
+milkymist_uart_lower_irq(void) "Lower IRQ"
+
+# hw/display/milkymist-vgafb.c
+milkymist_vgafb_memory_read(uint32_t addr, uint32_t value) "addr %08x value %08x"
+milkymist_vgafb_memory_write(uint32_t addr, uint32_t value) "addr %08x value %08x"
+
+# hw/net/mipsnet.c
+mipsnet_send(uint32_t size) "sending len=%u"
+mipsnet_receive(uint32_t size) "receiving len=%u"
+mipsnet_read(uint64_t addr, uint32_t val) "read addr=0x%" PRIx64 " val=0x%x"
+mipsnet_write(uint64_t addr, uint64_t val) "write addr=0x%" PRIx64 " val=0x%" PRIx64 ""
+mipsnet_irq(uint32_t isr, uint32_t intctl) "set irq to %d (%02x)"
+
+# hw/isa/pc87312.c
+pc87312_io_read(uint32_t addr, uint32_t val) "read addr=%x val=%x"
+pc87312_io_write(uint32_t addr, uint32_t val) "write addr=%x val=%x"
+pc87312_info_floppy(uint32_t base) "base 0x%x"
+pc87312_info_ide(uint32_t base) "base 0x%x"
+pc87312_info_parallel(uint32_t base, uint32_t irq) "base 0x%x, irq %u"
+pc87312_info_serial(int n, uint32_t base, uint32_t irq) "id=%d, base 0x%x, irq %u"
+
+# hw/scsi/vmw_pvscsi.c
+pvscsi_ring_init_data(uint32_t txr_len_log2, uint32_t rxr_len_log2) "TX/RX rings logarithms set to %d/%d"
+pvscsi_ring_init_msg(uint32_t len_log2) "MSG ring logarithm set to %d"
+pvscsi_ring_flush_cmp(uint64_t filled_cmp_ptr) "new production counter of completion ring is 0x%"PRIx64""
+pvscsi_ring_flush_msg(uint64_t filled_cmp_ptr) "new production counter of message ring is 0x%"PRIx64""
+pvscsi_update_irq_level(bool raise, uint64_t mask, uint64_t status) "interrupt level set to %d (MASK: 0x%"PRIx64", STATUS: 0x%"PRIx64")"
+pvscsi_update_irq_msi(void) "sending MSI notification"
+pvscsi_cmp_ring_put(unsigned long addr) "got completion descriptor 0x%lx"
+pvscsi_msg_ring_put(unsigned long addr) "got message descriptor 0x%lx"
+pvscsi_complete_request(uint64_t context, uint64_t len, uint8_t sense_key) "completion: ctx: 0x%"PRIx64", len: 0x%"PRIx64", sense key: %u"
+pvscsi_get_sg_list(int nsg, size_t size) "get SG list: depth: %u, size: %zu"
+pvscsi_get_next_sg_elem(uint32_t flags) "unknown flags in SG element (val: 0x%x)"
+pvscsi_command_complete_not_found(uint32_t tag) "can't find request for tag 0x%x"
+pvscsi_command_complete_data_run(void) "not all data required for command transferred"
+pvscsi_command_complete_sense_len(int len) "sense information length is %d bytes"
+pvscsi_convert_sglist(uint64_t context, unsigned long addr, uint32_t resid) "element: ctx: 0x%"PRIx64" addr: 0x%lx, len: %ul"
+pvscsi_process_req_descr(uint8_t cmd, uint64_t ctx) "SCSI cmd 0x%x, ctx: 0x%"PRIx64""
+pvscsi_process_req_descr_unknown_device(void) "command directed to unknown device rejected"
+pvscsi_process_req_descr_invalid_dir(void) "command with invalid transfer direction rejected"
+pvscsi_process_io(unsigned long addr) "got descriptor 0x%lx"
+pvscsi_on_cmd_noimpl(const char* cmd) "unimplemented command %s ignored"
+pvscsi_on_cmd_reset_dev(uint32_t tgt, int lun, void* dev) "PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]"
+pvscsi_on_cmd_arrived(const char* cmd) "command %s arrived"
+pvscsi_on_cmd_abort(uint64_t ctx, uint32_t tgt) "command PVSCSI_CMD_ABORT_CMD for ctx 0x%"PRIx64", target %u"
+pvscsi_on_cmd_unknown(uint64_t cmd_id) "unknown command %"PRIx64""
+pvscsi_on_cmd_unknown_data(uint32_t data) "data for unknown command 0x:%x"
+pvscsi_io_write(const char* cmd, uint64_t val) "%s write: %"PRIx64""
+pvscsi_io_write_unknown(unsigned long addr, unsigned sz, uint64_t val) "unknown write address: 0x%lx size: %u bytes value: 0x%"PRIx64""
+pvscsi_io_read(const char* cmd, uint64_t status) "%s read: 0x%"PRIx64""
+pvscsi_io_read_unknown(unsigned long addr, unsigned sz) "unknown read address: 0x%lx size: %u bytes"
+pvscsi_init_msi_fail(int res) "failed to initialize MSI, error %d"
+pvscsi_state(const char* state) "starting %s ..."
+pvscsi_tx_rings_ppn(const char* label, uint64_t ppn) "%s page: %"PRIx64""
+pvscsi_tx_rings_num_pages(const char* label, uint32_t num) "Number of %s pages: %u"
+
+# xen-hvm.c
+xen_ram_alloc(unsigned long ram_addr, unsigned long size) "requested: %#lx, size %#lx"
+xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty) "%#"PRIx64" size %#lx, log_dirty %i"
+xen_ioreq_server_create(uint32_t id) "id: %u"
+xen_ioreq_server_destroy(uint32_t id) "id: %u"
+xen_ioreq_server_state(uint32_t id, bool enable) "id: %u: enable: %i"
+xen_map_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr) "id: %u start: %#"PRIx64" end: %#"PRIx64
+xen_unmap_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr) "id: %u start: %#"PRIx64" end: %#"PRIx64
+xen_map_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr) "id: %u start: %#"PRIx64" end: %#"PRIx64
+xen_unmap_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr) "id: %u start: %#"PRIx64" end: %#"PRIx64
+xen_map_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func) "id: %u bdf: %02x.%02x.%02x"
+xen_unmap_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func) "id: %u bdf: %02x.%02x.%02x"
+
+# xen-mapcache.c
+xen_map_cache(uint64_t phys_addr) "want %#"PRIx64
+xen_remap_bucket(uint64_t index) "index %#"PRIx64
+xen_map_cache_return(void* ptr) "%p"
+
+# hw/i386/xen/xen_platform.c
+xen_platform_log(char *s) "xen platform: %s"
+
+# qemu-coroutine.c
+qemu_coroutine_enter(void *from, void *to, void *opaque) "from %p to %p opaque %p"
+qemu_coroutine_yield(void *from, void *to) "from %p to %p"
+qemu_coroutine_terminate(void *co) "self %p"
+
+# qemu-coroutine-lock.c
+qemu_co_queue_run_restart(void *co) "co %p"
+qemu_co_queue_next(void *nxt) "next %p"
+qemu_co_mutex_lock_entry(void *mutex, void *self) "mutex %p self %p"
+qemu_co_mutex_lock_return(void *mutex, void *self) "mutex %p self %p"
+qemu_co_mutex_unlock_entry(void *mutex, void *self) "mutex %p self %p"
+qemu_co_mutex_unlock_return(void *mutex, void *self) "mutex %p self %p"
+
+# hw/char/escc.c
+escc_put_queue(char channel, int b) "channel %c put: 0x%02x"
+escc_get_queue(char channel, int val) "channel %c get 0x%02x"
+escc_update_irq(int irq) "IRQ = %d"
+escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits) "channel %c: speed=%d parity=%c data=%d stop=%d"
+escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val) "Write channel %c, reg[%d] = %2.2x"
+escc_mem_writeb_data(char channel, uint32_t val) "Write channel %c, ch %d"
+escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val) "Read channel %c, reg[%d] = %2.2x"
+escc_mem_readb_data(char channel, uint32_t ret) "Read channel %c, ch %d"
+escc_serial_receive_byte(char channel, int ch) "channel %c put ch %d"
+escc_sunkbd_event_in(int ch, const char *name, int down) "QKeyCode 0x%2.2x [%s], down %d"
+escc_sunkbd_event_out(int ch) "Translated keycode 0x%2.2x"
+escc_kbd_command(int val) "Command %d"
+escc_sunmouse_event(int dx, int dy, int buttons_state) "dx=%d dy=%d buttons=%01x"
+
+# hw/scsi/esp.c
+esp_error_fifo_overrun(void) "FIFO overrun"
+esp_error_unhandled_command(uint32_t val) "unhandled command (%2.2x)"
+esp_error_invalid_write(uint32_t val, uint32_t addr) "invalid write of 0x%02x at [0x%x]"
+esp_raise_irq(void) "Raise IRQ"
+esp_lower_irq(void) "Lower IRQ"
+esp_dma_enable(void) "Raise enable"
+esp_dma_disable(void) "Lower enable"
+esp_get_cmd(uint32_t dmalen, int target) "len %d target %d"
+esp_do_busid_cmd(uint8_t busid) "busid 0x%x"
+esp_handle_satn_stop(uint32_t cmdlen) "cmdlen %d"
+esp_write_response(uint32_t status) "Transfer status (status=%d)"
+esp_do_dma(uint32_t cmdlen, uint32_t len) "command len %d + %d"
+esp_command_complete(void) "SCSI Command complete"
+esp_command_complete_unexpected(void) "SCSI command completed unexpectedly"
+esp_command_complete_fail(void) "Command failed"
+esp_transfer_data(uint32_t dma_left, int32_t ti_size) "transfer %d/%d"
+esp_handle_ti(uint32_t minlen) "Transfer Information len %d"
+esp_handle_ti_cmd(uint32_t cmdlen) "command len %d"
+esp_mem_readb(uint32_t saddr, uint8_t reg) "reg[%d]: 0x%2.2x"
+esp_mem_writeb(uint32_t saddr, uint8_t reg, uint32_t val) "reg[%d]: 0x%2.2x -> 0x%2.2x"
+esp_mem_writeb_cmd_nop(uint32_t val) "NOP (%2.2x)"
+esp_mem_writeb_cmd_flush(uint32_t val) "Flush FIFO (%2.2x)"
+esp_mem_writeb_cmd_reset(uint32_t val) "Chip reset (%2.2x)"
+esp_mem_writeb_cmd_bus_reset(uint32_t val) "Bus reset (%2.2x)"
+esp_mem_writeb_cmd_iccs(uint32_t val) "Initiator Command Complete Sequence (%2.2x)"
+esp_mem_writeb_cmd_msgacc(uint32_t val) "Message Accepted (%2.2x)"
+esp_mem_writeb_cmd_pad(uint32_t val) "Transfer padding (%2.2x)"
+esp_mem_writeb_cmd_satn(uint32_t val) "Set ATN (%2.2x)"
+esp_mem_writeb_cmd_rstatn(uint32_t val) "Reset ATN (%2.2x)"
+esp_mem_writeb_cmd_sel(uint32_t val) "Select without ATN (%2.2x)"
+esp_mem_writeb_cmd_selatn(uint32_t val) "Select with ATN (%2.2x)"
+esp_mem_writeb_cmd_selatns(uint32_t val) "Select with ATN & stop (%2.2x)"
+esp_mem_writeb_cmd_ensel(uint32_t val) "Enable selection (%2.2x)"
+esp_mem_writeb_cmd_dissel(uint32_t val) "Disable selection (%2.2x)"
+
+# hw/scsi/esp-pci.c
+esp_pci_error_invalid_dma_direction(void) "invalid DMA transfer direction"
+esp_pci_error_invalid_read(uint32_t reg) "read access outside bounds (reg 0x%x)"
+esp_pci_error_invalid_write(uint32_t reg) "write access outside bounds (reg 0x%x)"
+esp_pci_error_invalid_write_dma(uint32_t val, uint32_t addr) "invalid write of 0x%02x at [0x%x]"
+esp_pci_dma_read(uint32_t saddr, uint32_t reg) "reg[%d]: 0x%8.8x"
+esp_pci_dma_write(uint32_t saddr, uint32_t reg, uint32_t val) "reg[%d]: 0x%8.8x -> 0x%8.8x"
+esp_pci_dma_idle(uint32_t val) "IDLE (%.8x)"
+esp_pci_dma_blast(uint32_t val) "BLAST (%.8x)"
+esp_pci_dma_abort(uint32_t val) "ABORT (%.8x)"
+esp_pci_dma_start(uint32_t val) "START (%.8x)"
+esp_pci_sbac_read(uint32_t reg) "sbac: 0x%8.8x"
+esp_pci_sbac_write(uint32_t reg, uint32_t val) "sbac: 0x%8.8x -> 0x%8.8x"
+
+# monitor.c
+handle_qmp_command(void *mon, const char *cmd_name) "mon %p cmd_name \"%s\""
+monitor_protocol_emitter(void *mon) "mon %p"
+monitor_protocol_event_handler(uint32_t event, void *data, uint64_t last, uint64_t now) "event=%d data=%p last=%" PRId64 " now=%" PRId64
+monitor_protocol_event_emit(uint32_t event, void *data) "event=%d data=%p"
+monitor_protocol_event_queue(uint32_t event, void *data, uint64_t rate, uint64_t last, uint64_t now) "event=%d data=%p rate=%" PRId64 " last=%" PRId64 " now=%" PRId64
+monitor_protocol_event_throttle(uint32_t event, uint64_t rate) "event=%d rate=%" PRId64
+
+# hw/net/opencores_eth.c
+open_eth_mii_write(unsigned idx, uint16_t v) "MII[%02x] <- %04x"
+open_eth_mii_read(unsigned idx, uint16_t v) "MII[%02x] -> %04x"
+open_eth_update_irq(uint32_t v) "IRQ <- %x"
+open_eth_receive(unsigned len) "RX: len: %u"
+open_eth_receive_mcast(unsigned idx, uint32_t h0, uint32_t h1) "MCAST: idx = %u, hash: %08x:%08x"
+open_eth_receive_reject(void) "RX: rejected"
+open_eth_receive_desc(uint32_t addr, uint32_t len_flags) "RX: %08x, len_flags: %08x"
+open_eth_start_xmit(uint32_t addr, unsigned len, unsigned tx_len) "TX: %08x, len: %u, tx_len: %u"
+open_eth_reg_read(uint32_t addr, uint32_t v) "MAC[%02x] -> %08x"
+open_eth_reg_write(uint32_t addr, uint32_t v) "MAC[%02x] <- %08x"
+open_eth_desc_read(uint32_t addr, uint32_t v) "DESC[%04x] -> %08x"
+open_eth_desc_write(uint32_t addr, uint32_t v) "DESC[%04x] <- %08x"
+
+# hw/9pfs/virtio-9p.c
+v9fs_rerror(uint16_t tag, uint8_t id, int err) "tag %d id %d err %d"
+v9fs_version(uint16_t tag, uint8_t id, int32_t msize, char* version) "tag %d id %d msize %d version %s"
+v9fs_version_return(uint16_t tag, uint8_t id, int32_t msize, char* version) "tag %d id %d msize %d version %s"
+v9fs_attach(uint16_t tag, uint8_t id, int32_t fid, int32_t afid, char* uname, char* aname) "tag %u id %u fid %d afid %d uname %s aname %s"
+v9fs_attach_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path) "tag %d id %d type %d version %d path %"PRId64""
+v9fs_stat(uint16_t tag, uint8_t id, int32_t fid) "tag %d id %d fid %d"
+v9fs_stat_return(uint16_t tag, uint8_t id, int32_t mode, int32_t atime, int32_t mtime, int64_t length) "tag %d id %d stat={mode %d atime %d mtime %d length %"PRId64"}"
+v9fs_getattr(uint16_t tag, uint8_t id, int32_t fid, uint64_t request_mask) "tag %d id %d fid %d request_mask %"PRIu64""
+v9fs_getattr_return(uint16_t tag, uint8_t id, uint64_t result_mask, uint32_t mode, uint32_t uid, uint32_t gid) "tag %d id %d getattr={result_mask %"PRId64" mode %u uid %u gid %u}"
+v9fs_walk(uint16_t tag, uint8_t id, int32_t fid, int32_t newfid, uint16_t nwnames) "tag %d id %d fid %d newfid %d nwnames %d"
+v9fs_walk_return(uint16_t tag, uint8_t id, uint16_t nwnames, void* qids) "tag %d id %d nwnames %d qids %p"
+v9fs_open(uint16_t tag, uint8_t id, int32_t fid, int32_t mode) "tag %d id %d fid %d mode %d"
+v9fs_open_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int iounit) "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d"
+v9fs_lcreate(uint16_t tag, uint8_t id, int32_t dfid, int32_t flags, int32_t mode, uint32_t gid) "tag %d id %d dfid %d flags %d mode %d gid %u"
+v9fs_lcreate_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int32_t iounit) "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d"
+v9fs_fsync(uint16_t tag, uint8_t id, int32_t fid, int datasync) "tag %d id %d fid %d datasync %d"
+v9fs_clunk(uint16_t tag, uint8_t id, int32_t fid) "tag %d id %d fid %d"
+v9fs_read(uint16_t tag, uint8_t id, int32_t fid, uint64_t off, uint32_t max_count) "tag %d id %d fid %d off %"PRIu64" max_count %u"
+v9fs_read_return(uint16_t tag, uint8_t id, int32_t count, ssize_t err) "tag %d id %d count %d err %zd"
+v9fs_readdir(uint16_t tag, uint8_t id, int32_t fid, uint64_t offset, uint32_t max_count) "tag %d id %d fid %d offset %"PRIu64" max_count %u"
+v9fs_readdir_return(uint16_t tag, uint8_t id, uint32_t count, ssize_t retval) "tag %d id %d count %u retval %zd"
+v9fs_write(uint16_t tag, uint8_t id, int32_t fid, uint64_t off, uint32_t count, int cnt) "tag %d id %d fid %d off %"PRIu64" count %u cnt %d"
+v9fs_write_return(uint16_t tag, uint8_t id, int32_t total, ssize_t err) "tag %d id %d total %d err %zd"
+v9fs_create(uint16_t tag, uint8_t id, int32_t fid, char* name, int32_t perm, int8_t mode) "tag %d id %d fid %d name %s perm %d mode %d"
+v9fs_create_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int iounit) "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d"
+v9fs_symlink(uint16_t tag, uint8_t id, int32_t fid,  char* name, char* symname, uint32_t gid) "tag %d id %d fid %d name %s symname %s gid %u"
+v9fs_symlink_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path) "tag %d id %d qid={type %d version %d path %"PRId64"}"
+v9fs_flush(uint16_t tag, uint8_t id, int16_t flush_tag) "tag %d id %d flush_tag %d"
+v9fs_link(uint16_t tag, uint8_t id, int32_t dfid, int32_t oldfid, char* name) "tag %d id %d dfid %d oldfid %d name %s"
+v9fs_remove(uint16_t tag, uint8_t id, int32_t fid) "tag %d id %d fid %d"
+v9fs_wstat(uint16_t tag, uint8_t id, int32_t fid, int32_t mode, int32_t atime, int32_t mtime) "tag %u id %u fid %d stat={mode %d atime %d mtime %d}"
+v9fs_mknod(uint16_t tag, uint8_t id, int32_t fid, int mode, int major, int minor) "tag %d id %d fid %d mode %d major %d minor %d"
+v9fs_mknod_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path) "tag %d id %d qid={type %d version %d path %"PRId64"}"
+v9fs_lock(uint16_t tag, uint8_t id, int32_t fid, uint8_t type, uint64_t start, uint64_t length) "tag %d id %d fid %d type %d start %"PRIu64" length %"PRIu64""
+v9fs_lock_return(uint16_t tag, uint8_t id, int8_t status) "tag %d id %d status %d"
+v9fs_getlock(uint16_t tag, uint8_t id, int32_t fid, uint8_t type, uint64_t start, uint64_t length)"tag %d id %d fid %d type %d start %"PRIu64" length %"PRIu64""
+v9fs_getlock_return(uint16_t tag, uint8_t id, uint8_t type, uint64_t start, uint64_t length, uint32_t proc_id) "tag %d id %d type %d start %"PRIu64" length %"PRIu64" proc_id %u"
+v9fs_mkdir(uint16_t tag, uint8_t id, int32_t fid, char* name, int mode, uint32_t gid) "tag %u id %u fid %d name %s mode %d gid %u"
+v9fs_mkdir_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int err) "tag %u id %u qid={type %d version %d path %"PRId64"} err %d"
+v9fs_xattrwalk(uint16_t tag, uint8_t id, int32_t fid, int32_t newfid, char* name) "tag %d id %d fid %d newfid %d name %s"
+v9fs_xattrwalk_return(uint16_t tag, uint8_t id, int64_t size) "tag %d id %d size %"PRId64""
+v9fs_xattrcreate(uint16_t tag, uint8_t id, int32_t fid, char* name, int64_t size, int flags) "tag %d id %d fid %d name %s size %"PRId64" flags %d"
+v9fs_readlink(uint16_t tag, uint8_t id, int32_t fid) "tag %d id %d fid %d"
+v9fs_readlink_return(uint16_t tag, uint8_t id, char* target) "tag %d id %d name %s"
+
+# target-sparc/mmu_helper.c
+mmu_helper_dfault(uint64_t address, uint64_t context, int mmu_idx, uint32_t tl) "DFAULT at %"PRIx64" context %"PRIx64" mmu_idx=%d tl=%d"
+mmu_helper_dprot(uint64_t address, uint64_t context, int mmu_idx, uint32_t tl) "DPROT at %"PRIx64" context %"PRIx64" mmu_idx=%d tl=%d"
+mmu_helper_dmiss(uint64_t address, uint64_t context) "DMISS at %"PRIx64" context %"PRIx64""
+mmu_helper_tfault(uint64_t address, uint64_t context) "TFAULT at %"PRIx64" context %"PRIx64""
+mmu_helper_tmiss(uint64_t address, uint64_t context) "TMISS at %"PRIx64" context %"PRIx64""
+mmu_helper_get_phys_addr_code(uint32_t tl, int mmu_idx, uint64_t prim_context, uint64_t sec_context, uint64_t address) "tl=%d mmu_idx=%d primary context=%"PRIx64" secondary context=%"PRIx64" address=%"PRIx64""
+mmu_helper_get_phys_addr_data(uint32_t tl, int mmu_idx, uint64_t prim_context, uint64_t sec_context, uint64_t address) "tl=%d mmu_idx=%d primary context=%"PRIx64" secondary context=%"PRIx64" address=%"PRIx64""
+mmu_helper_mmu_fault(uint64_t address, uint64_t paddr, int mmu_idx, uint32_t tl, uint64_t prim_context, uint64_t sec_context) "Translate at %"PRIx64" -> %"PRIx64", mmu_idx=%d tl=%d primary context=%"PRIx64" secondary context=%"PRIx64""
+
+# target-sparc/int64_helper.c
+int_helper_set_softint(uint32_t softint) "new %08x"
+int_helper_clear_softint(uint32_t softint) "new %08x"
+int_helper_write_softint(uint32_t softint) "new %08x"
+
+# target-sparc/int32_helper.c
+int_helper_icache_freeze(void) "Instruction cache: freeze"
+int_helper_dcache_freeze(void) "Data cache: freeze"
+
+# target-sparc/win_helper.c
+win_helper_gregset_error(uint32_t pstate) "ERROR in get_gregset: active pstate bits=%x"
+win_helper_switch_pstate(uint32_t pstate_regs, uint32_t new_pstate_regs) "change_pstate: switching regs old=%x new=%x"
+win_helper_no_switch_pstate(uint32_t new_pstate_regs) "change_pstate: regs new=%x (unchanged)"
+win_helper_wrpil(uint32_t psrpil, uint32_t new_pil) "old=%x new=%x"
+win_helper_done(uint32_t tl) "tl=%d"
+win_helper_retry(uint32_t tl) "tl=%d"
+
+# dma-helpers.c
+dma_blk_io(void *dbs, void *bs, int64_t sector_num, bool to_dev) "dbs=%p bs=%p sector_num=%" PRId64 " to_dev=%d"
+dma_aio_cancel(void *dbs) "dbs=%p"
+dma_complete(void *dbs, int ret, void *cb) "dbs=%p ret=%d cb=%p"
+dma_blk_cb(void *dbs, int ret) "dbs=%p ret=%d"
+dma_map_wait(void *dbs) "dbs=%p"
+
+# ui/console.c
+console_gfx_new(void) ""
+console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params) "escape sequence CSI%d;%d%c, %d parameters"
+console_putchar_unhandled(int ch) "unhandled escape character '%c'"
+console_txt_new(int w, int h) "%dx%d"
+console_select(int nr) "%d"
+console_refresh(int interval) "interval %d ms"
+displaysurface_create(void *display_surface, int w, int h) "surface=%p, %dx%d"
+displaysurface_create_from(void *display_surface, int w, int h, uint32_t format) "surface=%p, %dx%d, format 0x%x"
+displaysurface_free(void *display_surface) "surface=%p"
+displaychangelistener_register(void *dcl, const char *name) "%p [ %s ]"
+displaychangelistener_unregister(void *dcl, const char *name) "%p [ %s ]"
+ppm_save(const char *filename, void *display_surface) "%s surface=%p"
+
+# ui/gtk.c
+gd_switch(const char *tab, int width, int height) "tab=%s, width=%d, height=%d"
+gd_update(const char *tab, int x, int y, int w, int h) "tab=%s, x=%d, y=%d, w=%d, h=%d"
+gd_key_event(const char *tab, int gdk_keycode, int qemu_keycode, const char *action) "tab=%s, translated GDK keycode %d to QEMU keycode %d (%s)"
+gd_grab(const char *tab, const char *device, bool on) "tab=%s, %s %d"
+
+# ui/vnc.c
+vnc_key_guest_leds(bool caps, bool num, bool scroll) "caps %d, num %d, scroll %d"
+vnc_key_map_init(const char *layout) "%s"
+vnc_key_event_ext(bool down, int sym, int keycode, const char *name) "down %d, sym 0x%x, keycode 0x%x [%s]"
+vnc_key_event_map(bool down, int sym, int keycode, const char *name) "down %d, sym 0x%x -> keycode 0x%x [%s]"
+vnc_key_sync_numlock(bool on) "%d"
+vnc_key_sync_capslock(bool on) "%d"
+
+# ui/input.c
+input_event_key_number(int conidx, int number, const char *qcode, bool down) "con %d, key number 0x%x [%s], down %d"
+input_event_key_qcode(int conidx, const char *qcode, bool down) "con %d, key qcode %s, down %d"
+input_event_btn(int conidx, const char *btn, bool down) "con %d, button %s, down %d"
+input_event_rel(int conidx, const char *axis, int value) "con %d, axis %s, value %d"
+input_event_abs(int conidx, const char *axis, int value) "con %d, axis %s, value 0x%x"
+input_event_sync(void) ""
+input_mouse_mode(int absolute) "absolute %d"
+
+# hw/display/vmware_vga.c
+vmware_value_read(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_value_write(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_palette_read(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_palette_write(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_scratch_read(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_scratch_write(uint32_t index, uint32_t value) "index %d, value 0x%x"
+vmware_setmode(uint32_t w, uint32_t h, uint32_t bpp) "%dx%d @ %d bpp"
+
+# savevm.c
+qemu_loadvm_state_section(unsigned int section_type) "%d"
+qemu_loadvm_state_section_partend(uint32_t section_id) "%u"
+qemu_loadvm_state_section_startfull(uint32_t section_id, const char *idstr, uint32_t instance_id, uint32_t version_id) "%u(%s) %u %u"
+savevm_section_start(const char *id, unsigned int section_id) "%s, section_id %u"
+savevm_section_end(const char *id, unsigned int section_id, int ret) "%s, section_id %u -> %d"
+savevm_state_begin(void) ""
+savevm_state_iterate(void) ""
+savevm_state_complete(void) ""
+savevm_state_cancel(void) ""
+vmstate_save(const char *idstr, const char *vmsd_name) "%s, %s"
+vmstate_load(const char *idstr, const char *vmsd_name) "%s, %s"
+qemu_announce_self_iter(const char *mac) "%s"
+
+# vmstate.c
+vmstate_load_field_error(const char *field, int ret) "field \"%s\" load failed, ret = %d"
+vmstate_load_state(const char *name, int version_id) "%s v%d"
+vmstate_load_state_end(const char *name, const char *reason, int val) "%s %s/%d"
+vmstate_load_state_field(const char *name, const char *field) "%s:%s"
+vmstate_subsection_load(const char *parent) "%s"
+vmstate_subsection_load_bad(const char *parent,  const char *sub) "%s: %s"
+vmstate_subsection_load_good(const char *parent) "%s"
+
+# qemu-file.c
+qemu_file_fclose(void) ""
+
+# arch_init.c
+migration_bitmap_sync_start(void) ""
+migration_bitmap_sync_end(uint64_t dirty_pages) "dirty_pages %" PRIu64""
+migration_throttle(void) ""
+
+# hw/display/qxl.c
+disable qxl_interface_set_mm_time(int qid, uint32_t mm_time) "%d %d"
+disable qxl_io_write_vga(int qid, const char *mode, uint32_t addr, uint32_t val) "%d %s addr=%u val=%u"
+qxl_create_guest_primary(int qid, uint32_t width, uint32_t height, uint64_t mem, uint32_t format, uint32_t position) "%d %ux%u mem=%" PRIx64 " %u,%u"
+qxl_create_guest_primary_rest(int qid, int32_t stride, uint32_t type, uint32_t flags) "%d %d,%d,%d"
+qxl_destroy_primary(int qid) "%d"
+qxl_enter_vga_mode(int qid) "%d"
+qxl_exit_vga_mode(int qid) "%d"
+qxl_hard_reset(int qid, int64_t loadvm) "%d loadvm=%"PRId64""
+qxl_interface_async_complete_io(int qid, uint32_t current_async, void *cookie) "%d current=%d cookie=%p"
+qxl_interface_attach_worker(int qid) "%d"
+qxl_interface_get_init_info(int qid) "%d"
+qxl_interface_set_compression_level(int qid, int64_t level) "%d %"PRId64
+qxl_interface_update_area_complete(int qid, uint32_t surface_id, uint32_t dirty_left, uint32_t dirty_right, uint32_t dirty_top, uint32_t dirty_bottom) "%d surface=%d [%d,%d,%d,%d]"
+qxl_interface_update_area_complete_rest(int qid, uint32_t num_updated_rects) "%d #=%d"
+qxl_interface_update_area_complete_overflow(int qid, int max) "%d max=%d"
+qxl_interface_update_area_complete_schedule_bh(int qid, uint32_t num_dirty) "%d #dirty=%d"
+qxl_io_destroy_primary_ignored(int qid, const char *mode) "%d %s"
+qxl_io_log(int qid, const uint8_t *log_buf) "%d %s"
+qxl_io_read_unexpected(int qid) "%d"
+qxl_io_unexpected_vga_mode(int qid, uint64_t addr, uint64_t val, const char *desc) "%d 0x%"PRIx64"=%"PRIu64" (%s)"
+qxl_io_write(int qid, const char *mode, uint64_t addr, const char *aname, uint64_t val, unsigned size, int async) "%d %s addr=%"PRIu64 " (%s) val=%"PRIu64" size=%u async=%d"
+qxl_memslot_add_guest(int qid, uint32_t slot_id, uint64_t guest_start, uint64_t guest_end) "%d %u: guest phys 0x%"PRIx64 " - 0x%" PRIx64
+qxl_post_load(int qid, const char *mode) "%d %s"
+qxl_pre_load(int qid) "%d"
+qxl_pre_save(int qid) "%d"
+qxl_reset_surfaces(int qid) "%d"
+qxl_ring_command_check(int qid, const char *mode) "%d %s"
+qxl_ring_command_get(int qid, const char *mode) "%d %s"
+qxl_ring_command_req_notification(int qid) "%d"
+qxl_ring_cursor_check(int qid, const char *mode) "%d %s"
+qxl_ring_cursor_get(int qid, const char *mode) "%d %s"
+qxl_ring_cursor_req_notification(int qid) "%d"
+qxl_ring_res_push(int qid, const char *mode, uint32_t surface_count, uint32_t free_res, void *last_release, const char *notify) "%d %s s#=%d res#=%d last=%p notify=%s"
+qxl_ring_res_push_rest(int qid, uint32_t ring_has, uint32_t ring_size, uint32_t prod, uint32_t cons) "%d ring %d/%d [%d,%d]"
+qxl_ring_res_put(int qid, uint32_t free_res) "%d #res=%d"
+qxl_set_mode(int qid, int modenr, uint32_t x_res, uint32_t y_res, uint32_t bits, uint64_t devmem) "%d mode=%d [ x=%d y=%d @ bpp=%d devmem=0x%" PRIx64 " ]"
+qxl_soft_reset(int qid) "%d"
+qxl_spice_destroy_surfaces_complete(int qid) "%d"
+qxl_spice_destroy_surfaces(int qid, int async) "%d async=%d"
+qxl_spice_destroy_surface_wait_complete(int qid, uint32_t id) "%d sid=%d"
+qxl_spice_destroy_surface_wait(int qid, uint32_t id, int async) "%d sid=%d async=%d"
+qxl_spice_flush_surfaces_async(int qid, uint32_t surface_count, uint32_t num_free_res) "%d s#=%d, res#=%d"
+qxl_spice_monitors_config(int qid) "%d"
+qxl_spice_loadvm_commands(int qid, void *ext, uint32_t count) "%d ext=%p count=%d"
+qxl_spice_oom(int qid) "%d"
+qxl_spice_reset_cursor(int qid) "%d"
+qxl_spice_reset_image_cache(int qid) "%d"
+qxl_spice_reset_memslots(int qid) "%d"
+qxl_spice_update_area(int qid, uint32_t surface_id, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom) "%d sid=%d [%d,%d,%d,%d]"
+qxl_spice_update_area_rest(int qid, uint32_t num_dirty_rects, uint32_t clear_dirty_region) "%d #d=%d clear=%d"
+qxl_surfaces_dirty(int qid, int surface, int offset, int size) "%d surface=%d offset=%d size=%d"
+qxl_send_events(int qid, uint32_t events) "%d %d"
+qxl_send_events_vm_stopped(int qid, uint32_t events) "%d %d"
+qxl_set_guest_bug(int qid) "%d"
+qxl_interrupt_client_monitors_config(int qid, int num_heads, void *heads) "%d %d %p"
+qxl_client_monitors_config_unsupported_by_guest(int qid, uint32_t int_mask, void *client_monitors_config) "%d %X %p"
+qxl_client_monitors_config_unsupported_by_device(int qid, int revision) "%d revision=%d"
+qxl_client_monitors_config_capped(int qid, int requested, int limit) "%d %d %d"
+qxl_client_monitors_config_crc(int qid, unsigned size, uint32_t crc32) "%d %u %u"
+qxl_set_client_capabilities_unsupported_by_revision(int qid, int revision) "%d revision=%d"
+
+# ui/spice-display.c
+qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async) "%d %u: host virt 0x%lx - 0x%lx async=%d"
+qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id) "%d gid=%u sid=%u"
+qemu_spice_create_primary_surface(int qid, uint32_t sid, void *surface, int async) "%d sid=%u surface=%p async=%d"
+qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async) "%d sid=%u async=%d"
+qemu_spice_wakeup(uint32_t qid) "%d"
+qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom) "lr %d -> %d,  tb -> %d -> %d"
+
+# hw/display/qxl-render.c
+qxl_render_blit(int32_t stride, int32_t left, int32_t right, int32_t top, int32_t bottom) "stride=%d [%d, %d, %d, %d]"
+qxl_render_guest_primary_resized(int32_t width, int32_t height, int32_t stride, int32_t bytes_pp, int32_t bits_pp) "%dx%d, stride %d, bpp %d, depth %d"
+qxl_render_update_area_done(void *cookie) "%p"
+
+# hw/ppc/spapr_pci.c
+spapr_pci_msi(const char *msg, uint32_t ca) "%s (cfg=%x)"
+spapr_pci_msi_setup(const char *name, unsigned vector, uint64_t addr) "dev\"%s\" vector %u, addr=%"PRIx64
+spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first) "cfgaddr %x func %u, requested %u, first irq %u"
+spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr) "queries for #%u, IRQ%u"
+spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq) "@%"PRIx64"<=%"PRIx64" IRQ %u"
+spapr_pci_lsi_set(const char *busname, int pin, uint32_t irq) "%s PIN%d IRQ %u"
+spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs) "Guest device at %x asked %u, have only %u"
+
+# hw/pci/pci.c
+pci_update_mappings_del(void *d, uint32_t bus, uint32_t func, uint32_t slot, int bar, uint64_t addr, uint64_t size) "d=%p %02x:%02x.%x %d,%#"PRIx64"+%#"PRIx64
+pci_update_mappings_add(void *d, uint32_t bus, uint32_t func, uint32_t slot, int bar, uint64_t addr, uint64_t size) "d=%p %02x:%02x.%x %d,%#"PRIx64"+%#"PRIx64
+
+# hw/net/pcnet.c
+pcnet_s_reset(void *s) "s=%p"
+pcnet_user_int(void *s) "s=%p"
+pcnet_isr_change(void *s, uint32_t isr, uint32_t isr_old) "s=%p INTA=%d<=%d"
+pcnet_init(void *s, uint64_t init_addr) "s=%p init_addr=%#"PRIx64
+pcnet_rlen_tlen(void *s, uint32_t rlen, uint32_t tlen) "s=%p rlen=%d tlen=%d"
+pcnet_ss32_rdra_tdra(void *s, uint32_t ss32, uint32_t rdra, uint32_t rcvrl, uint32_t tdra, uint32_t xmtrl) "s=%p ss32=%d rdra=0x%08x[%d] tdra=0x%08x[%d]"
+
+# hw/net/pcnet-pci.c
+pcnet_aprom_writeb(void *opaque, uint32_t addr, uint32_t val) "opaque=%p addr=0x%08x val=0x%02x"
+pcnet_aprom_readb(void *opaque, uint32_t addr, uint32_t val) "opaque=%p addr=0x%08x val=0x%02x"
+pcnet_ioport_read(void *opaque, uint64_t addr, unsigned size) "opaque=%p addr=%#"PRIx64" size=%d"
+pcnet_ioport_write(void *opaque, uint64_t addr, uint64_t data, unsigned size) "opaque=%p addr=%#"PRIx64" data=%#"PRIx64" size=%d"
+pcnet_mmio_writeb(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+pcnet_mmio_writew(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+pcnet_mmio_writel(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+pcnet_mmio_readb(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+pcnet_mmio_readw(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+pcnet_mmio_readl(void *opaque, uint64_t addr, uint32_t val) "opaque=%p addr=%#"PRIx64" val=0x%x"
+
+# hw/intc/xics.c
+xics_icp_check_ipi(int server, uint8_t mfrr) "CPU %d can take IPI mfrr=%#x"
+xics_icp_accept(uint32_t old_xirr, uint32_t new_xirr) "icp_accept: XIRR %#"PRIx32"->%#"PRIx32
+xics_icp_eoi(int server, uint32_t xirr, uint32_t new_xirr) "icp_eoi: server %d given XIRR %#"PRIx32" new XIRR %#"PRIx32
+xics_icp_irq(int server, int nr, uint8_t priority) "cpu %d trying to deliver irq %#"PRIx32" priority %#x"
+xics_icp_raise(uint32_t xirr, uint8_t pending_priority) "raising IRQ new XIRR=%#x new pending priority=%#x"
+xics_set_irq_msi(int srcno, int nr) "set_irq_msi: srcno %d [irq %#x]"
+xics_masked_pending(void) "set_irq_msi: masked pending"
+xics_set_irq_lsi(int srcno, int nr) "set_irq_lsi: srcno %d [irq %#x]"
+xics_ics_write_xive(int nr, int srcno, int server, uint8_t priority) "ics_write_xive: irq %#x [src %d] server %#x prio %#x"
+xics_ics_reject(int nr, int srcno) "reject irq %#x [src %d]"
+xics_ics_eoi(int nr) "ics_eoi: irq %#x"
+xics_alloc(int src, int irq) "source#%d, irq %d"
+xics_alloc_failed_hint(int src, int irq) "source#%d, irq %d is already in use"
+xics_alloc_failed_no_left(int src) "source#%d, no irq left"
+xics_alloc_block(int src, int first, int num, bool lsi, int align) "source#%d, first irq %d, %d irqs, lsi=%d, alignnum %d"
+xics_ics_free(int src, int irq, int num) "Source#%d, first irq %d, %d irqs"
+xics_ics_free_warn(int src, int irq) "Source#%d, irq %d is already free"
+
+# hw/ppc/spapr.c
+spapr_cas_failed(unsigned long n) "DT diff buffer is too small: %ld bytes"
+spapr_cas_continue(unsigned long n) "Copy changes to the guest: %ld bytes"
+
+# hw/ppc/spapr_hcall.c
+spapr_cas_pvr_try(uint32_t pvr) "%x"
+spapr_cas_pvr(uint32_t cur_pvr, bool cpu_match, uint32_t new_pvr, uint64_t pcr) "current=%x, cpu_match=%u, new=%x, compat flags=%"PRIx64
+
+# hw/ppc/spapr_iommu.c
+spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret) "liobn=%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64
+spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce) "liobn=%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64
+spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret) "liobn=%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64
+spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret) "liobn=%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64
+spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize) "liobn=%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=%x"
+spapr_iommu_new_table(uint64_t liobn, void *tcet, void *table, int fd) "liobn=%"PRIx64" tcet=%p table=%p fd=%d"
+
+# hw/ppc/ppc.c
+ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds) "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)"
+
+# util/hbitmap.c
+hbitmap_iter_skip_words(const void *hb, void *hbi, uint64_t pos, unsigned long cur) "hb %p hbi %p pos %"PRId64" cur 0x%lx"
+hbitmap_reset(void *hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit) "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64
+hbitmap_set(void *hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit) "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64
+
+# target-s390x/ioinst.c
+ioinst(const char *insn) "IOINST: %s"
+ioinst_sch_id(const char *insn, int cssid, int ssid, int schid) "IOINST: %s (%x.%x.%04x)"
+ioinst_chp_id(const char *insn, int cssid, int chpid) "IOINST: %s (%x.%02x)"
+ioinst_chsc_cmd(uint16_t cmd, uint16_t len) "IOINST: chsc command %04x, len %04x"
+
+# hw/s390x/css.c
+css_enable_facility(const char *facility) "CSS: enable %s"
+css_crw(uint8_t rsc, uint8_t erc, uint16_t rsid, const char *chained) "CSS: queueing crw: rsc=%x, erc=%x, rsid=%x %s"
+css_chpid_add(uint8_t cssid, uint8_t chpid, uint8_t type) "CSS: add chpid %x.%02x (type %02x)"
+css_new_image(uint8_t cssid, const char *default_cssid) "CSS: add css image %02x %s"
+css_assign_subch(const char *do_assign, uint8_t cssid, uint8_t ssid, uint16_t schid, uint16_t devno) "CSS: %s %x.%x.%04x (devno %04x)"
+css_io_interrupt(int cssid, int ssid, int schid, uint32_t intparm, uint8_t isc, const char *conditional) "CSS: I/O interrupt on sch %x.%x.%04x (intparm %08x, isc %x) %s"
+css_adapter_interrupt(uint8_t isc) "CSS: adapter I/O interrupt (isc %x)"
+
+# hw/s390x/virtio-ccw.c
+virtio_ccw_interpret_ccw(int cssid, int ssid, int schid, int cmd_code) "VIRTIO-CCW: %x.%x.%04x: interpret command %x"
+virtio_ccw_new_device(int cssid, int ssid, int schid, int devno, const char *devno_mode) "VIRTIO-CCW: add subchannel %x.%x.%04x, devno %04x (%s)"
+
+# hw/intc/s390_flic_kvm.c
+flic_create_device(int err) "flic: create device failed %d"
+flic_no_device_api(int err) "flic: no Device Contral API support %d"
+flic_reset_failed(int err) "flic: reset failed %d"
+
+# migration.c
+migrate_set_state(int new_state) "new state %d"
+migrate_fd_cleanup(void) ""
+migrate_fd_error(void) ""
+migrate_fd_cancel(void) ""
+migrate_pending(uint64_t size, uint64_t max) "pending size %" PRIu64 " max %" PRIu64
+migrate_transferred(uint64_t tranferred, uint64_t time_spent, double bandwidth, uint64_t size) "transferred %" PRIu64 " time_spent %" PRIu64 " bandwidth %g max_size %" PRId64
+
+# migration/rdma.c
+qemu_dma_accept_incoming_migration(void) ""
+qemu_dma_accept_incoming_migration_accepted(void) ""
+qemu_rdma_accept_pin_state(bool pin) "%d"
+qemu_rdma_accept_pin_verbsc(void *verbs) "Verbs context after listen: %p"
+qemu_rdma_block_for_wrid_miss(const char *wcompstr, int wcomp, const char *gcompstr, uint64_t req) "A Wanted wrid %s (%d) but got %s (%" PRIu64 ")"
+qemu_rdma_block_for_wrid_miss_b(const char *wcompstr, int wcomp, const char *gcompstr, uint64_t req) "B Wanted wrid %s (%d) but got %s (%" PRIu64 ")"
+qemu_rdma_cleanup_disconnect(void) ""
+qemu_rdma_cleanup_waiting_for_disconnect(void) ""
+qemu_rdma_close(void) ""
+qemu_rdma_connect_pin_all_requested(void) ""
+qemu_rdma_connect_pin_all_outcome(bool pin) "%d"
+qemu_rdma_dest_init_trying(const char *host, const char *ip) "%s => %s"
+qemu_rdma_dump_gid(const char *who, const char *src, const char *dst) "%s Source GID: %s, Dest GID: %s"
+qemu_rdma_exchange_get_response_start(const char *desc) "CONTROL: %s receiving..."
+qemu_rdma_exchange_get_response_none(const char *desc, int type) "Surprise: got %s (%d)"
+qemu_rdma_exchange_send_issue_callback(void) ""
+qemu_rdma_exchange_send_waiting(const char *desc) "Waiting for response %s"
+qemu_rdma_exchange_send_received(const char *desc) "Response %s received."
+qemu_rdma_fill(int64_t control_len, int size) "RDMA %" PRId64 " of %d bytes already in buffer"
+qemu_rdma_init_ram_blocks(int blocks) "Allocated %d local ram block structures"
+qemu_rdma_poll_recv(const char *compstr, int64_t comp, int64_t id, int sent) "completion %s #%" PRId64 " received (%" PRId64 ") left %d"
+qemu_rdma_poll_write(const char *compstr, int64_t comp, int left, uint64_t block, uint64_t chunk, void *local, void *remote) "completions %s (%" PRId64 ") left %d, block %" PRIu64 ", chunk: %" PRIu64 " %p %p"
+qemu_rdma_poll_other(const char *compstr, int64_t comp, int left) "other completion %s (%" PRId64 ") received left %d"
+qemu_rdma_post_send_control(const char *desc) "CONTROL: sending %s.."
+qemu_rdma_register_and_get_keys(uint64_t len, void *start) "Registering %" PRIu64 " bytes @ %p"
+qemu_rdma_registration_handle_compress(int64_t length, int index, int64_t offset) "Zapping zero chunk: %" PRId64 " bytes, index %d, offset %" PRId64
+qemu_rdma_registration_handle_finished(void) ""
+qemu_rdma_registration_handle_ram_blocks(void) ""
+qemu_rdma_registration_handle_register(int requests) "%d requests"
+qemu_rdma_registration_handle_register_loop(int req, int index, uint64_t addr, uint64_t chunks) "Registration request (%d): index %d, current_addr %" PRIu64 " chunks: %" PRIu64
+qemu_rdma_registration_handle_register_rkey(int rkey) "%x"
+qemu_rdma_registration_handle_unregister(int requests) "%d requests"
+qemu_rdma_registration_handle_unregister_loop(int count, int index, uint64_t chunk) "Unregistration request (%d): index %d, chunk %" PRIu64
+qemu_rdma_registration_handle_unregister_success(uint64_t chunk) "%" PRIu64
+qemu_rdma_registration_handle_wait(uint64_t flags) "Waiting for next request %" PRIu64
+qemu_rdma_registration_start(uint64_t flags) "%" PRIu64
+qemu_rdma_registration_stop(uint64_t flags) "%" PRIu64
+qemu_rdma_registration_stop_ram(void) ""
+qemu_rdma_resolve_host_trying(const char *host, const char *ip) "Trying %s => %s"
+qemu_rdma_signal_unregister_append(uint64_t chunk, int pos) "Appending unregister chunk %" PRIu64 " at position %d"
+qemu_rdma_signal_unregister_already(uint64_t chunk) "Unregister chunk %" PRIu64 " already in queue"
+qemu_rdma_unregister_waiting_inflight(uint64_t chunk) "Cannot unregister inflight chunk: %" PRIu64
+qemu_rdma_unregister_waiting_proc(uint64_t chunk, int pos) "Processing unregister for chunk: %" PRIu64 " at position %d"
+qemu_rdma_unregister_waiting_send(uint64_t chunk) "Sending unregister for chunk: %" PRIu64
+qemu_rdma_unregister_waiting_complete(uint64_t chunk) "Unregister for chunk: %" PRIu64 " complete."
+qemu_rdma_write_flush(int sent) "sent total: %d"
+qemu_rdma_write_one_block(int count, int block, uint64_t chunk, uint64_t current, uint64_t len, int nb_sent, int nb_chunks) "(%d) Not clobbering: block: %d chunk %" PRIu64 " current %" PRIu64 " len %" PRIu64 " %d %d"
+qemu_rdma_write_one_post(uint64_t chunk, long addr, long remote, uint32_t len) "Posting chunk: %" PRIu64 ", addr: %lx remote: %lx, bytes %" PRIu32
+qemu_rdma_write_one_queue_full(void) ""
+qemu_rdma_write_one_recvregres(int mykey, int theirkey, uint64_t chunk) "Received registration result: my key: %x their key %x, chunk %" PRIu64
+qemu_rdma_write_one_sendreg(uint64_t chunk, int len, int index, int64_t offset) "Sending registration request chunk %" PRIu64 " for %d bytes, index: %d, offset: %" PRId64
+qemu_rdma_write_one_top(uint64_t chunks, uint64_t size) "Writing %" PRIu64 " chunks, (%" PRIu64 " MB)"
+qemu_rdma_write_one_zero(uint64_t chunk, int len, int index, int64_t offset) "Entire chunk is zero, sending compress: %" PRIu64 " for %d bytes, index: %d, offset: %" PRId64
+rdma_add_block(int block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks) "Added Block: %d, addr: %" PRIu64 ", offset: %" PRIu64 " length: %" PRIu64 " end: %" PRIu64 " bits %" PRIu64 " chunks %d"
+rdma_delete_block(int block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks) "Deleted Block: %d, addr: %" PRIu64 ", offset: %" PRIu64 " length: %" PRIu64 " end: %" PRIu64 " bits %" PRIu64 " chunks %d"
+rdma_start_incoming_migration(void) ""
+rdma_start_incoming_migration_after_dest_init(void) ""
+rdma_start_incoming_migration_after_rdma_listen(void) ""
+rdma_start_outgoing_migration_after_rdma_connect(void) ""
+rdma_start_outgoing_migration_after_rdma_source_init(void) ""
+
+# kvm-all.c
+kvm_ioctl(int type, void *arg) "type 0x%x, arg %p"
+kvm_vm_ioctl(int type, void *arg) "type 0x%x, arg %p"
+kvm_vcpu_ioctl(int cpu_index, int type, void *arg) "cpu_index %d, type 0x%x, arg %p"
+kvm_run_exit(int cpu_index, uint32_t reason) "cpu_index %d, reason %d"
+kvm_device_ioctl(int fd, int type, void *arg) "dev fd %d, type 0x%x, arg %p"
+kvm_failed_reg_get(uint64_t id, const char *msg) "Warning: Unable to retrieve ONEREG %" PRIu64 " from KVM: %s"
+kvm_failed_reg_set(uint64_t id, const char *msg) "Warning: Unable to set ONEREG %" PRIu64 " to KVM: %s"
+
+# target-ppc/kvm.c
+kvm_failed_spr_set(int str, const char *msg) "Warning: Unable to set SPR %d to KVM: %s"
+kvm_failed_spr_get(int str, const char *msg) "Warning: Unable to retrieve SPR %d from KVM: %s"
+
+# TCG related tracing (mostly disabled by default)
+# cpu-exec.c
+disable exec_tb(void *tb, uintptr_t pc) "tb:%p pc=0x%"PRIxPTR
+disable exec_tb_nocache(void *tb, uintptr_t pc) "tb:%p pc=0x%"PRIxPTR
+disable exec_tb_exit(void *next_tb, unsigned int flags) "tb:%p flags=%x"
+
+# translate-all.c
+translate_block(void *tb, uintptr_t pc, uint8_t *tb_code) "tb:%p, pc:0x%"PRIxPTR", tb_code:%p"
+
+# memory.c
+memory_region_ops_read(void *mr, uint64_t addr, uint64_t value, unsigned size) "mr %p addr %#"PRIx64" value %#"PRIx64" size %u"
+memory_region_ops_write(void *mr, uint64_t addr, uint64_t value, unsigned size) "mr %p addr %#"PRIx64" value %#"PRIx64" size %u"
+
+# qom/object.c
+object_dynamic_cast_assert(const char *type, const char *target, const char *file, int line, const char *func) "%s->%s (%s:%d:%s)"
+object_class_dynamic_cast_assert(const char *type, const char *target, const char *file, int line, const char *func) "%s->%s (%s:%d:%s)"
+
+# hw/i386/xen/xen_pvdevice.c
+xen_pv_mmio_read(uint64_t addr) "WARNING: read from Xen PV Device MMIO space (address %"PRIx64")"
+xen_pv_mmio_write(uint64_t addr) "WARNING: write to Xen PV Device MMIO space (address %"PRIx64")"
+
+# hw/pci/pci_host.c
+pci_cfg_read(const char *dev, unsigned devid, unsigned fnid, unsigned offs, unsigned val) "%s %02u:%u @0x%x -> 0x%x"
+pci_cfg_write(const char *dev, unsigned devid, unsigned fnid, unsigned offs, unsigned val) "%s %02u:%u @0x%x <- 0x%x"
+
+# hw/vfio/vfio-pci.c
+vfio_intx_interrupt(const char *name, char line) " (%s) Pin %c"
+vfio_eoi(const char *name) " (%s) EOI"
+vfio_enable_intx_kvm(const char *name) " (%s) KVM INTx accel enabled"
+vfio_disable_intx_kvm(const char *name) " (%s) KVM INTx accel disabled"
+vfio_update_irq(const char *name, int new_irq, int target_irq) " (%s) IRQ moved %d -> %d"
+vfio_enable_intx(const char *name) " (%s)"
+vfio_disable_intx(const char *name) " (%s)"
+vfio_msi_interrupt(const char *name, int index, uint64_t addr, int data) " (%s) vector %d 0x%"PRIx64"/0x%x"
+vfio_msix_vector_do_use(const char *name, int index) " (%s) vector %d used"
+vfio_msix_vector_release(const char *name, int index) " (%s) vector %d released"
+vfio_enable_msix(const char *name) " (%s)"
+vfio_enable_msi(const char *name, int nr_vectors) " (%s) Enabled %d MSI vectors"
+vfio_disable_msix(const char *name) " (%s)"
+vfio_disable_msi(const char *name) " (%s)"
+vfio_pci_load_rom(const char *name, unsigned long size, unsigned long offset, unsigned long flags) "Device %s ROM:\n  size: 0x%lx, offset: 0x%lx, flags: 0x%lx"
+vfio_rom_read(const char *name, uint64_t addr, int size, uint64_t data) " (%s, 0x%"PRIx64", 0x%x) = 0x%"PRIx64
+vfio_pci_size_rom(const char *name, int size) "%s ROM size 0x%x"
+vfio_vga_write(uint64_t addr, uint64_t data, int size) " (0x%"PRIx64", 0x%"PRIx64", %d)"
+vfio_vga_read(uint64_t addr, int size, uint64_t data) " (0x%"PRIx64", %d) = 0x%"PRIx64
+# remove ) =
+vfio_generic_window_quirk_read(const char * region_name, const char *name, int index, uint64_t addr, int size, uint64_t data) "%s read(%s:BAR%d+0x%"PRIx64", %d = 0x%"PRIx64
+## remove )
+vfio_generic_window_quirk_write(const char * region_name, const char *name, int index, uint64_t addr, uint64_t data, int size) "%s write(%s:BAR%d+0x%"PRIx64", 0x%"PRIx64", %d"
+# remove ) =
+vfio_generic_quirk_read(const char * region_name, const char *name, int index, uint64_t addr, int size, uint64_t data) "%s read(%s:BAR%d+0x%"PRIx64", %d = 0x%"PRIx64
+# remove )
+vfio_generic_quirk_write(const char * region_name, const char *name, int index, uint64_t addr, uint64_t data, int size) "%s write(%s:BAR%d+0x%"PRIx64", 0x%"PRIx64", %d"
+vfio_ati_3c3_quirk_read(uint64_t data) " (0x3c3, 1) = 0x%"PRIx64
+vfio_vga_probe_ati_3c3_quirk(const char *name) "Enabled ATI/AMD quirk 0x3c3 BAR4for device %s"
+vfio_probe_ati_bar4_window_quirk(const char *name) "Enabled ATI/AMD BAR4 window quirk for device %s"
+#issue with )
+vfio_rtl8168_window_quirk_read_fake(const char *region_name, const char *name) "%s fake read(%s"
+vfio_rtl8168_window_quirk_read_table(const char *region_name, const char *name) "%s MSI-X table read(%s"
+vfio_rtl8168_window_quirk_read_direct(const char *region_name, const char *name) "%s direct read(%s"
+vfio_rtl8168_window_quirk_write_table(const char *region_name, const char *name) "%s MSI-X table write(%s"
+vfio_rtl8168_window_quirk_write_direct(const char *region_name, const char *name) "%s direct write(%s"
+vfio_probe_rtl8168_bar2_window_quirk(const char *name) "Enabled RTL8168 BAR2 window quirk for device %s"
+vfio_probe_ati_bar2_4000_quirk(const char *name) "Enabled ATI/AMD BAR2 0x4000 quirk for device %s"
+vfio_nvidia_3d0_quirk_read(int size, uint64_t data) " (0x3d0, %d) = 0x%"PRIx64
+vfio_nvidia_3d0_quirk_write(uint64_t data, int size) " (0x3d0, 0x%"PRIx64", %d)"
+vfio_vga_probe_nvidia_3d0_quirk(const char *name) "Enabled NVIDIA VGA 0x3d0 quirk for device %s"
+vfio_probe_nvidia_bar5_window_quirk(const char *name) "Enabled NVIDIA BAR5 window quirk for device %s"
+vfio_probe_nvidia_bar0_88000_quirk(const char *name) "Enabled NVIDIA BAR0 0x88000 quirk for device %s"
+vfio_probe_nvidia_bar0_1800_quirk_id(int id) "Nvidia NV%02x"
+vfio_probe_nvidia_bar0_1800_quirk(const char *name) "Enabled NVIDIA BAR0 0x1800 quirk for device %s"
+vfio_pci_read_config(const char *name, int addr, int len, int val) " (%s, @0x%x, len=0x%x) %x"
+vfio_pci_write_config(const char *name, int addr, int val, int len) " (%s, @0x%x, 0x%x, len=0x%x)"
+vfio_setup_msi(const char *name, int pos) "%s PCI MSI CAP @0x%x"
+vfio_early_setup_msix(const char *name, int pos, int table_bar, int offset, int entries) "%s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%x, entries %d"
+vfio_check_pcie_flr(const char *name) "%s Supports FLR via PCIe cap"
+vfio_check_pm_reset(const char *name) "%s Supports PM reset"
+vfio_check_af_flr(const char *name) "%s Supports FLR via AF cap"
+vfio_pci_hot_reset(const char *name, const char *type) " (%s) %s"
+vfio_pci_hot_reset_has_dep_devices(const char *name) "%s: hot reset dependent devices:"
+vfio_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int group_id) "\t%04x:%02x:%02x.%x group %d"
+vfio_pci_hot_reset_result(const char *name, const char *result) "%s hot reset: %s"
+vfio_populate_device_region(const char *region_name, int index, unsigned long size, unsigned long offset, unsigned long flags) "Device %s region %d:\n  size: 0x%lx, offset: 0x%lx, flags: 0x%lx"
+vfio_populate_device_config(const char *name, unsigned long size, unsigned long offset, unsigned long flags) "Device %s config:\n  size: 0x%lx, offset: 0x%lx, flags: 0x%lx"
+vfio_populate_device_get_irq_info_failure(void) "VFIO_DEVICE_GET_IRQ_INFO failure: %m"
+vfio_initfn(const char *name, int group_id) " (%s) group %d"
+vfio_pci_reset(const char *name) " (%s)"
+vfio_pci_reset_flr(const char *name) "%s FLR/VFIO_DEVICE_RESET"
+vfio_pci_reset_pm(const char *name) "%s PCI PM Reset"
+
+# hw/vfio/vfio-common.c
+vfio_region_write(const char *name, int index, uint64_t addr, uint64_t data, unsigned size) " (%s:region%d+0x%"PRIx64", 0x%"PRIx64 ", %d)"
+vfio_region_read(char *name, int index, uint64_t addr, unsigned size, uint64_t data) " (%s:region%d+0x%"PRIx64", %d) = 0x%"PRIx64
+vfio_iommu_map_notify(uint64_t iova_start, uint64_t iova_end) "iommu map @ %"PRIx64" - %"PRIx64
+vfio_listener_region_add_skip(uint64_t start, uint64_t end) "SKIPPING region_add %"PRIx64" - %"PRIx64
+vfio_listener_region_add_iommu(uint64_t start, uint64_t end) "region_add [iommu] %"PRIx64" - %"PRIx64
+vfio_listener_region_add_ram(uint64_t iova_start, uint64_t iova_end, void *vaddr) "region_add [ram] %"PRIx64" - %"PRIx64" [%p]"
+vfio_listener_region_del_skip(uint64_t start, uint64_t end) "SKIPPING region_del %"PRIx64" - %"PRIx64
+vfio_listener_region_del(uint64_t start, uint64_t end) "region_del %"PRIx64" - %"PRIx64
+vfio_disconnect_container(int fd) "close container->fd=%d"
+vfio_put_group(int fd) "close group->fd=%d"
+vfio_get_device(const char * name, unsigned int flags, unsigned int num_regions, unsigned int num_irqs) "Device %s flags: %u, regions: %u, irqs: %u"
+vfio_put_base_device(int fd) "close vdev->fd=%d"
+
+#hw/acpi/memory_hotplug.c
+mhp_acpi_invalid_slot_selected(uint32_t slot) "0x%"PRIx32
+mhp_acpi_read_addr_lo(uint32_t slot, uint32_t addr) "slot[0x%"PRIx32"] addr lo: 0x%"PRIx32
+mhp_acpi_read_addr_hi(uint32_t slot, uint32_t addr) "slot[0x%"PRIx32"] addr hi: 0x%"PRIx32
+mhp_acpi_read_size_lo(uint32_t slot, uint32_t size) "slot[0x%"PRIx32"] size lo: 0x%"PRIx32
+mhp_acpi_read_size_hi(uint32_t slot, uint32_t size) "slot[0x%"PRIx32"] size hi: 0x%"PRIx32
+mhp_acpi_read_pxm(uint32_t slot, uint32_t pxm) "slot[0x%"PRIx32"] proximity: 0x%"PRIx32
+mhp_acpi_read_flags(uint32_t slot, uint32_t flags) "slot[0x%"PRIx32"] flags: 0x%"PRIx32
+mhp_acpi_write_slot(uint32_t slot) "set active slot: 0x%"PRIx32
+mhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev) "slot[0x%"PRIx32"] OST EVENT: 0x%"PRIx32
+mhp_acpi_write_ost_status(uint32_t slot, uint32_t st) "slot[0x%"PRIx32"] OST STATUS: 0x%"PRIx32
+mhp_acpi_clear_insert_evt(uint32_t slot) "slot[0x%"PRIx32"] clear insert event"
+
+# hw/i386/pc.c
+mhp_pc_dimm_assigned_slot(int slot) "0x%d"
+mhp_pc_dimm_assigned_address(uint64_t addr) "0x%"PRIx64
+
+# target-s390x/kvm.c
+kvm_enable_cmma(int rc) "CMMA: enabling with result code %d"
+kvm_clear_cmma(int rc) "CMMA: clearing with result code %d"
+kvm_failed_cpu_state_set(int cpu_index, uint8_t state, const char *msg) "Warning: Unable to set cpu %d state %" PRIu8 " to KVM: %s"
+kvm_sigp_finished(uint8_t order, int cpu_index, int dst_index, int cc) "SIGP: Finished order %u on cpu %d -> cpu %d with cc=%d"
+
+# hw/dma/i8257.c
+i8257_unregistered_dma(int nchan, int dma_pos, int dma_len) "unregistered DMA channel used nchan=%d dma_pos=%d dma_len=%d"
+
+# target-s390x/cpu.c
+cpu_set_state(int cpu_index, uint8_t state) "setting cpu %d state to %" PRIu8
+cpu_halt(int cpu_index) "halting cpu %d"
+cpu_unhalt(int cpu_index) "unhalting cpu %d"
diff --git a/qemu/share/qemu/u-boot.e500 b/qemu/share/qemu/u-boot.e500
new file mode 100644
index 0000000..bdb2a5e
Binary files /dev/null and b/qemu/share/qemu/u-boot.e500 differ
diff --git a/qemu/share/qemu/vgabios-cirrus.bin b/qemu/share/qemu/vgabios-cirrus.bin
new file mode 100644
index 0000000..02227d3
Binary files /dev/null and b/qemu/share/qemu/vgabios-cirrus.bin differ
diff --git a/qemu/share/qemu/vgabios-qxl.bin b/qemu/share/qemu/vgabios-qxl.bin
new file mode 100644
index 0000000..8a87c23
Binary files /dev/null and b/qemu/share/qemu/vgabios-qxl.bin differ
diff --git a/qemu/share/qemu/vgabios-stdvga.bin b/qemu/share/qemu/vgabios-stdvga.bin
new file mode 100644
index 0000000..00cb73c
Binary files /dev/null and b/qemu/share/qemu/vgabios-stdvga.bin differ
diff --git a/qemu/share/qemu/vgabios-vmware.bin b/qemu/share/qemu/vgabios-vmware.bin
new file mode 100644
index 0000000..c9a94f9
Binary files /dev/null and b/qemu/share/qemu/vgabios-vmware.bin differ
diff --git a/qemu/share/qemu/vgabios.bin b/qemu/share/qemu/vgabios.bin
new file mode 100644
index 0000000..3e3335d
Binary files /dev/null and b/qemu/share/qemu/vgabios.bin differ
diff --git a/user/dumbfork.c b/user/dumbfork.c
index e5e433c..8c3466f 100644
--- a/user/dumbfork.c
+++ b/user/dumbfork.c
@@ -16,7 +16,7 @@ umain(int argc, char **argv)
 	who = dumbfork();
 
 	// print a message and yield to the other a few times
-	for (i = 0; i < (who ? 10 : 20); i++) {
+	for (i = 0; i < (who ? 30 : 20); i++) {
 		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
 		sys_yield();
 	}
diff --git a/user/faultallocbad.c b/user/faultallocbad.c
index 2c0898a..19ad2f1 100644
--- a/user/faultallocbad.c
+++ b/user/faultallocbad.c
@@ -2,7 +2,8 @@
 // doesn't work because we sys_cputs instead of cprintf (exercise: why?)
 
 #include <inc/lib.h>
-
+//const char *hello = "hello, world\n";
+//const char *DEADBEEF = "hello, world\n";
 void
 handler(struct UTrapframe *utf)
 {
@@ -20,5 +21,20 @@ void
 umain(int argc, char **argv)
 {
 	set_pgfault_handler(handler);
+	
 	sys_cputs((char*)0xDEADBEEF, 4);
+	
+	//sys_cputs((char*)0xeebfe000, 1024);//failure:ustacktop//
+	//sys_cputs((char*)0xeebfefff, 1024);//failure:emptymemory:user exception stack+1//
+	//sys_cputs((char*)0xeebff000, 1024);//no failure: user exception stack//
+	//sys_cputs((char*)0xef400000, 1024);//no failure: uvpt//
+	//sys_cputs((char*)0xef7fffff, 1024);//no failure: ulim-1//
+	//sys_cputs((char*)0xef800000, 1024);//failure: ulim//	
+
+/****************no failure when the address range is between uxstacktop and ulim**************/
+
+
+	//sys_cputs("0xDEADBEEF\n", 1024);
+	//sys_cputs(DEADBEEF, 1024);
+	//sys_cputs(hello, 1024);
 }
diff --git a/user/faultdie.c b/user/faultdie.c
index 4959d11..76e1d65 100644
--- a/user/faultdie.c
+++ b/user/faultdie.c
@@ -7,6 +7,7 @@ handler(struct UTrapframe *utf)
 {
 	void *addr = (void*)utf->utf_fault_va;
 	uint32_t err = utf->utf_err;
+        cprintf("error= %x\n",err);
 	cprintf("i faulted at va %x, err %x\n", addr, err & 7);
 	sys_env_destroy(sys_getenvid());
 }
diff --git a/user/httpd.c b/user/httpd.c
index ede43bf..7953e5d 100644
--- a/user/httpd.c
+++ b/user/httpd.c
@@ -77,6 +77,30 @@ static int
 send_data(struct http_request *req, int fd)
 {
 	// LAB 6: Your code here.
+	char * buf;
+ int r;
+ struct Stat stat;
+
+ if ((r = fstat(fd, &stat)) < 0) {
+   die("send_data failed: fstat failed");
+ }
+
+ if (stat.st_size > 1518) {
+   die("send_data failed: size larger than 1518");
+ }
+
+ buf = malloc(stat.st_size);
+
+ if ((r = readn(fd, buf, stat.st_size)) != stat.st_size) {
+   die("send_data failed: couldn't read entire data");
+ }
+
+ if ((r = write(req->sock, buf, stat.st_size)) != stat.st_size) {
+   die("send_data failed: couldn't write all data to sock");
+ }
+ free(buf);
+ return 0;
+
 	panic("send_data not implemented");
 }
 
@@ -223,7 +247,26 @@ send_file(struct http_request *req)
 	// set file_size to the size of the file
 
 	// LAB 6: Your code here.
-	panic("send_file not implemented");
+	//panic("send_file not implemented");
+	struct Stat stat;
+
+ if ((fd = open(req->url, O_RDONLY)) < 0) {
+   send_error(req, 404);  // HTTP page not found
+   r = fd;
+   goto end;
+ }
+
+ if ((r = fstat(fd, &stat)) < 0) {
+   goto end;
+ }
+
+ if (stat.st_isdir) {
+   send_error(req, 404); // HTTP page not found
+   r = -1;
+  goto end;
+ }
+
+ file_size = stat.st_size;
 
 	if ((r = send_header(req, 200)) < 0)
 		goto end;
diff --git a/user/sh.c b/user/sh.c
index 26f501a..431a42b 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -55,8 +55,18 @@ again:
 			// then close the original 'fd'.
 
 			// LAB 5: Your code here.
-			panic("< redirection not implemented");
-			break;
+			if ((fd = open(t, O_RDONLY)) < 0)
+     {
+      cprintf("open %s for read: %e", t, fd);
+       exit();
+     }
+     if (fd != 0) {
+       dup(fd, 0);
+       close(fd);
+    }
+     break;
+			//panic("< redirection not implemented");
+			//break;
 
 		case '>':	// Output redirection
 			// Grab the filename from the argument list
